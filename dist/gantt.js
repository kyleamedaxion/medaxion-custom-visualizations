/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/highcharts/highcharts.js":
/*!***********************************************!*\
  !*** ./node_modules/highcharts/highcharts.js ***!
  \***********************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("/* module decorator */ module = __webpack_require__.nmd(module);\nvar __WEBPACK_AMD_DEFINE_RESULT__;function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _iterableToArray(r) { if (\"undefined\" != typeof Symbol && null != r[Symbol.iterator] || null != r[\"@@iterator\"]) return Array.from(r); }\nfunction _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _superPropGet(t, e, r, o) { var p = _get(_getPrototypeOf(1 & o ? t.prototype : t), e, r); return 2 & o ? function (t) { return p.apply(r, t); } : p; }\nfunction _get() { return _get = \"undefined\" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function (e, t, r) { var p = _superPropBase(e, t); if (p) { var n = Object.getOwnPropertyDescriptor(p, t); return n.get ? n.get.call(arguments.length < 3 ? e : r) : n.value; } }, _get.apply(null, arguments); }\nfunction _superPropBase(t, o) { for (; !{}.hasOwnProperty.call(t, o) && null !== (t = _getPrototypeOf(t));); return t; }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _iterableToArrayLimit(r, l) { var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }\nfunction _arrayWithHoles(r) { if (Array.isArray(r)) return r; }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _createForOfIteratorHelper(r, e) { var t = \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && \"number\" == typeof r.length) { t && (r = t); var _n20 = 0, F = function F() {}; return { s: F, n: function n() { return _n20 >= r.length ? { done: !0 } : { done: !1, value: r[_n20++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t[\"return\"] || t[\"return\"](); } finally { if (u) throw o; } } }; }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\n!\n/**\n* Highcharts JS v11.4.7 (2024-08-14)\n*\n* (c) 2009-2024 Torstein Honsi\n*\n* License: www.highcharts.com/license\n*/\nfunction (t, e) {\n  \"object\" == ( false ? 0 : _typeof(module)) && module.exports ? (e[\"default\"] = e, module.exports = t && t.document ? e(t) : e) :  true ? !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {\n    return e(t);\n  }).call(exports, __webpack_require__, exports, module),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : (0);\n}(\"undefined\" != typeof window ? window : this, function (t) {\n  \"use strict\";\n\n  var e = {};\n  function i(e, i, s, r) {\n    !e.hasOwnProperty(i) && (e[i] = r.apply(null, s), t && \"function\" == typeof CustomEvent && t.dispatchEvent(new CustomEvent(\"HighchartsModuleLoaded\", {\n      detail: {\n        path: i,\n        module: e[i]\n      }\n    })));\n  }\n  return i(e, \"Core/Globals.js\", [], function () {\n    var e, i;\n    return (i = e || (e = {})).SVG_NS = \"http://www.w3.org/2000/svg\", i.product = \"Highcharts\", i.version = \"11.4.7\", i.win = void 0 !== t ? t : {}, i.doc = i.win.document, i.svg = i.doc && i.doc.createElementNS && !!i.doc.createElementNS(i.SVG_NS, \"svg\").createSVGRect, i.userAgent = i.win.navigator && i.win.navigator.userAgent || \"\", i.isChrome = i.win.chrome, i.isFirefox = -1 !== i.userAgent.indexOf(\"Firefox\"), i.isMS = /(edge|msie|trident)/i.test(i.userAgent) && !i.win.opera, i.isSafari = !i.isChrome && -1 !== i.userAgent.indexOf(\"Safari\"), i.isTouchDevice = /(Mobile|Android|Windows Phone)/.test(i.userAgent), i.isWebKit = -1 !== i.userAgent.indexOf(\"AppleWebKit\"), i.deg2rad = 2 * Math.PI / 360, i.hasBidiBug = i.isFirefox && 4 > parseInt(i.userAgent.split(\"Firefox/\")[1], 10), i.marginNames = [\"plotTop\", \"marginRight\", \"marginBottom\", \"plotLeft\"], i.noop = function () {}, i.supportsPassiveEvents = function () {\n      var t = !1;\n      if (!i.isMS) {\n        var _e = Object.defineProperty({}, \"passive\", {\n          get: function get() {\n            t = !0;\n          }\n        });\n        i.win.addEventListener && i.win.removeEventListener && (i.win.addEventListener(\"testPassive\", i.noop, _e), i.win.removeEventListener(\"testPassive\", i.noop, _e));\n      }\n      return t;\n    }(), i.charts = [], i.composed = [], i.dateFormats = {}, i.seriesTypes = {}, i.symbolSizes = {}, i.chartCount = 0, e;\n  }), i(e, \"Core/Utilities.js\", [e[\"Core/Globals.js\"]], function (t) {\n    var e;\n    var i = t.charts,\n      s = t.doc,\n      r = t.win;\n    function o(e, i, s, n) {\n      var a = i ? \"Highcharts error\" : \"Highcharts warning\";\n      32 === e && (e = \"\".concat(a, \": Deprecated member\"));\n      var h = p(e),\n        l = h ? \"\".concat(a, \" #\").concat(e, \": www.highcharts.com/errors/\").concat(e, \"/\") : e.toString();\n      if (void 0 !== n) {\n        var _t = \"\";\n        h && (l += \"?\"), C(n, function (e, i) {\n          _t += \"\\n - \".concat(i, \": \").concat(e), h && (l += encodeURI(i) + \"=\" + encodeURI(e));\n        }), l += _t;\n      }\n      M(t, \"displayError\", {\n        chart: s,\n        code: e,\n        message: l,\n        params: n\n      }, function () {\n        if (i) throw Error(l);\n        r.console && -1 === o.messages.indexOf(l) && console.warn(l);\n      }), o.messages.push(l);\n    }\n    function n(t, e) {\n      return parseInt(t, e || 10);\n    }\n    function a(t) {\n      return \"string\" == typeof t;\n    }\n    function h(t) {\n      var e = Object.prototype.toString.call(t);\n      return \"[object Array]\" === e || \"[object Array Iterator]\" === e;\n    }\n    function l(t, e) {\n      return !!t && \"object\" == _typeof(t) && (!e || !h(t));\n    }\n    function d(t) {\n      return l(t) && \"number\" == typeof t.nodeType;\n    }\n    function c(t) {\n      var e = t && t.constructor;\n      return !!(l(t, !0) && !d(t) && e && e.name && \"Object\" !== e.name);\n    }\n    function p(t) {\n      return \"number\" == typeof t && !isNaN(t) && t < 1 / 0 && t > -1 / 0;\n    }\n    function u(t) {\n      return null != t;\n    }\n    function g(t, e, i) {\n      var s;\n      var r = a(e) && !u(i),\n        o = function o(e, i) {\n          u(e) ? t.setAttribute(i, e) : r ? (s = t.getAttribute(i)) || \"class\" !== i || (s = t.getAttribute(i + \"Name\")) : t.removeAttribute(i);\n        };\n      return a(e) ? o(i, e) : C(e, o), s;\n    }\n    function f(t) {\n      return h(t) ? t : [t];\n    }\n    function m(t, e) {\n      var i;\n      for (i in t || (t = {}), e) t[i] = e[i];\n      return t;\n    }\n    function x() {\n      var t = arguments,\n        e = t.length;\n      for (var _i = 0; _i < e; _i++) {\n        var _e2 = t[_i];\n        if (null != _e2) return _e2;\n      }\n    }\n    function y(t, e) {\n      m(t.style, e);\n    }\n    function b(t) {\n      return Math.pow(10, Math.floor(Math.log(t) / Math.LN10));\n    }\n    function v(t, e) {\n      return t > 1e14 ? t : parseFloat(t.toPrecision(e || 14));\n    }\n    (o || (o = {})).messages = [], Math.easeInOutSine = function (t) {\n      return -.5 * (Math.cos(Math.PI * t) - 1);\n    };\n    var S = Array.prototype.find ? function (t, e) {\n      return t.find(e);\n    } : function (t, e) {\n      var i;\n      var s = t.length;\n      for (i = 0; i < s; i++) if (e(t[i], i)) return t[i];\n    };\n    function C(t, e, i) {\n      for (var _s in t) Object.hasOwnProperty.call(t, _s) && e.call(i || t[_s], t[_s], _s, t);\n    }\n    function k(t, e, i) {\n      function s(e, i) {\n        var s = t.removeEventListener;\n        s && s.call(t, e, i, !1);\n      }\n      function r(i) {\n        var r, o;\n        t.nodeName && (e ? (r = {})[e] = !0 : r = i, C(r, function (t, e) {\n          if (i[e]) for (o = i[e].length; o--;) s(e, i[e][o].fn);\n        }));\n      }\n      var o = \"function\" == typeof t && t.prototype || t;\n      if (Object.hasOwnProperty.call(o, \"hcEvents\")) {\n        var _t2 = o.hcEvents;\n        if (e) {\n          var _o = _t2[e] || [];\n          i ? (_t2[e] = _o.filter(function (t) {\n            return i !== t.fn;\n          }), s(e, i)) : (r(_t2), _t2[e] = []);\n        } else r(_t2), delete o.hcEvents;\n      }\n    }\n    function M(e, i, r, o) {\n      if (r = r || {}, s.createEvent && (e.dispatchEvent || e.fireEvent && e !== t)) {\n        var _t3 = s.createEvent(\"Events\");\n        _t3.initEvent(i, !0, !0), r = m(_t3, r), e.dispatchEvent ? e.dispatchEvent(r) : e.fireEvent(i, r);\n      } else if (e.hcEvents) {\n        r.target || m(r, {\n          preventDefault: function preventDefault() {\n            r.defaultPrevented = !0;\n          },\n          target: e,\n          type: i\n        });\n        var _t4 = [],\n          _s2 = e,\n          _o2 = !1;\n        for (; _s2.hcEvents;) Object.hasOwnProperty.call(_s2, \"hcEvents\") && _s2.hcEvents[i] && (_t4.length && (_o2 = !0), _t4.unshift.apply(_t4, _s2.hcEvents[i])), _s2 = Object.getPrototypeOf(_s2);\n        _o2 && _t4.sort(function (t, e) {\n          return t.order - e.order;\n        }), _t4.forEach(function (t) {\n          !1 === t.fn.call(e, r) && r.preventDefault();\n        });\n      }\n      o && !r.defaultPrevented && o.call(e, r);\n    }\n    C({\n      map: \"map\",\n      each: \"forEach\",\n      grep: \"filter\",\n      reduce: \"reduce\",\n      some: \"some\"\n    }, function (e, i) {\n      t[i] = function (t) {\n        return o(32, !1, void 0, _defineProperty({}, \"Highcharts.\".concat(i), \"use Array.\".concat(e))), Array.prototype[e].apply(t, [].slice.call(arguments, 1));\n      };\n    });\n    var w = function () {\n      var t = Math.random().toString(36).substring(2, 9) + \"-\",\n        i = 0;\n      return function () {\n        return \"highcharts-\" + (e ? \"\" : t) + i++;\n      };\n    }();\n    return r.jQuery && (r.jQuery.fn.highcharts = function () {\n      var e = [].slice.call(arguments);\n      if (this[0]) return e[0] ? (new t[a(e[0]) ? e.shift() : \"Chart\"](this[0], e[0], e[1]), this) : i[g(this[0], \"data-highcharts-chart\")];\n    }), {\n      addEvent: function addEvent(e, i, s) {\n        var r = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n        var o = \"function\" == typeof e && e.prototype || e;\n        Object.hasOwnProperty.call(o, \"hcEvents\") || (o.hcEvents = {});\n        var n = o.hcEvents;\n        t.Point && e instanceof t.Point && e.series && e.series.chart && (e.series.chart.runTrackerClick = !0);\n        var a = e.addEventListener;\n        a && a.call(e, i, s, !!t.supportsPassiveEvents && {\n          passive: void 0 === r.passive ? -1 !== i.indexOf(\"touch\") : r.passive,\n          capture: !1\n        }), n[i] || (n[i] = []);\n        var h = {\n          fn: s,\n          order: \"number\" == typeof r.order ? r.order : 1 / 0\n        };\n        return n[i].push(h), n[i].sort(function (t, e) {\n          return t.order - e.order;\n        }), function () {\n          k(e, i, s);\n        };\n      },\n      arrayMax: function arrayMax(t) {\n        var e = t.length,\n          i = t[0];\n        for (; e--;) t[e] > i && (i = t[e]);\n        return i;\n      },\n      arrayMin: function arrayMin(t) {\n        var e = t.length,\n          i = t[0];\n        for (; e--;) t[e] < i && (i = t[e]);\n        return i;\n      },\n      attr: g,\n      clamp: function clamp(t, e, i) {\n        return t > e ? t < i ? t : i : e;\n      },\n      clearTimeout: function (_clearTimeout) {\n        function clearTimeout(_x) {\n          return _clearTimeout.apply(this, arguments);\n        }\n        clearTimeout.toString = function () {\n          return _clearTimeout.toString();\n        };\n        return clearTimeout;\n      }(function (t) {\n        u(t) && clearTimeout(t);\n      }),\n      correctFloat: v,\n      createElement: function createElement(t, e, i, r, o) {\n        var n = s.createElement(t);\n        return e && m(n, e), o && y(n, {\n          padding: \"0\",\n          border: \"none\",\n          margin: \"0\"\n        }), i && y(n, i), r && r.appendChild(n), n;\n      },\n      crisp: function crisp(t) {\n        var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n        var i = arguments.length > 2 ? arguments[2] : undefined;\n        var s = e % 2 / 2,\n          r = i ? -1 : 1;\n        return (Math.round(t * r - s) + s) * r;\n      },\n      css: y,\n      defined: u,\n      destroyObjectProperties: function destroyObjectProperties(t, e, i) {\n        C(t, function (s, r) {\n          s !== e && s !== null && s !== void 0 && s.destroy && s.destroy(), ((s === null || s === void 0 ? void 0 : s.destroy) || !i) && delete t[r];\n        });\n      },\n      diffObjects: function diffObjects(t, e, i, s) {\n        var r = {};\n        return function t(e, r, o, n) {\n          var a = i ? r : e;\n          C(e, function (i, d) {\n            if (!n && s && s.indexOf(d) > -1 && r[d]) {\n              i = f(i), o[d] = [];\n              for (var _e3 = 0; _e3 < Math.max(i.length, r[d].length); _e3++) r[d][_e3] && (void 0 === i[_e3] ? o[d][_e3] = r[d][_e3] : (o[d][_e3] = {}, t(i[_e3], r[d][_e3], o[d][_e3], n + 1)));\n            } else l(i, !0) && !i.nodeType ? (o[d] = h(i) ? [] : {}, t(i, r[d] || {}, o[d], n + 1), 0 !== Object.keys(o[d]).length || \"colorAxis\" === d && 0 === n || delete o[d]) : (e[d] !== r[d] || d in e && !(d in r)) && \"__proto__\" !== d && \"constructor\" !== d && (o[d] = a[d]);\n          });\n        }(t, e, r, 0), r;\n      },\n      discardElement: function discardElement(t) {\n        t && t.parentElement && t.parentElement.removeChild(t);\n      },\n      erase: function erase(t, e) {\n        var i = t.length;\n        for (; i--;) if (t[i] === e) {\n          t.splice(i, 1);\n          break;\n        }\n      },\n      error: o,\n      extend: m,\n      extendClass: function extendClass(t, e) {\n        var i = function i() {};\n        return i.prototype = new t(), m(i.prototype, e), i;\n      },\n      find: S,\n      fireEvent: M,\n      getClosestDistance: function getClosestDistance(t, e) {\n        var i, s, r, o;\n        var n = !e;\n        return t.forEach(function (t) {\n          if (t.length > 1) for (o = s = t.length - 1; o > 0; o--) {\n            var _e4;\n            (r = t[o] - t[o - 1]) < 0 && !n ? ((_e4 = e) !== null && _e4 !== void 0 && _e4(), e = void 0) : r && (void 0 === i || r < i) && (i = r);\n          }\n        }), i;\n      },\n      getMagnitude: b,\n      getNestedProperty: function getNestedProperty(t, e) {\n        var i = t.split(\".\");\n        for (; i.length && u(e);) {\n          var _t5 = i.shift();\n          if (void 0 === _t5 || \"__proto__\" === _t5) return;\n          if (\"this\" === _t5) {\n            var _t7;\n            var _t6 = void 0;\n            return l(e) && (_t6 = e[\"@this\"]), (_t7 = _t6) !== null && _t7 !== void 0 ? _t7 : e;\n          }\n          var _s3 = e[_t5];\n          if (!u(_s3) || \"function\" == typeof _s3 || \"number\" == typeof _s3.nodeType || _s3 === r) return;\n          e = _s3;\n        }\n        return e;\n      },\n      getStyle: function t(e, i, s) {\n        var o;\n        if (\"width\" === i) {\n          var _i2 = Math.min(e.offsetWidth, e.scrollWidth),\n            _s4 = e.getBoundingClientRect && e.getBoundingClientRect().width;\n          return _s4 < _i2 && _s4 >= _i2 - 1 && (_i2 = Math.floor(_s4)), Math.max(0, _i2 - (t(e, \"padding-left\", !0) || 0) - (t(e, \"padding-right\", !0) || 0));\n        }\n        if (\"height\" === i) return Math.max(0, Math.min(e.offsetHeight, e.scrollHeight) - (t(e, \"padding-top\", !0) || 0) - (t(e, \"padding-bottom\", !0) || 0));\n        var a = r.getComputedStyle(e, void 0);\n        return a && (o = a.getPropertyValue(i), x(s, \"opacity\" !== i) && (o = n(o))), o;\n      },\n      inArray: function inArray(t, e, i) {\n        return o(32, !1, void 0, {\n          \"Highcharts.inArray\": \"use Array.indexOf\"\n        }), e.indexOf(t, i);\n      },\n      insertItem: function insertItem(t, e) {\n        var i;\n        var s = t.options.index,\n          r = e.length;\n        for (i = t.options.isInternal ? r : 0; i < r + 1; i++) if (!e[i] || p(s) && s < x(e[i].options.index, e[i]._i) || e[i].options.isInternal) {\n          e.splice(i, 0, t);\n          break;\n        }\n        return i;\n      },\n      isArray: h,\n      isClass: c,\n      isDOMElement: d,\n      isFunction: function isFunction(t) {\n        return \"function\" == typeof t;\n      },\n      isNumber: p,\n      isObject: l,\n      isString: a,\n      keys: function keys(t) {\n        return o(32, !1, void 0, {\n          \"Highcharts.keys\": \"use Object.keys\"\n        }), Object.keys(t);\n      },\n      merge: function merge() {\n        var t,\n          e = arguments,\n          i = {},\n          _s5 = function s(t, e) {\n            return \"object\" != _typeof(t) && (t = {}), C(e, function (i, r) {\n              \"__proto__\" !== r && \"constructor\" !== r && (!l(i, !0) || c(i) || d(i) ? t[r] = e[r] : t[r] = _s5(t[r] || {}, i));\n            }), t;\n          };\n        !0 === e[0] && (i = e[1], e = Array.prototype.slice.call(e, 2));\n        var r = e.length;\n        for (t = 0; t < r; t++) i = _s5(i, e[t]);\n        return i;\n      },\n      normalizeTickInterval: function normalizeTickInterval(t, e, i, s, r) {\n        var o,\n          n = t;\n        i = x(i, b(t));\n        var a = t / i;\n        for (!e && (e = r ? [1, 1.2, 1.5, 2, 2.5, 3, 4, 5, 6, 8, 10] : [1, 2, 2.5, 5, 10], !1 === s && (1 === i ? e = e.filter(function (t) {\n          return t % 1 == 0;\n        }) : i <= .1 && (e = [1 / i]))), o = 0; o < e.length && (n = e[o], (!r || !(n * i >= t)) && (r || !(a <= (e[o] + (e[o + 1] || e[o])) / 2))); o++);\n        return v(n * i, -Math.round(Math.log(.001) / Math.LN10));\n      },\n      objectEach: C,\n      offset: function offset(t) {\n        var e = s.documentElement,\n          i = t.parentElement || t.parentNode ? t.getBoundingClientRect() : {\n            top: 0,\n            left: 0,\n            width: 0,\n            height: 0\n          };\n        return {\n          top: i.top + (r.pageYOffset || e.scrollTop) - (e.clientTop || 0),\n          left: i.left + (r.pageXOffset || e.scrollLeft) - (e.clientLeft || 0),\n          width: i.width,\n          height: i.height\n        };\n      },\n      pad: function pad(t, e, i) {\n        return Array((e || 2) + 1 - String(t).replace(\"-\", \"\").length).join(i || \"0\") + t;\n      },\n      pick: x,\n      pInt: n,\n      pushUnique: function pushUnique(t, e) {\n        return 0 > t.indexOf(e) && !!t.push(e);\n      },\n      relativeLength: function relativeLength(t, e, i) {\n        return /%$/.test(t) ? e * parseFloat(t) / 100 + (i || 0) : parseFloat(t);\n      },\n      removeEvent: k,\n      replaceNested: function replaceNested(t) {\n        var i, s;\n        for (var _len = arguments.length, e = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n          e[_key - 1] = arguments[_key];\n        }\n        do {\n          var _iterator = _createForOfIteratorHelper((i = t, e)),\n            _step;\n          try {\n            for (_iterator.s(); !(_step = _iterator.n()).done;) {\n              s = _step.value;\n              t = t.replace(s[0], s[1]);\n            }\n          } catch (err) {\n            _iterator.e(err);\n          } finally {\n            _iterator.f();\n          }\n        } while (t !== i);\n        return t;\n      },\n      splat: f,\n      stableSort: function stableSort(t, e) {\n        var i, s;\n        var r = t.length;\n        for (s = 0; s < r; s++) t[s].safeI = s;\n        for (t.sort(function (t, s) {\n          return 0 === (i = e(t, s)) ? t.safeI - s.safeI : i;\n        }), s = 0; s < r; s++) delete t[s].safeI;\n      },\n      syncTimeout: function syncTimeout(t, e, i) {\n        return e > 0 ? setTimeout(t, e, i) : (t.call(0, i), -1);\n      },\n      timeUnits: {\n        millisecond: 1,\n        second: 1e3,\n        minute: 6e4,\n        hour: 36e5,\n        day: 864e5,\n        week: 6048e5,\n        month: 24192e5,\n        year: 314496e5\n      },\n      uniqueKey: w,\n      useSerialIds: function useSerialIds(t) {\n        return e = x(t, e);\n      },\n      wrap: function wrap(t, e, i) {\n        var s = t[e];\n        t[e] = function () {\n          var t = arguments,\n            e = this;\n          return i.apply(this, [function () {\n            return s.apply(e, arguments.length ? arguments : t);\n          }].concat([].slice.call(arguments)));\n        };\n      }\n    };\n  }), i(e, \"Core/Chart/ChartDefaults.js\", [], function () {\n    return {\n      alignThresholds: !1,\n      panning: {\n        enabled: !1,\n        type: \"x\"\n      },\n      styledMode: !1,\n      borderRadius: 0,\n      colorCount: 10,\n      allowMutatingData: !0,\n      ignoreHiddenSeries: !0,\n      spacing: [10, 10, 15, 10],\n      resetZoomButton: {\n        theme: {},\n        position: {}\n      },\n      reflow: !0,\n      type: \"line\",\n      zooming: {\n        singleTouch: !1,\n        resetButton: {\n          theme: {\n            zIndex: 6\n          },\n          position: {\n            align: \"right\",\n            x: -10,\n            y: 10\n          }\n        }\n      },\n      width: null,\n      height: null,\n      borderColor: \"#334eff\",\n      backgroundColor: \"#ffffff\",\n      plotBorderColor: \"#cccccc\"\n    };\n  }), i(e, \"Core/Color/Palettes.js\", [], function () {\n    return {\n      colors: [\"#2caffe\", \"#544fc5\", \"#00e272\", \"#fe6a35\", \"#6b8abc\", \"#d568fb\", \"#2ee0ca\", \"#fa4b42\", \"#feb56a\", \"#91e8e1\"]\n    };\n  }), i(e, \"Core/Time.js\", [e[\"Core/Globals.js\"], e[\"Core/Utilities.js\"]], function (t, e) {\n    var i = t.win,\n      s = e.defined,\n      r = e.error,\n      o = e.extend,\n      n = e.isNumber,\n      a = e.isObject,\n      h = e.merge,\n      l = e.objectEach,\n      d = e.pad,\n      c = e.pick,\n      p = e.splat,\n      u = e.timeUnits,\n      g = t.isSafari && i.Intl && i.Intl.DateTimeFormat.prototype.formatRange,\n      f = t.isSafari && i.Intl && !i.Intl.DateTimeFormat.prototype.formatRange;\n    var m = /*#__PURE__*/function () {\n      function m(t) {\n        _classCallCheck(this, m);\n        this.options = {}, this.useUTC = !1, this.variableTimezone = !1, this.Date = i.Date, this.getTimezoneOffset = this.timezoneOffsetFunction(), this.update(t);\n      }\n      return _createClass(m, [{\n        key: \"get\",\n        value: function get(t, e) {\n          if (this.variableTimezone || this.timezoneOffset) {\n            var _i3 = e.getTime(),\n              _s6 = _i3 - this.getTimezoneOffset(e);\n            e.setTime(_s6);\n            var _r = e[\"getUTC\" + t]();\n            return e.setTime(_i3), _r;\n          }\n          return this.useUTC ? e[\"getUTC\" + t]() : e[\"get\" + t]();\n        }\n      }, {\n        key: \"set\",\n        value: function set(t, e, i) {\n          if (this.variableTimezone || this.timezoneOffset) {\n            if (\"Milliseconds\" === t || \"Seconds\" === t || \"Minutes\" === t && this.getTimezoneOffset(e) % 36e5 == 0) return e[\"setUTC\" + t](i);\n            var _s7 = this.getTimezoneOffset(e),\n              _r2 = e.getTime() - _s7;\n            e.setTime(_r2), e[\"setUTC\" + t](i);\n            var _o4 = this.getTimezoneOffset(e);\n            return _r2 = e.getTime() + _o4, e.setTime(_r2);\n          }\n          return this.useUTC || g && \"FullYear\" === t ? e[\"setUTC\" + t](i) : e[\"set\" + t](i);\n        }\n      }, {\n        key: \"update\",\n        value: function update() {\n          var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n          var e = c(t.useUTC, !0);\n          this.options = t = h(!0, this.options, t), this.Date = t.Date || i.Date || Date, this.useUTC = e, this.timezoneOffset = e && t.timezoneOffset || void 0, this.getTimezoneOffset = this.timezoneOffsetFunction(), this.variableTimezone = e && !!(t.getTimezoneOffset || t.timezone);\n        }\n      }, {\n        key: \"makeTime\",\n        value: function makeTime(t, e, i, s, r, o) {\n          var n, a, h;\n          return this.useUTC ? (n = this.Date.UTC.apply(0, arguments), a = this.getTimezoneOffset(n), n += a, a !== (h = this.getTimezoneOffset(n)) ? n += h - a : a - 36e5 !== this.getTimezoneOffset(n - 36e5) || f || (n -= 36e5)) : n = new this.Date(t, e, c(i, 1), c(s, 0), c(r, 0), c(o, 0)).getTime(), n;\n        }\n      }, {\n        key: \"timezoneOffsetFunction\",\n        value: function timezoneOffsetFunction() {\n          var t = this,\n            e = this.options,\n            i = e.getTimezoneOffset;\n          return this.useUTC ? e.timezone ? function (t) {\n            try {\n              var _i4 = \"shortOffset,\".concat(e.timezone || \"\"),\n                _m$formatCache$i$form = (m.formatCache[_i4] = m.formatCache[_i4] || Intl.DateTimeFormat(\"en\", {\n                  timeZone: e.timezone,\n                  timeZoneName: \"shortOffset\"\n                })).format(t).split(/(GMT|:)/).map(Number),\n                _m$formatCache$i$form2 = _slicedToArray(_m$formatCache$i$form, 5),\n                _s8 = _m$formatCache$i$form2[0],\n                _r3 = _m$formatCache$i$form2[1],\n                _o5 = _m$formatCache$i$form2[2],\n                _a = _m$formatCache$i$form2[3],\n                _m$formatCache$i$form3 = _m$formatCache$i$form2[4],\n                _h = _m$formatCache$i$form3 === void 0 ? 0 : _m$formatCache$i$form3,\n                _l = -(36e5 * (_o5 + _h / 60));\n              if (n(_l)) return _l;\n            } catch (t) {\n              r(34);\n            }\n            return 0;\n          } : this.useUTC && i ? function (t) {\n            return 6e4 * i(t.valueOf());\n          } : function () {\n            return 6e4 * (t.timezoneOffset || 0);\n          } : function (t) {\n            return 6e4 * new Date(t.toString()).getTimezoneOffset();\n          };\n        }\n      }, {\n        key: \"dateFormat\",\n        value: function dateFormat(e, i, r) {\n          if (!s(i) || isNaN(i)) return t.defaultOptions.lang && t.defaultOptions.lang.invalidDate || \"\";\n          e = c(e, \"%Y-%m-%d %H:%M:%S\");\n          var n = this,\n            a = new this.Date(i),\n            h = this.get(\"Hours\", a),\n            p = this.get(\"Day\", a),\n            u = this.get(\"Date\", a),\n            g = this.get(\"Month\", a),\n            f = this.get(\"FullYear\", a),\n            _m = t.defaultOptions.lang,\n            x = _m && _m.weekdays,\n            y = _m && _m.shortWeekdays;\n          return l(o({\n            a: y ? y[p] : x[p].substr(0, 3),\n            A: x[p],\n            d: d(u),\n            e: d(u, 2, \" \"),\n            w: p,\n            b: _m.shortMonths[g],\n            B: _m.months[g],\n            m: d(g + 1),\n            o: g + 1,\n            y: f.toString().substr(2, 2),\n            Y: f,\n            H: d(h),\n            k: h,\n            I: d(h % 12 || 12),\n            l: h % 12 || 12,\n            M: d(this.get(\"Minutes\", a)),\n            p: h < 12 ? \"AM\" : \"PM\",\n            P: h < 12 ? \"am\" : \"pm\",\n            S: d(this.get(\"Seconds\", a)),\n            L: d(Math.floor(i % 1e3), 3)\n          }, t.dateFormats), function (t, s) {\n            for (; -1 !== e.indexOf(\"%\" + s);) e = e.replace(\"%\" + s, \"function\" == typeof t ? t.call(n, i) : t);\n          }), r ? e.substr(0, 1).toUpperCase() + e.substr(1) : e;\n        }\n      }, {\n        key: \"resolveDTLFormat\",\n        value: function resolveDTLFormat(t) {\n          return a(t, !0) ? t : {\n            main: (t = p(t))[0],\n            from: t[1],\n            to: t[2]\n          };\n        }\n      }, {\n        key: \"getTimeTicks\",\n        value: function getTimeTicks(t, e, i, r) {\n          var n, a, h, l;\n          var d = this,\n            p = d.Date,\n            g = [],\n            f = {},\n            _m2 = new p(e),\n            x = t.unitRange,\n            y = t.count || 1;\n          if (r = c(r, 1), s(e)) {\n            d.set(\"Milliseconds\", _m2, x >= u.second ? 0 : y * Math.floor(d.get(\"Milliseconds\", _m2) / y)), x >= u.second && d.set(\"Seconds\", _m2, x >= u.minute ? 0 : y * Math.floor(d.get(\"Seconds\", _m2) / y)), x >= u.minute && d.set(\"Minutes\", _m2, x >= u.hour ? 0 : y * Math.floor(d.get(\"Minutes\", _m2) / y)), x >= u.hour && d.set(\"Hours\", _m2, x >= u.day ? 0 : y * Math.floor(d.get(\"Hours\", _m2) / y)), x >= u.day && d.set(\"Date\", _m2, x >= u.month ? 1 : Math.max(1, y * Math.floor(d.get(\"Date\", _m2) / y))), x >= u.month && (d.set(\"Month\", _m2, x >= u.year ? 0 : y * Math.floor(d.get(\"Month\", _m2) / y)), a = d.get(\"FullYear\", _m2)), x >= u.year && (a -= a % y, d.set(\"FullYear\", _m2, a)), x === u.week && (l = d.get(\"Day\", _m2), d.set(\"Date\", _m2, d.get(\"Date\", _m2) - l + r + (l < r ? -7 : 0))), a = d.get(\"FullYear\", _m2);\n            var _t8 = d.get(\"Month\", _m2),\n              _o6 = d.get(\"Date\", _m2),\n              _c = d.get(\"Hours\", _m2);\n            e = _m2.getTime(), (d.variableTimezone || !d.useUTC) && s(i) && (h = i - e > 4 * u.month || d.getTimezoneOffset(e) !== d.getTimezoneOffset(i));\n            var _p = _m2.getTime();\n            for (n = 1; _p < i;) g.push(_p), x === u.year ? _p = d.makeTime(a + n * y, 0) : x === u.month ? _p = d.makeTime(a, _t8 + n * y) : h && (x === u.day || x === u.week) ? _p = d.makeTime(a, _t8, _o6 + n * y * (x === u.day ? 1 : 7)) : h && x === u.hour && y > 1 ? _p = d.makeTime(a, _t8, _o6, _c + n * y) : _p += x * y, n++;\n            g.push(_p), x <= u.hour && g.length < 1e4 && g.forEach(function (t) {\n              t % 18e5 == 0 && \"000000000\" === d.dateFormat(\"%H%M%S%L\", t) && (f[t] = \"day\");\n            });\n          }\n          return g.info = o(t, {\n            higherRanks: f,\n            totalRange: x * y\n          }), g;\n        }\n      }, {\n        key: \"getDateFormat\",\n        value: function getDateFormat(t, e, i, s) {\n          var r = this.dateFormat(\"%m-%d %H:%M:%S.%L\", e),\n            o = \"01-01 00:00:00.000\",\n            n = {\n              millisecond: 15,\n              second: 12,\n              minute: 9,\n              hour: 6,\n              day: 3\n            },\n            a = \"millisecond\",\n            h = a;\n          for (a in u) {\n            if (t === u.week && +this.dateFormat(\"%w\", e) === i && r.substr(6) === o.substr(6)) {\n              a = \"week\";\n              break;\n            }\n            if (u[a] > t) {\n              a = h;\n              break;\n            }\n            if (n[a] && r.substr(n[a]) !== o.substr(n[a])) break;\n            \"week\" !== a && (h = a);\n          }\n          return this.resolveDTLFormat(s[a]).main;\n        }\n      }]);\n    }();\n    return m.formatCache = {}, m;\n  }), i(e, \"Core/Defaults.js\", [e[\"Core/Chart/ChartDefaults.js\"], e[\"Core/Globals.js\"], e[\"Core/Color/Palettes.js\"], e[\"Core/Time.js\"], e[\"Core/Utilities.js\"]], function (t, e, i, s, r) {\n    var o = e.isTouchDevice,\n      n = r.fireEvent,\n      a = r.merge,\n      h = {\n        colors: i.colors,\n        symbols: [\"circle\", \"diamond\", \"square\", \"triangle\", \"triangle-down\"],\n        lang: {\n          loading: \"Loading...\",\n          months: [\"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"],\n          shortMonths: [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"],\n          weekdays: [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"],\n          decimalPoint: \".\",\n          numericSymbols: [\"k\", \"M\", \"G\", \"T\", \"P\", \"E\"],\n          resetZoom: \"Reset zoom\",\n          resetZoomTitle: \"Reset zoom level 1:1\",\n          thousandsSep: \" \"\n        },\n        global: {\n          buttonTheme: {\n            fill: \"#f7f7f7\",\n            padding: 8,\n            r: 2,\n            stroke: \"#cccccc\",\n            \"stroke-width\": 1,\n            style: {\n              color: \"#333333\",\n              cursor: \"pointer\",\n              fontSize: \"0.8em\",\n              fontWeight: \"normal\"\n            },\n            states: {\n              hover: {\n                fill: \"#e6e6e6\"\n              },\n              select: {\n                fill: \"#e6e9ff\",\n                style: {\n                  color: \"#000000\",\n                  fontWeight: \"bold\"\n                }\n              },\n              disabled: {\n                style: {\n                  color: \"#cccccc\"\n                }\n              }\n            }\n          }\n        },\n        time: {\n          Date: void 0,\n          getTimezoneOffset: void 0,\n          timezone: void 0,\n          timezoneOffset: 0,\n          useUTC: !0\n        },\n        chart: t,\n        title: {\n          style: {\n            color: \"#333333\",\n            fontWeight: \"bold\"\n          },\n          text: \"Chart title\",\n          align: \"center\",\n          margin: 15,\n          widthAdjust: -44\n        },\n        subtitle: {\n          style: {\n            color: \"#666666\",\n            fontSize: \"0.8em\"\n          },\n          text: \"\",\n          align: \"center\",\n          widthAdjust: -44\n        },\n        caption: {\n          margin: 15,\n          style: {\n            color: \"#666666\",\n            fontSize: \"0.8em\"\n          },\n          text: \"\",\n          align: \"left\",\n          verticalAlign: \"bottom\"\n        },\n        plotOptions: {},\n        legend: {\n          enabled: !0,\n          align: \"center\",\n          alignColumns: !0,\n          className: \"highcharts-no-tooltip\",\n          events: {},\n          layout: \"horizontal\",\n          itemMarginBottom: 2,\n          itemMarginTop: 2,\n          labelFormatter: function labelFormatter() {\n            return this.name;\n          },\n          borderColor: \"#999999\",\n          borderRadius: 0,\n          navigation: {\n            style: {\n              fontSize: \"0.8em\"\n            },\n            activeColor: \"#0022ff\",\n            inactiveColor: \"#cccccc\"\n          },\n          itemStyle: {\n            color: \"#333333\",\n            cursor: \"pointer\",\n            fontSize: \"0.8em\",\n            textDecoration: \"none\",\n            textOverflow: \"ellipsis\"\n          },\n          itemHoverStyle: {\n            color: \"#000000\"\n          },\n          itemHiddenStyle: {\n            color: \"#666666\",\n            textDecoration: \"line-through\"\n          },\n          shadow: !1,\n          itemCheckboxStyle: {\n            position: \"absolute\",\n            width: \"13px\",\n            height: \"13px\"\n          },\n          squareSymbol: !0,\n          symbolPadding: 5,\n          verticalAlign: \"bottom\",\n          x: 0,\n          y: 0,\n          title: {\n            style: {\n              fontSize: \"0.8em\",\n              fontWeight: \"bold\"\n            }\n          }\n        },\n        loading: {\n          labelStyle: {\n            fontWeight: \"bold\",\n            position: \"relative\",\n            top: \"45%\"\n          },\n          style: {\n            position: \"absolute\",\n            backgroundColor: \"#ffffff\",\n            opacity: .5,\n            textAlign: \"center\"\n          }\n        },\n        tooltip: {\n          enabled: !0,\n          animation: {\n            duration: 300,\n            easing: function easing(t) {\n              return Math.sqrt(1 - Math.pow(t - 1, 2));\n            }\n          },\n          borderRadius: 3,\n          dateTimeLabelFormats: {\n            millisecond: \"%A, %e %b, %H:%M:%S.%L\",\n            second: \"%A, %e %b, %H:%M:%S\",\n            minute: \"%A, %e %b, %H:%M\",\n            hour: \"%A, %e %b, %H:%M\",\n            day: \"%A, %e %b %Y\",\n            week: \"Week from %A, %e %b %Y\",\n            month: \"%B %Y\",\n            year: \"%Y\"\n          },\n          footerFormat: \"\",\n          headerShape: \"callout\",\n          hideDelay: 500,\n          padding: 8,\n          shape: \"callout\",\n          shared: !1,\n          snap: o ? 25 : 10,\n          headerFormat: '<span style=\"font-size: 0.8em\">{point.key}</span><br/>',\n          pointFormat: '<span style=\"color:{point.color}\">‚óè</span> {series.name}: <b>{point.y}</b><br/>',\n          backgroundColor: \"#ffffff\",\n          borderWidth: void 0,\n          shadow: !0,\n          stickOnContact: !1,\n          style: {\n            color: \"#333333\",\n            cursor: \"default\",\n            fontSize: \"0.8em\"\n          },\n          useHTML: !1\n        },\n        credits: {\n          enabled: !0,\n          href: \"https://www.highcharts.com?credits\",\n          position: {\n            align: \"right\",\n            x: -10,\n            verticalAlign: \"bottom\",\n            y: -5\n          },\n          style: {\n            cursor: \"pointer\",\n            color: \"#999999\",\n            fontSize: \"0.6em\"\n          },\n          text: \"Highcharts.com\"\n        }\n      };\n    h.chart.styledMode = !1;\n    var l = new s(h.time);\n    return {\n      defaultOptions: h,\n      defaultTime: l,\n      getOptions: function getOptions() {\n        return h;\n      },\n      setOptions: function setOptions(t) {\n        return n(e, \"setOptions\", {\n          options: t\n        }), a(!0, h, t), (t.time || t.global) && (e.time ? e.time.update(a(h.global, h.time, t.global, t.time)) : e.time = l), h;\n      }\n    };\n  }), i(e, \"Core/Color/Color.js\", [e[\"Core/Globals.js\"], e[\"Core/Utilities.js\"]], function (t, e) {\n    var i = e.isNumber,\n      s = e.merge,\n      r = e.pInt;\n    var o = /*#__PURE__*/function () {\n      function o(e) {\n        _classCallCheck(this, o);\n        var i, s, r, n;\n        this.rgba = [NaN, NaN, NaN, NaN], this.input = e;\n        var a = t.Color;\n        if (a && a !== o) return new a(e);\n        if (\"object\" == _typeof(e) && void 0 !== e.stops) this.stops = e.stops.map(function (t) {\n          return new o(t[1]);\n        });else if (\"string\" == typeof e) {\n          if (this.input = e = o.names[e.toLowerCase()] || e, \"#\" === e.charAt(0)) {\n            var _t9 = e.length,\n              _i5 = parseInt(e.substr(1), 16);\n            7 === _t9 ? s = [(16711680 & _i5) >> 16, (65280 & _i5) >> 8, 255 & _i5, 1] : 4 === _t9 && (s = [(3840 & _i5) >> 4 | (3840 & _i5) >> 8, (240 & _i5) >> 4 | 240 & _i5, (15 & _i5) << 4 | 15 & _i5, 1]);\n          }\n          if (!s) for (r = o.parsers.length; r-- && !s;) (i = (n = o.parsers[r]).regex.exec(e)) && (s = n.parse(i));\n        }\n        s && (this.rgba = s);\n      }\n      return _createClass(o, [{\n        key: \"get\",\n        value: function get(t) {\n          var e = this.input,\n            r = this.rgba;\n          if (\"object\" == _typeof(e) && void 0 !== this.stops) {\n            var _i6 = s(e);\n            return _i6.stops = [].slice.call(_i6.stops), this.stops.forEach(function (e, s) {\n              _i6.stops[s] = [_i6.stops[s][0], e.get(t)];\n            }), _i6;\n          }\n          return r && i(r[0]) ? \"rgb\" !== t && (t || 1 !== r[3]) ? \"a\" === t ? \"\".concat(r[3]) : \"rgba(\" + r.join(\",\") + \")\" : \"rgb(\" + r[0] + \",\" + r[1] + \",\" + r[2] + \")\" : e;\n        }\n      }, {\n        key: \"brighten\",\n        value: function brighten(t) {\n          var e = this.rgba;\n          if (this.stops) this.stops.forEach(function (e) {\n            e.brighten(t);\n          });else if (i(t) && 0 !== t) for (var _i7 = 0; _i7 < 3; _i7++) e[_i7] += r(255 * t), e[_i7] < 0 && (e[_i7] = 0), e[_i7] > 255 && (e[_i7] = 255);\n          return this;\n        }\n      }, {\n        key: \"setOpacity\",\n        value: function setOpacity(t) {\n          return this.rgba[3] = t, this;\n        }\n      }, {\n        key: \"tweenTo\",\n        value: function tweenTo(t, e) {\n          var s = this.rgba,\n            r = t.rgba;\n          if (!i(s[0]) || !i(r[0])) return t.input || \"none\";\n          var _o7 = 1 !== r[3] || 1 !== s[3];\n          return (_o7 ? \"rgba(\" : \"rgb(\") + Math.round(r[0] + (s[0] - r[0]) * (1 - e)) + \",\" + Math.round(r[1] + (s[1] - r[1]) * (1 - e)) + \",\" + Math.round(r[2] + (s[2] - r[2]) * (1 - e)) + (_o7 ? \",\" + (r[3] + (s[3] - r[3]) * (1 - e)) : \"\") + \")\";\n        }\n      }], [{\n        key: \"parse\",\n        value: function parse(t) {\n          return t ? new o(t) : o.None;\n        }\n      }]);\n    }();\n    return o.names = {\n      white: \"#ffffff\",\n      black: \"#000000\"\n    }, o.parsers = [{\n      regex: /rgba\\(\\s*(\\d{1,3})\\s*,\\s*(\\d{1,3})\\s*,\\s*(\\d{1,3})\\s*,\\s*(\\d?(?:\\.\\d+)?)\\s*\\)/,\n      parse: function parse(t) {\n        return [r(t[1]), r(t[2]), r(t[3]), parseFloat(t[4], 10)];\n      }\n    }, {\n      regex: /rgb\\(\\s*(\\d{1,3})\\s*,\\s*(\\d{1,3})\\s*,\\s*(\\d{1,3})\\s*\\)/,\n      parse: function parse(t) {\n        return [r(t[1]), r(t[2]), r(t[3]), 1];\n      }\n    }], o.None = new o(\"\"), o;\n  }), i(e, \"Core/Animation/Fx.js\", [e[\"Core/Color/Color.js\"], e[\"Core/Globals.js\"], e[\"Core/Utilities.js\"]], function (t, e, i) {\n    var s = t.parse,\n      r = e.win,\n      o = i.isNumber,\n      n = i.objectEach;\n    var a = /*#__PURE__*/function () {\n      function a(t, e, i) {\n        _classCallCheck(this, a);\n        this.pos = NaN, this.options = e, this.elem = t, this.prop = i;\n      }\n      return _createClass(a, [{\n        key: \"dSetter\",\n        value: function dSetter() {\n          var t = this.paths,\n            e = t && t[0],\n            i = t && t[1],\n            s = this.now || 0,\n            r = [];\n          if (1 !== s && e && i) {\n            if (e.length === i.length && s < 1) for (var _t10 = 0; _t10 < i.length; _t10++) {\n              var _n = e[_t10],\n                _a2 = i[_t10],\n                h = [];\n              for (var _t11 = 0; _t11 < _a2.length; _t11++) {\n                var _e5 = _n[_t11],\n                  _i8 = _a2[_t11];\n                o(_e5) && o(_i8) && !(\"A\" === _a2[0] && (4 === _t11 || 5 === _t11)) ? h[_t11] = _e5 + s * (_i8 - _e5) : h[_t11] = _i8;\n              }\n              r.push(h);\n            } else r = i;\n          } else r = this.toD || [];\n          this.elem.attr(\"d\", r, void 0, !0);\n        }\n      }, {\n        key: \"update\",\n        value: function update() {\n          var t = this.elem,\n            e = this.prop,\n            i = this.now,\n            s = this.options.step;\n          this[e + \"Setter\"] ? this[e + \"Setter\"]() : t.attr ? t.element && t.attr(e, i, null, !0) : t.style[e] = i + this.unit, s && s.call(t, i, this);\n        }\n      }, {\n        key: \"run\",\n        value: function run(t, e, i) {\n          var s = this,\n            o = s.options,\n            _n2 = function n(t) {\n              return !_n2.stopped && s.step(t);\n            },\n            h = r.requestAnimationFrame || function (t) {\n              setTimeout(t, 13);\n            },\n            _l2 = function l() {\n              for (var _t12 = 0; _t12 < a.timers.length; _t12++) a.timers[_t12]() || a.timers.splice(_t12--, 1);\n              a.timers.length && h(_l2);\n            };\n          t !== e || this.elem[\"forceAnimate:\" + this.prop] ? (this.startTime = +new Date(), this.start = t, this.end = e, this.unit = i, this.now = this.start, this.pos = 0, _n2.elem = this.elem, _n2.prop = this.prop, _n2() && 1 === a.timers.push(_n2) && h(_l2)) : (delete o.curAnim[this.prop], o.complete && 0 === Object.keys(o.curAnim).length && o.complete.call(this.elem));\n        }\n      }, {\n        key: \"step\",\n        value: function step(t) {\n          var e, i;\n          var s = +new Date(),\n            r = this.options,\n            o = this.elem,\n            _a3 = r.complete,\n            h = r.duration,\n            l = r.curAnim;\n          return o.attr && !o.element ? e = !1 : t || s >= h + this.startTime ? (this.now = this.end, this.pos = 1, this.update(), l[this.prop] = !0, i = !0, n(l, function (t) {\n            !0 !== t && (i = !1);\n          }), i && _a3 && _a3.call(o), e = !1) : (this.pos = r.easing((s - this.startTime) / h), this.now = this.start + (this.end - this.start) * this.pos, this.update(), e = !0), e;\n        }\n      }, {\n        key: \"initPath\",\n        value: function initPath(t, e, i) {\n          var s = t.startX,\n            r = t.endX,\n            n = i.slice(),\n            _a4 = t.isArea,\n            h = _a4 ? 2 : 1,\n            l = e && i.length > e.length && i.hasStackedCliffs,\n            d,\n            c,\n            p,\n            u,\n            g = e && e.slice();\n          if (!g || l) return [n, n];\n          function f(t, e) {\n            for (; t.length < c;) {\n              var _i9 = t[0],\n                _s9 = e[c - t.length];\n              if (_s9 && \"M\" === _i9[0] && (\"C\" === _s9[0] ? t[0] = [\"C\", _i9[1], _i9[2], _i9[1], _i9[2], _i9[1], _i9[2]] : t[0] = [\"L\", _i9[1], _i9[2]]), t.unshift(_i9), _a4) {\n                var _e6 = t.pop();\n                t.push(t[t.length - 1], _e6);\n              }\n            }\n          }\n          function m(t) {\n            for (; t.length < c;) {\n              var _e7 = t[Math.floor(t.length / h) - 1].slice();\n              if (\"C\" === _e7[0] && (_e7[1] = _e7[5], _e7[2] = _e7[6]), _a4) {\n                var _i10 = t[Math.floor(t.length / h)].slice();\n                t.splice(t.length / 2, 0, _e7, _i10);\n              } else t.push(_e7);\n            }\n          }\n          if (s && r && r.length) {\n            for (p = 0; p < s.length; p++) {\n              if (s[p] === r[0]) {\n                d = p;\n                break;\n              }\n              if (s[0] === r[r.length - s.length + p]) {\n                d = p, u = !0;\n                break;\n              }\n              if (s[s.length - 1] === r[r.length - s.length + p]) {\n                d = s.length - p;\n                break;\n              }\n            }\n            void 0 === d && (g = []);\n          }\n          return g.length && o(d) && (c = n.length + d * h, u ? (f(g, n), m(n)) : (f(n, g), m(g))), [g, n];\n        }\n      }, {\n        key: \"fillSetter\",\n        value: function fillSetter() {\n          a.prototype.strokeSetter.apply(this, arguments);\n        }\n      }, {\n        key: \"strokeSetter\",\n        value: function strokeSetter() {\n          this.elem.attr(this.prop, s(this.start).tweenTo(s(this.end), this.pos), void 0, !0);\n        }\n      }]);\n    }();\n    return a.timers = [], a;\n  }), i(e, \"Core/Animation/AnimationUtilities.js\", [e[\"Core/Animation/Fx.js\"], e[\"Core/Utilities.js\"]], function (t, e) {\n    var i = e.defined,\n      s = e.getStyle,\n      r = e.isArray,\n      o = e.isNumber,\n      n = e.isObject,\n      a = e.merge,\n      h = e.objectEach,\n      l = e.pick;\n    function d(t) {\n      return n(t) ? a({\n        duration: 500,\n        defer: 0\n      }, t) : {\n        duration: t ? 500 : 0,\n        defer: 0\n      };\n    }\n    function c(e, i) {\n      var s = t.timers.length;\n      for (; s--;) t.timers[s].elem !== e || i && i !== t.timers[s].prop || (t.timers[s].stopped = !0);\n    }\n    return {\n      animate: function animate(e, i, l) {\n        var d,\n          p = \"\",\n          u,\n          g,\n          f;\n        n(l) || (f = arguments, l = {\n          duration: f[2],\n          easing: f[3],\n          complete: f[4]\n        }), o(l.duration) || (l.duration = 400), l.easing = \"function\" == typeof l.easing ? l.easing : Math[l.easing] || Math.easeInOutSine, l.curAnim = a(i), h(i, function (o, n) {\n          c(e, n), g = new t(e, l, n), u = void 0, \"d\" === n && r(i.d) ? (g.paths = g.initPath(e, e.pathArray, i.d), g.toD = i.d, d = 0, u = 1) : e.attr ? d = e.attr(n) : (d = parseFloat(s(e, n)) || 0, \"opacity\" !== n && (p = \"px\")), u || (u = o), \"string\" == typeof u && u.match(\"px\") && (u = u.replace(/px/g, \"\")), g.run(d, u, p);\n        });\n      },\n      animObject: d,\n      getDeferredAnimation: function getDeferredAnimation(t, e, s) {\n        var r = d(e),\n          o = s ? [s] : t.series,\n          a = 0,\n          h = 0;\n        return o.forEach(function (t) {\n          var s = d(t.options.animation);\n          a = n(e) && i(e.defer) ? r.defer : Math.max(a, s.duration + s.defer), h = Math.min(r.duration, s.duration);\n        }), t.renderer.forExport && (a = 0), {\n          defer: Math.max(0, a - h),\n          duration: Math.min(a, h)\n        };\n      },\n      setAnimation: function setAnimation(t, e) {\n        e.renderer.globalAnimation = l(t, e.options.chart.animation, !0);\n      },\n      stop: c\n    };\n  }), i(e, \"Core/Renderer/HTML/AST.js\", [e[\"Core/Globals.js\"], e[\"Core/Utilities.js\"]], function (t, e) {\n    var i = t.SVG_NS,\n      s = t.win,\n      r = e.attr,\n      o = e.createElement,\n      n = e.css,\n      a = e.error,\n      h = e.isFunction,\n      l = e.isString,\n      d = e.objectEach,\n      c = e.splat,\n      p = s.trustedTypes,\n      u = p && h(p.createPolicy) && p.createPolicy(\"highcharts\", {\n        createHTML: function createHTML(t) {\n          return t;\n        }\n      }),\n      g = u ? u.createHTML(\"\") : \"\",\n      f = function () {\n        try {\n          return !!new DOMParser().parseFromString(g, \"text/html\");\n        } catch (t) {\n          return !1;\n        }\n      }();\n    var m = /*#__PURE__*/function () {\n      function m(t) {\n        _classCallCheck(this, m);\n        this.nodes = \"string\" == typeof t ? this.parseMarkup(t) : t;\n      }\n      return _createClass(m, [{\n        key: \"addToDOM\",\n        value: function addToDOM(e) {\n          return function e(s, o) {\n            var h;\n            return c(s).forEach(function (s) {\n              var l;\n              var c = s.tagName,\n                p = s.textContent ? t.doc.createTextNode(s.textContent) : void 0,\n                u = m.bypassHTMLFiltering;\n              if (c) {\n                if (\"#text\" === c) l = p;else if (-1 !== m.allowedTags.indexOf(c) || u) {\n                  var _a5 = \"svg\" === c ? i : o.namespaceURI || i,\n                    _h2 = t.doc.createElementNS(_a5, c),\n                    _g = s.attributes || {};\n                  d(s, function (t, e) {\n                    \"tagName\" !== e && \"attributes\" !== e && \"children\" !== e && \"style\" !== e && \"textContent\" !== e && (_g[e] = t);\n                  }), r(_h2, u ? _g : m.filterUserAttributes(_g)), s.style && n(_h2, s.style), p && _h2.appendChild(p), e(s.children || [], _h2), l = _h2;\n                } else a(33, !1, void 0, {\n                  \"Invalid tagName in config\": c\n                });\n              }\n              l && o.appendChild(l), h = l;\n            }), h;\n          }(this.nodes, e);\n        }\n      }, {\n        key: \"parseMarkup\",\n        value: function parseMarkup(t) {\n          var e;\n          var i = [];\n          if (t = t.trim().replace(/ style=([\"'])/g, \" data-style=$1\"), f) e = new DOMParser().parseFromString(u ? u.createHTML(t) : t, \"text/html\");else {\n            var _i11 = o(\"div\");\n            _i11.innerHTML = t, e = {\n              body: _i11\n            };\n          }\n          var _s10 = function s(t, e) {\n            var i = t.nodeName.toLowerCase(),\n              r = {\n                tagName: i\n              };\n            \"#text\" === i && (r.textContent = t.textContent || \"\");\n            var o = t.attributes;\n            if (o) {\n              var _t13 = {};\n              [].forEach.call(o, function (e) {\n                \"data-style\" === e.name ? r.style = m.parseStyle(e.value) : _t13[e.name] = e.value;\n              }), r.attributes = _t13;\n            }\n            if (t.childNodes.length) {\n              var _e8 = [];\n              [].forEach.call(t.childNodes, function (t) {\n                _s10(t, _e8);\n              }), _e8.length && (r.children = _e8);\n            }\n            e.push(r);\n          };\n          return [].forEach.call(e.body.childNodes, function (t) {\n            return _s10(t, i);\n          }), i;\n        }\n      }], [{\n        key: \"filterUserAttributes\",\n        value: function filterUserAttributes(t) {\n          return d(t, function (e, i) {\n            var s = !0;\n            -1 === m.allowedAttributes.indexOf(i) && (s = !1), -1 !== [\"background\", \"dynsrc\", \"href\", \"lowsrc\", \"src\"].indexOf(i) && (s = l(e) && m.allowedReferences.some(function (t) {\n              return 0 === e.indexOf(t);\n            })), s || (a(33, !1, void 0, {\n              \"Invalid attribute in config\": \"\".concat(i)\n            }), delete t[i]), l(e) && t[i] && (t[i] = e.replace(/</g, \"&lt;\"));\n          }), t;\n        }\n      }, {\n        key: \"parseStyle\",\n        value: function parseStyle(t) {\n          return t.split(\";\").reduce(function (t, e) {\n            var i = e.split(\":\").map(function (t) {\n                return t.trim();\n              }),\n              s = i.shift();\n            return s && i.length && (t[s.replace(/-([a-z])/g, function (t) {\n              return t[1].toUpperCase();\n            })] = i.join(\":\")), t;\n          }, {});\n        }\n      }, {\n        key: \"setElementHTML\",\n        value: function setElementHTML(t, e) {\n          t.innerHTML = m.emptyHTML, e && new m(e).addToDOM(t);\n        }\n      }]);\n    }();\n    return m.allowedAttributes = [\"alt\", \"aria-controls\", \"aria-describedby\", \"aria-expanded\", \"aria-haspopup\", \"aria-hidden\", \"aria-label\", \"aria-labelledby\", \"aria-live\", \"aria-pressed\", \"aria-readonly\", \"aria-roledescription\", \"aria-selected\", \"class\", \"clip-path\", \"color\", \"colspan\", \"cx\", \"cy\", \"d\", \"dx\", \"dy\", \"disabled\", \"fill\", \"filterUnits\", \"flood-color\", \"flood-opacity\", \"height\", \"href\", \"id\", \"in\", \"in2\", \"markerHeight\", \"markerWidth\", \"offset\", \"opacity\", \"operator\", \"orient\", \"padding\", \"paddingLeft\", \"paddingRight\", \"patternUnits\", \"r\", \"radius\", \"refX\", \"refY\", \"role\", \"scope\", \"slope\", \"src\", \"startOffset\", \"stdDeviation\", \"stroke\", \"stroke-linecap\", \"stroke-width\", \"style\", \"tableValues\", \"result\", \"rowspan\", \"summary\", \"target\", \"tabindex\", \"text-align\", \"text-anchor\", \"textAnchor\", \"textLength\", \"title\", \"type\", \"valign\", \"width\", \"x\", \"x1\", \"x2\", \"xlink:href\", \"y\", \"y1\", \"y2\", \"zIndex\"], m.allowedReferences = [\"https://\", \"http://\", \"mailto:\", \"/\", \"../\", \"./\", \"#\"], m.allowedTags = [\"a\", \"abbr\", \"b\", \"br\", \"button\", \"caption\", \"circle\", \"clipPath\", \"code\", \"dd\", \"defs\", \"div\", \"dl\", \"dt\", \"em\", \"feComponentTransfer\", \"feComposite\", \"feDropShadow\", \"feFlood\", \"feFuncA\", \"feFuncB\", \"feFuncG\", \"feFuncR\", \"feGaussianBlur\", \"feMorphology\", \"feOffset\", \"feMerge\", \"feMergeNode\", \"filter\", \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\", \"hr\", \"i\", \"img\", \"li\", \"linearGradient\", \"marker\", \"ol\", \"p\", \"path\", \"pattern\", \"pre\", \"rect\", \"small\", \"span\", \"stop\", \"strong\", \"style\", \"sub\", \"sup\", \"svg\", \"table\", \"text\", \"textPath\", \"thead\", \"title\", \"tbody\", \"tspan\", \"td\", \"th\", \"tr\", \"u\", \"ul\", \"#text\"], m.emptyHTML = g, m.bypassHTMLFiltering = !1, m;\n  }), i(e, \"Core/Templating.js\", [e[\"Core/Defaults.js\"], e[\"Core/Utilities.js\"]], function (t, e) {\n    var i = t.defaultOptions,\n      s = t.defaultTime,\n      r = e.extend,\n      o = e.getNestedProperty,\n      n = e.isArray,\n      a = e.isNumber,\n      h = e.isObject,\n      l = e.pick,\n      d = e.pInt,\n      c = {\n        add: function add(t, e) {\n          return t + e;\n        },\n        divide: function divide(t, e) {\n          return 0 !== e ? t / e : \"\";\n        },\n        eq: function eq(t, e) {\n          return t == e;\n        },\n        each: function each(t) {\n          var e = arguments[arguments.length - 1];\n          return !!n(t) && t.map(function (i, s) {\n            return p(e.body, r(h(i) ? i : {\n              \"@this\": i\n            }, {\n              \"@index\": s,\n              \"@first\": 0 === s,\n              \"@last\": s === t.length - 1\n            }));\n          }).join(\"\");\n        },\n        ge: function ge(t, e) {\n          return t >= e;\n        },\n        gt: function gt(t, e) {\n          return t > e;\n        },\n        \"if\": function _if(t) {\n          return !!t;\n        },\n        le: function le(t, e) {\n          return t <= e;\n        },\n        lt: function lt(t, e) {\n          return t < e;\n        },\n        multiply: function multiply(t, e) {\n          return t * e;\n        },\n        ne: function ne(t, e) {\n          return t != e;\n        },\n        subtract: function subtract(t, e) {\n          return t - e;\n        },\n        unless: function unless(t) {\n          return !t;\n        }\n      };\n    function p() {\n      var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n      var e = arguments.length > 1 ? arguments[1] : undefined;\n      var r = arguments.length > 2 ? arguments[2] : undefined;\n      var n = /\\{([\\w\\:\\.\\,;\\-\\/<>%@\"'‚Äô= #\\(\\)]+)\\}/g,\n        a = /\\(([\\w\\:\\.\\,;\\-\\/<>%@\"'= ]+)\\)/g,\n        h = [],\n        d = /f$/,\n        g = /\\.(\\d)/,\n        f = i.lang,\n        m = r && r.time || s,\n        x = r && r.numberFormatter || u,\n        y = function y() {\n          var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n          var i;\n          return \"true\" === t || \"false\" !== t && ((i = Number(t)).toString() === t ? i : o(t, e));\n        },\n        b,\n        v,\n        S = 0,\n        C;\n      for (; null !== (b = n.exec(t));) {\n        var _v;\n        var _i12 = a.exec(b[1]);\n        _i12 && (b = _i12, C = !0), v && v.isBlock || (v = {\n          ctx: e,\n          expression: b[1],\n          find: b[0],\n          isBlock: \"#\" === b[1].charAt(0),\n          start: b.index,\n          startInner: b.index + b[0].length,\n          length: b[0].length\n        });\n        var _s11 = b[1].split(\" \")[0].replace(\"#\", \"\");\n        c[_s11] && (v.isBlock && _s11 === v.fn && S++, v.fn || (v.fn = _s11));\n        var _r4 = \"else\" === b[1];\n        if (v.isBlock && v.fn && (b[1] === \"/\".concat(v.fn) || _r4)) {\n          if (S) !_r4 && S--;else {\n            var _e9 = v.startInner,\n              _i13 = t.substr(_e9, b.index - _e9);\n            void 0 === v.body ? (v.body = _i13, v.startInner = b.index + b[0].length) : v.elseBody = _i13, v.find += _i13 + b[0], _r4 || (h.push(v), v = void 0);\n          }\n        } else v.isBlock || h.push(v);\n        if (_i12 && !((_v = v) !== null && _v !== void 0 && _v.isBlock)) break;\n      }\n      return h.forEach(function (i) {\n        var s, o;\n        var n = i.body,\n          a = i.elseBody,\n          h = i.expression,\n          u = i.fn;\n        if (u) {\n          var _t14 = [i],\n            _l3 = h.split(\" \");\n          for (o = c[u].length; o--;) _t14.unshift(y(_l3[o + 1]));\n          s = c[u].apply(e, _t14), i.isBlock && \"boolean\" == typeof s && (s = p(s ? n : a, e, r));\n        } else {\n          var _t15 = h.split(\":\");\n          if (s = y(_t15.shift() || \"\"), _t15.length && \"number\" == typeof s) {\n            var _e10 = _t15.join(\":\");\n            if (d.test(_e10)) {\n              var _t16 = parseInt((_e10.match(g) || [\"\", \"-1\"])[1], 10);\n              null !== s && (s = x(s, _t16, f.decimalPoint, _e10.indexOf(\",\") > -1 ? f.thousandsSep : \"\"));\n            } else s = m.dateFormat(_e10, s);\n          }\n        }\n        t = t.replace(i.find, l(s, \"\"));\n      }), C ? p(t, e, r) : t;\n    }\n    function u(t, e, s, r) {\n      var o, n;\n      t = +t || 0, e = +e;\n      var h = i.lang,\n        c = (t.toString().split(\".\")[1] || \"\").split(\"e\")[0].length,\n        p = t.toString().split(\"e\"),\n        u = e;\n      -1 === e ? e = Math.min(c, 20) : a(e) ? e && p[1] && p[1] < 0 && ((n = e + +p[1]) >= 0 ? (p[0] = (+p[0]).toExponential(n).split(\"e\")[0], e = n) : (p[0] = p[0].split(\".\")[0] || 0, t = e < 20 ? (p[0] * Math.pow(10, p[1])).toFixed(e) : 0, p[1] = 0)) : e = 2;\n      var g = (Math.abs(p[1] ? p[0] : t) + Math.pow(10, -Math.max(e, c) - 1)).toFixed(e),\n        f = String(d(g)),\n        m = f.length > 3 ? f.length % 3 : 0;\n      return s = l(s, h.decimalPoint), r = l(r, h.thousandsSep), o = (t < 0 ? \"-\" : \"\") + (m ? f.substr(0, m) + r : \"\"), 0 > +p[1] && !u ? o = \"0\" : o += f.substr(m).replace(/(\\d{3})(?=\\d)/g, \"$1\" + r), e ? o += s + g.slice(-e) : 0 == +o && (o = \"0\"), p[1] && 0 != +o && (o += \"e\" + p[1]), o;\n    }\n    return {\n      dateFormat: function dateFormat(t, e, i) {\n        return s.dateFormat(t, e, i);\n      },\n      format: p,\n      helpers: c,\n      numberFormat: u\n    };\n  }), i(e, \"Core/Renderer/RendererRegistry.js\", [e[\"Core/Globals.js\"]], function (t) {\n    var e, i;\n    var s;\n    return (i = e || (e = {})).rendererTypes = {}, i.getRendererType = function () {\n      var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : s;\n      return i.rendererTypes[t] || i.rendererTypes[s];\n    }, i.registerRendererType = function (e, r, o) {\n      i.rendererTypes[e] = r, (!s || o) && (s = e, t.Renderer = r);\n    }, e;\n  }), i(e, \"Core/Renderer/RendererUtilities.js\", [e[\"Core/Utilities.js\"]], function (t) {\n    var e;\n    var i = t.clamp,\n      s = t.pick,\n      r = t.pushUnique,\n      o = t.stableSort;\n    return (e || (e = {})).distribute = function t(e, n, a) {\n      var h = e,\n        l = h.reducedLen || n,\n        d = function d(t, e) {\n          return t.target - e.target;\n        },\n        c = [],\n        p = e.length,\n        u = [],\n        g = c.push,\n        f,\n        m,\n        x,\n        y = !0,\n        b,\n        v,\n        S = 0,\n        C;\n      for (f = p; f--;) S += e[f].size;\n      if (S > l) {\n        for (o(e, function (t, e) {\n          return (e.rank || 0) - (t.rank || 0);\n        }), x = (C = e[0].rank === e[e.length - 1].rank) ? p / 2 : -1, m = C ? x : p - 1; x && S > l;) b = e[f = Math.floor(m)], r(u, f) && (S -= b.size), m += x, C && m >= e.length && (x /= 2, m = x);\n        u.sort(function (t, e) {\n          return e - t;\n        }).forEach(function (t) {\n          return g.apply(c, e.splice(t, 1));\n        });\n      }\n      for (o(e, d), e = e.map(function (t) {\n        return {\n          size: t.size,\n          targets: [t.target],\n          align: s(t.align, .5)\n        };\n      }); y;) {\n        for (f = e.length; f--;) b = e[f], v = (Math.min.apply(0, b.targets) + Math.max.apply(0, b.targets)) / 2, b.pos = i(v - b.size * b.align, 0, n - b.size);\n        for (f = e.length, y = !1; f--;) f > 0 && e[f - 1].pos + e[f - 1].size > e[f].pos && (e[f - 1].size += e[f].size, e[f - 1].targets = e[f - 1].targets.concat(e[f].targets), e[f - 1].align = .5, e[f - 1].pos + e[f - 1].size > n && (e[f - 1].pos = n - e[f - 1].size), e.splice(f, 1), y = !0);\n      }\n      return g.apply(h, c), f = 0, e.some(function (e) {\n        var i = 0;\n        return (e.targets || []).some(function () {\n          return (h[f].pos = e.pos + i, void 0 !== a && Math.abs(h[f].pos - h[f].target) > a) ? (h.slice(0, f + 1).forEach(function (t) {\n            return delete t.pos;\n          }), h.reducedLen = (h.reducedLen || n) - .1 * n, h.reducedLen > .1 * n && t(h, n, a), !0) : (i += h[f].size, f++, !1);\n        });\n      }), o(h, d), h;\n    }, e;\n  }), i(e, \"Core/Renderer/SVG/SVGElement.js\", [e[\"Core/Animation/AnimationUtilities.js\"], e[\"Core/Color/Color.js\"], e[\"Core/Globals.js\"], e[\"Core/Utilities.js\"]], function (t, e, i, s) {\n    var r = t.animate,\n      o = t.animObject,\n      n = t.stop,\n      a = i.deg2rad,\n      h = i.doc,\n      l = i.svg,\n      d = i.SVG_NS,\n      c = i.win,\n      p = s.addEvent,\n      u = s.attr,\n      g = s.createElement,\n      f = s.crisp,\n      m = s.css,\n      x = s.defined,\n      y = s.erase,\n      b = s.extend,\n      v = s.fireEvent,\n      S = s.isArray,\n      C = s.isFunction,\n      k = s.isObject,\n      M = s.isString,\n      w = s.merge,\n      A = s.objectEach,\n      T = s.pick,\n      P = s.pInt,\n      L = s.pushUnique,\n      O = s.replaceNested,\n      D = s.syncTimeout,\n      E = s.uniqueKey;\n    var I = /*#__PURE__*/function () {\n      function I(t, e) {\n        _classCallCheck(this, I);\n        this.onEvents = {}, this.opacity = 1, this.SVG_NS = d, this.element = \"span\" === e || \"body\" === e ? g(e) : h.createElementNS(this.SVG_NS, e), this.renderer = t, this.styles = {}, v(this, \"afterInit\");\n      }\n      return _createClass(I, [{\n        key: \"_defaultGetter\",\n        value: function _defaultGetter(t) {\n          var e = T(this[t + \"Value\"], this[t], this.element ? this.element.getAttribute(t) : null, 0);\n          return /^-?[\\d\\.]+$/.test(e) && (e = parseFloat(e)), e;\n        }\n      }, {\n        key: \"_defaultSetter\",\n        value: function _defaultSetter(t, e, i) {\n          i.setAttribute(e, t);\n        }\n      }, {\n        key: \"add\",\n        value: function add(t) {\n          var e;\n          var i = this.renderer,\n            s = this.element;\n          return t && (this.parentGroup = t), void 0 !== this.textStr && \"text\" === this.element.nodeName && i.buildText(this), this.added = !0, (!t || t.handleZ || this.zIndex) && (e = this.zIndexSetter()), e || (t ? t.element : i.box).appendChild(s), this.onAdd && this.onAdd(), this;\n        }\n      }, {\n        key: \"addClass\",\n        value: function addClass(t, e) {\n          var i = e ? \"\" : this.attr(\"class\") || \"\";\n          return (t = (t || \"\").split(/ /g).reduce(function (t, e) {\n            return -1 === i.indexOf(e) && t.push(e), t;\n          }, i ? [i] : []).join(\" \")) !== i && this.attr(\"class\", t), this;\n        }\n      }, {\n        key: \"afterSetters\",\n        value: function afterSetters() {\n          this.doTransform && (this.updateTransform(), this.doTransform = !1);\n        }\n      }, {\n        key: \"align\",\n        value: function align(t, e, i) {\n          var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : !0;\n          var r, o, n, a;\n          var h = {},\n            l = this.renderer,\n            d = l.alignedObjects,\n            c = !!t;\n          t ? (this.alignOptions = t, this.alignByTranslate = e, this.alignTo = i) : (t = this.alignOptions || {}, e = this.alignByTranslate, i = this.alignTo);\n          var p = !i || M(i) ? i || \"renderer\" : void 0;\n          p && (c && L(d, this), i = void 0);\n          var u = T(i, l[p], l),\n            g = t.align,\n            f = t.verticalAlign;\n          return r = (u.x || 0) + (t.x || 0), o = (u.y || 0) + (t.y || 0), \"right\" === g ? n = 1 : \"center\" === g && (n = 2), n && (r += ((u.width || 0) - (t.width || 0)) / n), h[e ? \"translateX\" : \"x\"] = Math.round(r), \"bottom\" === f ? a = 1 : \"middle\" === f && (a = 2), a && (o += ((u.height || 0) - (t.height || 0)) / a), h[e ? \"translateY\" : \"y\"] = Math.round(o), s && (this[this.placed ? \"animate\" : \"attr\"](h), this.placed = !0), this.alignAttr = h, this;\n        }\n      }, {\n        key: \"alignSetter\",\n        value: function alignSetter(t) {\n          var e = {\n            left: \"start\",\n            center: \"middle\",\n            right: \"end\"\n          };\n          e[t] && (this.alignValue = t, this.element.setAttribute(\"text-anchor\", e[t]));\n        }\n      }, {\n        key: \"animate\",\n        value: function animate(t, e, i) {\n          var _this = this;\n          var s = o(T(e, this.renderer.globalAnimation, !0)),\n            n = s.defer;\n          return h.hidden && (s.duration = 0), 0 !== s.duration ? (i && (s.complete = i), D(function () {\n            _this.element && r(_this, t, s);\n          }, n)) : (this.attr(t, void 0, i || s.complete), A(t, function (t, e) {\n            s.step && s.step.call(this, t, {\n              prop: e,\n              pos: 1,\n              elem: this\n            });\n          }, this)), this;\n        }\n      }, {\n        key: \"applyTextOutline\",\n        value: function applyTextOutline(t) {\n          var e = this.element;\n          -1 !== t.indexOf(\"contrast\") && (t = t.replace(/contrast/g, this.renderer.getContrast(e.style.fill)));\n          var s = t.split(\" \"),\n            r = s[s.length - 1],\n            o = s[0];\n          if (o && \"none\" !== o && i.svg) {\n            this.fakeTS = !0, o = o.replace(/(^[\\d\\.]+)(.*?)$/g, function (t, e, i) {\n              return 2 * Number(e) + i;\n            }), this.removeTextOutline();\n            var _t17 = h.createElementNS(d, \"tspan\");\n            u(_t17, {\n              \"class\": \"highcharts-text-outline\",\n              fill: r,\n              stroke: r,\n              \"stroke-width\": o,\n              \"stroke-linejoin\": \"round\"\n            });\n            var _i14 = e.querySelector(\"textPath\") || e;\n            [].forEach.call(_i14.childNodes, function (e) {\n              var i = e.cloneNode(!0);\n              i.removeAttribute && [\"fill\", \"stroke\", \"stroke-width\", \"stroke\"].forEach(function (t) {\n                return i.removeAttribute(t);\n              }), _t17.appendChild(i);\n            });\n            var _s12 = 0;\n            [].forEach.call(_i14.querySelectorAll(\"text tspan\"), function (t) {\n              _s12 += Number(t.getAttribute(\"dy\"));\n            });\n            var _n3 = h.createElementNS(d, \"tspan\");\n            _n3.textContent = \"‚Äã\", u(_n3, {\n              x: Number(e.getAttribute(\"x\")),\n              dy: -_s12\n            }), _t17.appendChild(_n3), _i14.insertBefore(_t17, _i14.firstChild);\n          }\n        }\n      }, {\n        key: \"attr\",\n        value: function attr(t, e, i, s) {\n          var r = this.element,\n            o = I.symbolCustomAttribs,\n            a,\n            h,\n            l = this,\n            d;\n          return \"string\" == typeof t && void 0 !== e && (a = t, (t = {})[a] = e), \"string\" == typeof t ? l = (this[t + \"Getter\"] || this._defaultGetter).call(this, t, r) : (A(t, function (e, i) {\n            d = !1, s || n(this, i), this.symbolName && -1 !== o.indexOf(i) && (h || (this.symbolAttr(t), h = !0), d = !0), this.rotation && (\"x\" === i || \"y\" === i) && (this.doTransform = !0), d || (this[i + \"Setter\"] || this._defaultSetter).call(this, e, i, r);\n          }, this), this.afterSetters()), i && i.call(this), l;\n        }\n      }, {\n        key: \"clip\",\n        value: function clip(t) {\n          if (t && !t.clipPath) {\n            var _e11 = E() + \"-\",\n              _i15 = this.renderer.createElement(\"clipPath\").attr({\n                id: _e11\n              }).add(this.renderer.defs);\n            b(t, {\n              clipPath: _i15,\n              id: _e11,\n              count: 0\n            }), t.add(_i15);\n          }\n          return this.attr(\"clip-path\", t ? \"url(\".concat(this.renderer.url, \"#\").concat(t.id, \")\") : \"none\");\n        }\n      }, {\n        key: \"crisp\",\n        value: function crisp(t, e) {\n          e = Math.round(e || t.strokeWidth || 0);\n          var i = t.x || this.x || 0,\n            s = t.y || this.y || 0,\n            r = (t.width || this.width || 0) + i,\n            o = (t.height || this.height || 0) + s,\n            n = f(i, e),\n            a = f(s, e);\n          return b(t, {\n            x: n,\n            y: a,\n            width: f(r, e) - n,\n            height: f(o, e) - a\n          }), x(t.strokeWidth) && (t.strokeWidth = e), t;\n        }\n      }, {\n        key: \"complexColor\",\n        value: function complexColor(t, i, s) {\n          var r = this.renderer,\n            o,\n            n,\n            a,\n            h,\n            l,\n            d,\n            c,\n            p,\n            u,\n            g,\n            f = [],\n            m;\n          v(this.renderer, \"complexColor\", {\n            args: arguments\n          }, function () {\n            if (t.radialGradient ? n = \"radialGradient\" : t.linearGradient && (n = \"linearGradient\"), n) {\n              if (a = t[n], l = r.gradients, d = t.stops, u = s.radialReference, S(a) && (t[n] = a = {\n                x1: a[0],\n                y1: a[1],\n                x2: a[2],\n                y2: a[3],\n                gradientUnits: \"userSpaceOnUse\"\n              }), \"radialGradient\" === n && u && !x(a.gradientUnits) && (h = a, a = w(a, r.getRadialAttr(u, h), {\n                gradientUnits: \"userSpaceOnUse\"\n              })), A(a, function (t, e) {\n                \"id\" !== e && f.push(e, t);\n              }), A(d, function (t) {\n                f.push(t);\n              }), l[f = f.join(\",\")]) g = l[f].attr(\"id\");else {\n                a.id = g = E();\n                var _t18 = l[f] = r.createElement(n).attr(a).add(r.defs);\n                _t18.radAttr = h, _t18.stops = [], d.forEach(function (i) {\n                  0 === i[1].indexOf(\"rgba\") ? (c = (o = e.parse(i[1])).get(\"rgb\"), p = o.get(\"a\")) : (c = i[1], p = 1);\n                  var s = r.createElement(\"stop\").attr({\n                    offset: i[0],\n                    \"stop-color\": c,\n                    \"stop-opacity\": p\n                  }).add(_t18);\n                  _t18.stops.push(s);\n                });\n              }\n              m = \"url(\" + r.url + \"#\" + g + \")\", s.setAttribute(i, m), s.gradient = f, t.toString = function () {\n                return m;\n              };\n            }\n          });\n        }\n      }, {\n        key: \"css\",\n        value: function css(t) {\n          var e = this.styles,\n            i = {},\n            s = this.element,\n            r,\n            o = !e;\n          if (e && A(t, function (t, s) {\n            e && e[s] !== t && (i[s] = t, o = !0);\n          }), o) {\n            e && (t = b(e, i)), null === t.width || \"auto\" === t.width ? delete this.textWidth : \"text\" === s.nodeName.toLowerCase() && t.width && (r = this.textWidth = P(t.width)), b(this.styles, t), r && !l && this.renderer.forExport && delete t.width;\n            var _o8 = w(t);\n            s.namespaceURI === this.SVG_NS && ([\"textOutline\", \"textOverflow\", \"width\"].forEach(function (t) {\n              return _o8 && delete _o8[t];\n            }), _o8.color && (_o8.fill = _o8.color)), m(s, _o8);\n          }\n          return this.added && (\"text\" === this.element.nodeName && this.renderer.buildText(this), t.textOutline && this.applyTextOutline(t.textOutline)), this;\n        }\n      }, {\n        key: \"dashstyleSetter\",\n        value: function dashstyleSetter(t) {\n          var e,\n            i = this[\"stroke-width\"];\n          if (\"inherit\" === i && (i = 1), t = t && t.toLowerCase()) {\n            var _s13 = t.replace(\"shortdashdotdot\", \"3,1,1,1,1,1,\").replace(\"shortdashdot\", \"3,1,1,1\").replace(\"shortdot\", \"1,1,\").replace(\"shortdash\", \"3,1,\").replace(\"longdash\", \"8,3,\").replace(/dot/g, \"1,3,\").replace(\"dash\", \"4,3,\").replace(/,$/, \"\").split(\",\");\n            for (e = _s13.length; e--;) _s13[e] = \"\" + P(_s13[e]) * T(i, NaN);\n            t = _s13.join(\",\").replace(/NaN/g, \"none\"), this.element.setAttribute(\"stroke-dasharray\", t);\n          }\n        }\n      }, {\n        key: \"destroy\",\n        value: function destroy() {\n          var _t$connector;\n          var t = this,\n            e = t.element || {},\n            i = t.renderer,\n            s = e.ownerSVGElement,\n            r = \"SPAN\" === e.nodeName && t.parentGroup || void 0,\n            o,\n            a;\n          if (e.onclick = e.onmouseout = e.onmouseover = e.onmousemove = e.point = null, n(t), t.clipPath && s) {\n            var _e12 = t.clipPath;\n            [].forEach.call(s.querySelectorAll(\"[clip-path],[CLIP-PATH]\"), function (t) {\n              t.getAttribute(\"clip-path\").indexOf(_e12.element.id) > -1 && t.removeAttribute(\"clip-path\");\n            }), t.clipPath = _e12.destroy();\n          }\n          if (t.connector = (_t$connector = t.connector) === null || _t$connector === void 0 ? void 0 : _t$connector.destroy(), t.stops) {\n            for (a = 0; a < t.stops.length; a++) t.stops[a].destroy();\n            t.stops.length = 0, t.stops = void 0;\n          }\n          for (t.safeRemoveChild(e); r && r.div && 0 === r.div.childNodes.length;) o = r.parentGroup, t.safeRemoveChild(r.div), delete r.div, r = o;\n          t.alignOptions && y(i.alignedObjects, t), A(t, function (e, i) {\n            t[i] && t[i].parentGroup === t && t[i].destroy && t[i].destroy(), delete t[i];\n          });\n        }\n      }, {\n        key: \"dSetter\",\n        value: function dSetter(t, e, i) {\n          S(t) && (\"string\" == typeof t[0] && (t = this.renderer.pathToSegments(t)), this.pathArray = t, t = t.reduce(function (t, e, i) {\n            return e && e.join ? (i ? t + \" \" : \"\") + e.join(\" \") : (e || \"\").toString();\n          }, \"\")), /(NaN| {2}|^$)/.test(t) && (t = \"M 0 0\"), this[e] !== t && (i.setAttribute(e, t), this[e] = t);\n        }\n      }, {\n        key: \"fillSetter\",\n        value: function fillSetter(t, e, i) {\n          \"string\" == typeof t ? i.setAttribute(e, t) : t && this.complexColor(t, e, i);\n        }\n      }, {\n        key: \"hrefSetter\",\n        value: function hrefSetter(t, e, i) {\n          i.setAttributeNS(\"http://www.w3.org/1999/xlink\", e, t);\n        }\n      }, {\n        key: \"getBBox\",\n        value: function getBBox(t, e) {\n          var i, s, r, o;\n          var n = this.alignValue,\n            a = this.element,\n            h = this.renderer,\n            l = this.styles,\n            d = this.textStr,\n            c = h.cache,\n            p = h.cacheKeys,\n            u = a.namespaceURI === this.SVG_NS,\n            g = T(e, this.rotation, 0),\n            f = h.styledMode ? a && I.prototype.getStyle.call(a, \"font-size\") : l.fontSize;\n          if (x(d) && (-1 === (o = d.toString()).indexOf(\"<\") && (o = o.replace(/\\d/g, \"0\")), o += [\"\", h.rootFontSize, f, g, this.textWidth, n, l.textOverflow, l.fontWeight].join(\",\")), o && !t && (i = c[o]), !i || i.polygon) {\n            if (u || h.forExport) {\n              try {\n                r = this.fakeTS && function (t) {\n                  var e = a.querySelector(\".highcharts-text-outline\");\n                  e && m(e, {\n                    display: t\n                  });\n                }, C(r) && r(\"none\"), i = a.getBBox ? b({}, a.getBBox()) : {\n                  width: a.offsetWidth,\n                  height: a.offsetHeight,\n                  x: 0,\n                  y: 0\n                }, C(r) && r(\"\");\n              } catch (t) {}\n              (!i || i.width < 0) && (i = {\n                x: 0,\n                y: 0,\n                width: 0,\n                height: 0\n              });\n            } else i = this.htmlGetBBox();\n            s = i.height, u && (i.height = s = {\n              \"11px,17\": 14,\n              \"13px,20\": 16\n            }[\"\".concat(f || \"\", \",\").concat(Math.round(s))] || s), g && (i = this.getRotatedBox(i, g));\n            var _t19 = {\n              bBox: i\n            };\n            v(this, \"afterGetBBox\", _t19), i = _t19.bBox;\n          }\n          if (o && (\"\" === d || i.height > 0)) {\n            for (; p.length > 250;) delete c[p.shift()];\n            c[o] || p.push(o), c[o] = i;\n          }\n          return i;\n        }\n      }, {\n        key: \"getRotatedBox\",\n        value: function getRotatedBox(t, e) {\n          var i = t.x,\n            s = t.y,\n            r = t.width,\n            o = t.height,\n            n = this.alignValue,\n            h = this.translateY,\n            _this$rotationOriginX = this.rotationOriginX,\n            l = _this$rotationOriginX === void 0 ? 0 : _this$rotationOriginX,\n            _this$rotationOriginY = this.rotationOriginY,\n            d = _this$rotationOriginY === void 0 ? 0 : _this$rotationOriginY,\n            c = {\n              right: 1,\n              center: .5\n            }[n || 0] || 0,\n            p = Number(this.element.getAttribute(\"y\") || 0) - (h ? 0 : s),\n            u = e * a,\n            g = (e - 90) * a,\n            f = Math.cos(u),\n            m = Math.sin(u),\n            x = r * f,\n            y = r * m,\n            b = Math.cos(g),\n            v = Math.sin(g),\n            _map = [l, d].map(function (t) {\n              return [t - t * f, t * m];\n            }),\n            _map2 = _slicedToArray(_map, 2),\n            _map2$ = _slicedToArray(_map2[0], 2),\n            S = _map2$[0],\n            C = _map2$[1],\n            _map2$2 = _slicedToArray(_map2[1], 2),\n            k = _map2$2[0],\n            M = _map2$2[1],\n            w = i + c * (r - x) + S + M + p * b,\n            A = w + x,\n            T = A - o * b,\n            P = T - x,\n            L = s + p - c * y - C + k + p * v,\n            O = L + y,\n            D = O - o * v,\n            E = D - y,\n            _I = Math.min(w, A, T, P),\n            j = Math.min(L, O, D, E),\n            B = Math.max(w, A, T, P) - _I,\n            R = Math.max(L, O, D, E) - j;\n          return {\n            x: _I,\n            y: j,\n            width: B,\n            height: R,\n            polygon: [[w, L], [A, O], [T, D], [P, E]]\n          };\n        }\n      }, {\n        key: \"getStyle\",\n        value: function getStyle(t) {\n          return c.getComputedStyle(this.element || this, \"\").getPropertyValue(t);\n        }\n      }, {\n        key: \"hasClass\",\n        value: function hasClass(t) {\n          return -1 !== (\"\" + this.attr(\"class\")).split(\" \").indexOf(t);\n        }\n      }, {\n        key: \"hide\",\n        value: function hide() {\n          return this.attr({\n            visibility: \"hidden\"\n          });\n        }\n      }, {\n        key: \"htmlGetBBox\",\n        value: function htmlGetBBox() {\n          return {\n            height: 0,\n            width: 0,\n            x: 0,\n            y: 0\n          };\n        }\n      }, {\n        key: \"on\",\n        value: function on(t, e) {\n          var i = this.onEvents;\n          return i[t] && i[t](), i[t] = p(this.element, t, e), this;\n        }\n      }, {\n        key: \"opacitySetter\",\n        value: function opacitySetter(t, e, i) {\n          var s = Number(Number(t).toFixed(3));\n          this.opacity = s, i.setAttribute(e, s);\n        }\n      }, {\n        key: \"reAlign\",\n        value: function reAlign() {\n          var _this$alignOptions;\n          ((_this$alignOptions = this.alignOptions) === null || _this$alignOptions === void 0 ? void 0 : _this$alignOptions.width) && \"left\" !== this.alignOptions.align && (this.alignOptions.width = this.getBBox().width, this.placed = !1, this.align());\n        }\n      }, {\n        key: \"removeClass\",\n        value: function removeClass(t) {\n          return this.attr(\"class\", (\"\" + this.attr(\"class\")).replace(M(t) ? RegExp(\"(^| )\".concat(t, \"( |$)\")) : t, \" \").replace(/ +/g, \" \").trim());\n        }\n      }, {\n        key: \"removeTextOutline\",\n        value: function removeTextOutline() {\n          var t = this.element.querySelector(\"tspan.highcharts-text-outline\");\n          t && this.safeRemoveChild(t);\n        }\n      }, {\n        key: \"safeRemoveChild\",\n        value: function safeRemoveChild(t) {\n          var e = t.parentNode;\n          e && e.removeChild(t);\n        }\n      }, {\n        key: \"setRadialReference\",\n        value: function setRadialReference(t) {\n          var e = this.element.gradient && this.renderer.gradients[this.element.gradient];\n          return this.element.radialReference = t, e && e.radAttr && e.animate(this.renderer.getRadialAttr(t, e.radAttr)), this;\n        }\n      }, {\n        key: \"shadow\",\n        value: function shadow(t) {\n          var _this$parentGroup;\n          var e = this.renderer,\n            i = w(((_this$parentGroup = this.parentGroup) === null || _this$parentGroup === void 0 ? void 0 : _this$parentGroup.rotation) === 90 ? {\n              offsetX: -1,\n              offsetY: -1\n            } : {}, k(t) ? t : {}),\n            s = e.shadowDefinition(i);\n          return this.attr({\n            filter: t ? \"url(\".concat(e.url, \"#\").concat(s, \")\") : \"none\"\n          });\n        }\n      }, {\n        key: \"show\",\n        value: function show() {\n          var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : !0;\n          return this.attr({\n            visibility: t ? \"inherit\" : \"visible\"\n          });\n        }\n      }, {\n        key: \"stroke-widthSetter\",\n        value: function strokeWidthSetter(t, e, i) {\n          this[e] = t, i.setAttribute(e, t);\n        }\n      }, {\n        key: \"strokeWidth\",\n        value: function strokeWidth() {\n          if (!this.renderer.styledMode) return this[\"stroke-width\"] || 0;\n          var t = this.getStyle(\"stroke-width\"),\n            e = 0,\n            i;\n          return /px$/.test(t) ? e = P(t) : \"\" !== t && (u(i = h.createElementNS(d, \"rect\"), {\n            width: t,\n            \"stroke-width\": 0\n          }), this.element.parentNode.appendChild(i), e = i.getBBox().width, i.parentNode.removeChild(i)), e;\n        }\n      }, {\n        key: \"symbolAttr\",\n        value: function symbolAttr(t) {\n          var e = this;\n          I.symbolCustomAttribs.forEach(function (i) {\n            e[i] = T(t[i], e[i]);\n          }), e.attr({\n            d: e.renderer.symbols[e.symbolName](e.x, e.y, e.width, e.height, e)\n          });\n        }\n      }, {\n        key: \"textSetter\",\n        value: function textSetter(t) {\n          t !== this.textStr && (delete this.textPxLength, this.textStr = t, this.added && this.renderer.buildText(this), this.reAlign());\n        }\n      }, {\n        key: \"titleSetter\",\n        value: function titleSetter(t) {\n          var e = this.element,\n            i = e.getElementsByTagName(\"title\")[0] || h.createElementNS(this.SVG_NS, \"title\");\n          e.insertBefore ? e.insertBefore(i, e.firstChild) : e.appendChild(i), i.textContent = O(T(t, \"\"), [/<[^>]*>/g, \"\"]).replace(/&lt;/g, \"<\").replace(/&gt;/g, \">\");\n        }\n      }, {\n        key: \"toFront\",\n        value: function toFront() {\n          var t = this.element;\n          return t.parentNode.appendChild(t), this;\n        }\n      }, {\n        key: \"translate\",\n        value: function translate(t, e) {\n          return this.attr({\n            translateX: t,\n            translateY: e\n          });\n        }\n      }, {\n        key: \"updateTransform\",\n        value: function updateTransform() {\n          var _this$text;\n          var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"transform\";\n          var e = this.element,\n            i = this.matrix,\n            _this$rotation = this.rotation,\n            s = _this$rotation === void 0 ? 0 : _this$rotation,\n            r = this.rotationOriginX,\n            o = this.rotationOriginY,\n            n = this.scaleX,\n            a = this.scaleY,\n            _this$translateX = this.translateX,\n            h = _this$translateX === void 0 ? 0 : _this$translateX,\n            _this$translateY = this.translateY,\n            l = _this$translateY === void 0 ? 0 : _this$translateY,\n            d = [\"translate(\" + h + \",\" + l + \")\"];\n          x(i) && d.push(\"matrix(\" + i.join(\",\") + \")\"), s && (d.push(\"rotate(\" + s + \" \" + T(r, e.getAttribute(\"x\"), 0) + \" \" + T(o, e.getAttribute(\"y\") || 0) + \")\"), ((_this$text = this.text) === null || _this$text === void 0 ? void 0 : _this$text.element.tagName) === \"SPAN\" && this.text.attr({\n            rotation: s,\n            rotationOriginX: (r || 0) - this.padding,\n            rotationOriginY: (o || 0) - this.padding\n          })), (x(n) || x(a)) && d.push(\"scale(\" + T(n, 1) + \" \" + T(a, 1) + \")\"), d.length && !(this.text || this).textPath && e.setAttribute(t, d.join(\" \"));\n        }\n      }, {\n        key: \"visibilitySetter\",\n        value: function visibilitySetter(t, e, i) {\n          \"inherit\" === t ? i.removeAttribute(e) : this[e] !== t && i.setAttribute(e, t), this[e] = t;\n        }\n      }, {\n        key: \"xGetter\",\n        value: function xGetter(t) {\n          return \"circle\" === this.element.nodeName && (\"x\" === t ? t = \"cx\" : \"y\" === t && (t = \"cy\")), this._defaultGetter(t);\n        }\n      }, {\n        key: \"zIndexSetter\",\n        value: function zIndexSetter(t, e) {\n          var i = this.renderer,\n            s = this.parentGroup,\n            r = (s || i).element || i.box,\n            o = this.element,\n            n = r === i.box,\n            a,\n            h,\n            l,\n            d = !1,\n            c,\n            p = this.added,\n            u;\n          if (x(t) ? (o.setAttribute(\"data-z-index\", t), t = +t, this[e] === t && (p = !1)) : x(this[e]) && o.removeAttribute(\"data-z-index\"), this[e] = t, p) {\n            for ((t = this.zIndex) && s && (s.handleZ = !0), u = (a = r.childNodes).length - 1; u >= 0 && !d; u--) c = !x(l = (h = a[u]).getAttribute(\"data-z-index\")), h !== o && (t < 0 && c && !n && !u ? (r.insertBefore(o, a[u]), d = !0) : (P(l) <= t || c && (!x(t) || t >= 0)) && (r.insertBefore(o, a[u + 1]), d = !0));\n            d || (r.insertBefore(o, a[n ? 3 : 0]), d = !0);\n          }\n          return d;\n        }\n      }]);\n    }();\n    return I.symbolCustomAttribs = [\"anchorX\", \"anchorY\", \"clockwise\", \"end\", \"height\", \"innerR\", \"r\", \"start\", \"width\", \"x\", \"y\"], I.prototype.strokeSetter = I.prototype.fillSetter, I.prototype.yGetter = I.prototype.xGetter, I.prototype.matrixSetter = I.prototype.rotationOriginXSetter = I.prototype.rotationOriginYSetter = I.prototype.rotationSetter = I.prototype.scaleXSetter = I.prototype.scaleYSetter = I.prototype.translateXSetter = I.prototype.translateYSetter = I.prototype.verticalAlignSetter = function (t, e) {\n      this[e] = t, this.doTransform = !0;\n    }, I;\n  }), i(e, \"Core/Renderer/SVG/SVGLabel.js\", [e[\"Core/Renderer/SVG/SVGElement.js\"], e[\"Core/Utilities.js\"]], function (t, e) {\n    var i = e.defined,\n      s = e.extend,\n      r = e.isNumber,\n      o = e.merge,\n      n = e.pick,\n      a = e.removeEvent;\n    var h = /*#__PURE__*/function (_t20) {\n      function h(t, e, i, s, r, o, n, a, l, d) {\n        var _this2;\n        _classCallCheck(this, h);\n        var c;\n        _this2 = _callSuper(this, h, [t, \"g\"]), _this2.paddingLeftSetter = _this2.paddingSetter, _this2.paddingRightSetter = _this2.paddingSetter, _this2.doUpdate = !1, _this2.textStr = e, _this2.x = i, _this2.y = s, _this2.anchorX = o, _this2.anchorY = n, _this2.baseline = l, _this2.className = d, _this2.addClass(\"button\" === d ? \"highcharts-no-tooltip\" : \"highcharts-label\"), d && _this2.addClass(\"highcharts-\" + d), _this2.text = t.text(void 0, 0, 0, a).attr({\n          zIndex: 1\n        }), \"string\" == typeof r && ((c = /^url\\((.*?)\\)$/.test(r)) || _this2.renderer.symbols[r]) && (_this2.symbolKey = r), _this2.bBox = h.emptyBBox, _this2.padding = 3, _this2.baselineOffset = 0, _this2.needsBox = t.styledMode || c, _this2.deferredAttr = {}, _this2.alignFactor = 0;\n        return _this2;\n      }\n      _inherits(h, _t20);\n      return _createClass(h, [{\n        key: \"alignSetter\",\n        value: function alignSetter(t) {\n          var e = {\n            left: 0,\n            center: .5,\n            right: 1\n          }[t];\n          e !== this.alignFactor && (this.alignFactor = e, this.bBox && r(this.xSetting) && this.attr({\n            x: this.xSetting\n          }));\n        }\n      }, {\n        key: \"anchorXSetter\",\n        value: function anchorXSetter(t, e) {\n          this.anchorX = t, this.boxAttr(e, Math.round(t) - this.getCrispAdjust() - this.xSetting);\n        }\n      }, {\n        key: \"anchorYSetter\",\n        value: function anchorYSetter(t, e) {\n          this.anchorY = t, this.boxAttr(e, t - this.ySetting);\n        }\n      }, {\n        key: \"boxAttr\",\n        value: function boxAttr(t, e) {\n          this.box ? this.box.attr(t, e) : this.deferredAttr[t] = e;\n        }\n      }, {\n        key: \"css\",\n        value: function css(e) {\n          if (e) {\n            var _t21 = {};\n            e = o(e), h.textProps.forEach(function (i) {\n              void 0 !== e[i] && (_t21[i] = e[i], delete e[i]);\n            }), this.text.css(_t21), \"fontSize\" in _t21 || \"fontWeight\" in _t21 ? this.updateTextPadding() : (\"width\" in _t21 || \"textOverflow\" in _t21) && this.updateBoxSize();\n          }\n          return t.prototype.css.call(this, e);\n        }\n      }, {\n        key: \"destroy\",\n        value: function destroy() {\n          a(this.element, \"mouseenter\"), a(this.element, \"mouseleave\"), this.text && this.text.destroy(), this.box && (this.box = this.box.destroy()), t.prototype.destroy.call(this);\n        }\n      }, {\n        key: \"fillSetter\",\n        value: function fillSetter(t, e) {\n          t && (this.needsBox = !0), this.fill = t, this.boxAttr(e, t);\n        }\n      }, {\n        key: \"getBBox\",\n        value: function getBBox(t, e) {\n          this.textStr && 0 === this.bBox.width && 0 === this.bBox.height && this.updateBoxSize();\n          var i = this.padding,\n            _this$height = this.height,\n            s = _this$height === void 0 ? 0 : _this$height,\n            _this$translateX2 = this.translateX,\n            r = _this$translateX2 === void 0 ? 0 : _this$translateX2,\n            _this$translateY2 = this.translateY,\n            o = _this$translateY2 === void 0 ? 0 : _this$translateY2,\n            _this$width = this.width,\n            a = _this$width === void 0 ? 0 : _this$width,\n            _h3 = n(this.paddingLeft, i),\n            l = e !== null && e !== void 0 ? e : this.rotation || 0,\n            d = {\n              width: a,\n              height: s,\n              x: r + this.bBox.x - _h3,\n              y: o + this.bBox.y - i + this.baselineOffset\n            };\n          return l && (d = this.getRotatedBox(d, l)), d;\n        }\n      }, {\n        key: \"getCrispAdjust\",\n        value: function getCrispAdjust() {\n          return (this.renderer.styledMode && this.box ? this.box.strokeWidth() : this[\"stroke-width\"] ? parseInt(this[\"stroke-width\"], 10) : 0) % 2 / 2;\n        }\n      }, {\n        key: \"heightSetter\",\n        value: function heightSetter(t) {\n          this.heightSetting = t, this.doUpdate = !0;\n        }\n      }, {\n        key: \"afterSetters\",\n        value: function afterSetters() {\n          _superPropGet(h, \"afterSetters\", this, 3)([]), this.doUpdate && (this.updateBoxSize(), this.doUpdate = !1);\n        }\n      }, {\n        key: \"onAdd\",\n        value: function onAdd() {\n          this.text.add(this), this.attr({\n            text: n(this.textStr, \"\"),\n            x: this.x || 0,\n            y: this.y || 0\n          }), this.box && i(this.anchorX) && this.attr({\n            anchorX: this.anchorX,\n            anchorY: this.anchorY\n          });\n        }\n      }, {\n        key: \"paddingSetter\",\n        value: function paddingSetter(t, e) {\n          r(t) ? t !== this[e] && (this[e] = t, this.updateTextPadding()) : this[e] = void 0;\n        }\n      }, {\n        key: \"rSetter\",\n        value: function rSetter(t, e) {\n          this.boxAttr(e, t);\n        }\n      }, {\n        key: \"strokeSetter\",\n        value: function strokeSetter(t, e) {\n          this.stroke = t, this.boxAttr(e, t);\n        }\n      }, {\n        key: \"stroke-widthSetter\",\n        value: function strokeWidthSetter(t, e) {\n          t && (this.needsBox = !0), this[\"stroke-width\"] = t, this.boxAttr(e, t);\n        }\n      }, {\n        key: \"text-alignSetter\",\n        value: function textAlignSetter(t) {\n          this.textAlign = t;\n        }\n      }, {\n        key: \"textSetter\",\n        value: function textSetter(t) {\n          void 0 !== t && this.text.attr({\n            text: t\n          }), this.updateTextPadding(), this.reAlign();\n        }\n      }, {\n        key: \"updateBoxSize\",\n        value: function updateBoxSize() {\n          var t;\n          var e = this.text,\n            o = {},\n            n = this.padding,\n            a = this.bBox = (!r(this.widthSetting) || !r(this.heightSetting) || this.textAlign) && i(e.textStr) ? e.getBBox(void 0, 0) : h.emptyBBox;\n          this.width = this.getPaddedWidth(), this.height = (this.heightSetting || a.height || 0) + 2 * n;\n          var l = this.renderer.fontMetrics(e);\n          if (this.baselineOffset = n + Math.min((this.text.firstLineMetrics || l).b, a.height || 1 / 0), this.heightSetting && (this.baselineOffset += (this.heightSetting - l.h) / 2), this.needsBox && !e.textPath) {\n            if (!this.box) {\n              var _t22 = this.box = this.symbolKey ? this.renderer.symbol(this.symbolKey) : this.renderer.rect();\n              _t22.addClass((\"button\" === this.className ? \"\" : \"highcharts-label-box\") + (this.className ? \" highcharts-\" + this.className + \"-box\" : \"\")), _t22.add(this);\n            }\n            t = this.getCrispAdjust(), o.x = t, o.y = (this.baseline ? -this.baselineOffset : 0) + t, o.width = Math.round(this.width), o.height = Math.round(this.height), this.box.attr(s(o, this.deferredAttr)), this.deferredAttr = {};\n          }\n        }\n      }, {\n        key: \"updateTextPadding\",\n        value: function updateTextPadding() {\n          var t = this.text;\n          if (!t.textPath) {\n            this.updateBoxSize();\n            var _e13 = this.baseline ? 0 : this.baselineOffset,\n              _s14 = n(this.paddingLeft, this.padding);\n            i(this.widthSetting) && this.bBox && (\"center\" === this.textAlign || \"right\" === this.textAlign) && (_s14 += {\n              center: .5,\n              right: 1\n            }[this.textAlign] * (this.widthSetting - this.bBox.width)), (_s14 !== t.x || _e13 !== t.y) && (t.attr(\"x\", _s14), t.hasBoxWidthChanged && (this.bBox = t.getBBox(!0)), void 0 !== _e13 && t.attr(\"y\", _e13)), t.x = _s14, t.y = _e13;\n          }\n        }\n      }, {\n        key: \"widthSetter\",\n        value: function widthSetter(t) {\n          this.widthSetting = r(t) ? t : void 0, this.doUpdate = !0;\n        }\n      }, {\n        key: \"getPaddedWidth\",\n        value: function getPaddedWidth() {\n          var t = this.padding,\n            e = n(this.paddingLeft, t),\n            i = n(this.paddingRight, t);\n          return (this.widthSetting || this.bBox.width || 0) + e + i;\n        }\n      }, {\n        key: \"xSetter\",\n        value: function xSetter(t) {\n          this.x = t, this.alignFactor && (t -= this.alignFactor * this.getPaddedWidth(), this[\"forceAnimate:x\"] = !0), this.xSetting = Math.round(t), this.attr(\"translateX\", this.xSetting);\n        }\n      }, {\n        key: \"ySetter\",\n        value: function ySetter(t) {\n          this.ySetting = this.y = Math.round(t), this.attr(\"translateY\", this.ySetting);\n        }\n      }]);\n    }(t);\n    return h.emptyBBox = {\n      width: 0,\n      height: 0,\n      x: 0,\n      y: 0\n    }, h.textProps = [\"color\", \"direction\", \"fontFamily\", \"fontSize\", \"fontStyle\", \"fontWeight\", \"lineHeight\", \"textAlign\", \"textDecoration\", \"textOutline\", \"textOverflow\", \"whiteSpace\", \"width\"], h;\n  }), i(e, \"Core/Renderer/SVG/Symbols.js\", [e[\"Core/Utilities.js\"]], function (t) {\n    var e = t.defined,\n      i = t.isNumber,\n      s = t.pick;\n    function r(t, i, r, o, n) {\n      var a = [];\n      if (n) {\n        var h = n.start || 0,\n          l = s(n.r, r),\n          d = s(n.r, o || r),\n          c = 2e-4 / (n.borderRadius ? 1 : Math.max(l, 1)),\n          _p2 = Math.abs((n.end || 0) - h - 2 * Math.PI) < c,\n          u = (n.end || 0) - (_p2 ? c : 0),\n          g = n.innerR,\n          f = s(n.open, _p2),\n          m = Math.cos(h),\n          x = Math.sin(h),\n          y = Math.cos(u),\n          b = Math.sin(u),\n          v = s(n.longArc, u - h - Math.PI < c ? 0 : 1),\n          S = [\"A\", l, d, 0, v, s(n.clockwise, 1), t + l * y, i + d * b];\n        S.params = {\n          start: h,\n          end: u,\n          cx: t,\n          cy: i\n        }, a.push([\"M\", t + l * m, i + d * x], S), e(g) && ((S = [\"A\", g, g, 0, v, e(n.clockwise) ? 1 - n.clockwise : 0, t + g * m, i + g * x]).params = {\n          start: u,\n          end: h,\n          cx: t,\n          cy: i\n        }, a.push(f ? [\"M\", t + g * y, i + g * b] : [\"L\", t + g * y, i + g * b], S)), f || a.push([\"Z\"]);\n      }\n      return a;\n    }\n    function o(t, e, i, s, r) {\n      return r && r.r ? n(t, e, i, s, r) : [[\"M\", t, e], [\"L\", t + i, e], [\"L\", t + i, e + s], [\"L\", t, e + s], [\"Z\"]];\n    }\n    function n(t, e, i, s, r) {\n      var o = (r === null || r === void 0 ? void 0 : r.r) || 0;\n      return [[\"M\", t + o, e], [\"L\", t + i - o, e], [\"A\", o, o, 0, 0, 1, t + i, e + o], [\"L\", t + i, e + s - o], [\"A\", o, o, 0, 0, 1, t + i - o, e + s], [\"L\", t + o, e + s], [\"A\", o, o, 0, 0, 1, t, e + s - o], [\"L\", t, e + o], [\"A\", o, o, 0, 0, 1, t + o, e], [\"Z\"]];\n    }\n    return {\n      arc: r,\n      callout: function callout(t, e, s, r, o) {\n        var a = Math.min(o && o.r || 0, s, r),\n          h = a + 6,\n          l = o && o.anchorX,\n          d = o && o.anchorY || 0,\n          c = n(t, e, s, r, {\n            r: a\n          });\n        if (!i(l) || l < s && l > 0 && d < r && d > 0) return c;\n        if (t + l > s - h) {\n          if (d > e + h && d < e + r - h) c.splice(3, 1, [\"L\", t + s, d - 6], [\"L\", t + s + 6, d], [\"L\", t + s, d + 6], [\"L\", t + s, e + r - a]);else if (l < s) {\n            var _i16 = d < e + h,\n              _o9 = _i16 ? e : e + r;\n            c.splice(_i16 ? 2 : 5, 0, [\"L\", l, d], [\"L\", t + s - a, _o9]);\n          } else c.splice(3, 1, [\"L\", t + s, r / 2], [\"L\", l, d], [\"L\", t + s, r / 2], [\"L\", t + s, e + r - a]);\n        } else if (t + l < h) {\n          if (d > e + h && d < e + r - h) c.splice(7, 1, [\"L\", t, d + 6], [\"L\", t - 6, d], [\"L\", t, d - 6], [\"L\", t, e + a]);else if (l > 0) {\n            var _i17 = d < e + h,\n              _s15 = _i17 ? e : e + r;\n            c.splice(_i17 ? 1 : 6, 0, [\"L\", l, d], [\"L\", t + a, _s15]);\n          } else c.splice(7, 1, [\"L\", t, r / 2], [\"L\", l, d], [\"L\", t, r / 2], [\"L\", t, e + a]);\n        } else d > r && l < s - h ? c.splice(5, 1, [\"L\", l + 6, e + r], [\"L\", l, e + r + 6], [\"L\", l - 6, e + r], [\"L\", t + a, e + r]) : d < 0 && l > h && c.splice(1, 1, [\"L\", l - 6, e], [\"L\", l, e - 6], [\"L\", l + 6, e], [\"L\", s - a, e]);\n        return c;\n      },\n      circle: function circle(t, e, i, s) {\n        return r(t + i / 2, e + s / 2, i / 2, s / 2, {\n          start: .5 * Math.PI,\n          end: 2.5 * Math.PI,\n          open: !1\n        });\n      },\n      diamond: function diamond(t, e, i, s) {\n        return [[\"M\", t + i / 2, e], [\"L\", t + i, e + s / 2], [\"L\", t + i / 2, e + s], [\"L\", t, e + s / 2], [\"Z\"]];\n      },\n      rect: o,\n      roundedRect: n,\n      square: o,\n      triangle: function triangle(t, e, i, s) {\n        return [[\"M\", t + i / 2, e], [\"L\", t + i, e + s], [\"L\", t, e + s], [\"Z\"]];\n      },\n      \"triangle-down\": function triangleDown(t, e, i, s) {\n        return [[\"M\", t, e], [\"L\", t + i, e], [\"L\", t + i / 2, e + s], [\"Z\"]];\n      }\n    };\n  }), i(e, \"Core/Renderer/SVG/TextBuilder.js\", [e[\"Core/Renderer/HTML/AST.js\"], e[\"Core/Globals.js\"], e[\"Core/Utilities.js\"]], function (t, e, i) {\n    var s = e.doc,\n      r = e.SVG_NS,\n      o = e.win,\n      n = i.attr,\n      a = i.extend,\n      h = i.fireEvent,\n      l = i.isString,\n      d = i.objectEach,\n      c = i.pick;\n    return /*#__PURE__*/function () {\n      function _class(t) {\n        _classCallCheck(this, _class);\n        var e = t.styles;\n        this.renderer = t.renderer, this.svgElement = t, this.width = t.textWidth, this.textLineHeight = e && e.lineHeight, this.textOutline = e && e.textOutline, this.ellipsis = !!(e && \"ellipsis\" === e.textOverflow), this.noWrap = !!(e && \"nowrap\" === e.whiteSpace);\n      }\n      return _createClass(_class, [{\n        key: \"buildSVG\",\n        value: function buildSVG() {\n          var e = this.svgElement,\n            i = e.element,\n            r = e.renderer,\n            o = c(e.textStr, \"\").toString(),\n            n = -1 !== o.indexOf(\"<\"),\n            a = i.childNodes,\n            h = !e.added && r.box,\n            d = [o, this.ellipsis, this.noWrap, this.textLineHeight, this.textOutline, e.getStyle(\"font-size\"), this.width].join(\",\");\n          if (d !== e.textCache) {\n            e.textCache = d, delete e.actualWidth;\n            for (var _t23 = a.length; _t23--;) i.removeChild(a[_t23]);\n            if (n || this.ellipsis || this.width || e.textPath || -1 !== o.indexOf(\" \") && (!this.noWrap || /<br.*?>/g.test(o))) {\n              if (\"\" !== o) {\n                h && h.appendChild(i);\n                var _s16 = new t(o);\n                this.modifyTree(_s16.nodes), _s16.addToDOM(i), this.modifyDOM(), this.ellipsis && -1 !== (i.textContent || \"\").indexOf(\"‚Ä¶\") && e.attr(\"title\", this.unescapeEntities(e.textStr || \"\", [\"&lt;\", \"&gt;\"])), h && h.removeChild(i);\n              }\n            } else i.appendChild(s.createTextNode(this.unescapeEntities(o)));\n            l(this.textOutline) && e.applyTextOutline && e.applyTextOutline(this.textOutline);\n          }\n        }\n      }, {\n        key: \"modifyDOM\",\n        value: function modifyDOM() {\n          var _this3 = this;\n          var t;\n          var e = this.svgElement,\n            i = n(e.element, \"x\");\n          for (e.firstLineMetrics = void 0; t = e.element.firstChild;) if (/^[\\s\\u200B]*$/.test(t.textContent || \" \")) e.element.removeChild(t);else break;\n          [].forEach.call(e.element.querySelectorAll(\"tspan.highcharts-br\"), function (t, s) {\n            t.nextSibling && t.previousSibling && (0 === s && 1 === t.previousSibling.nodeType && (e.firstLineMetrics = e.renderer.fontMetrics(t.previousSibling)), n(t, {\n              dy: _this3.getLineHeight(t.nextSibling),\n              x: i\n            }));\n          });\n          var a = this.width || 0;\n          if (!a) return;\n          var h = function h(t, o) {\n              var h = t.textContent || \"\",\n                l = h.replace(/([^\\^])-/g, \"$1- \").split(\" \"),\n                d = !_this3.noWrap && (l.length > 1 || e.element.childNodes.length > 1),\n                c = _this3.getLineHeight(o),\n                p = 0,\n                u = e.actualWidth;\n              if (_this3.ellipsis) h && _this3.truncate(t, h, void 0, 0, Math.max(0, a - .8 * c), function (t, e) {\n                return t.substring(0, e) + \"‚Ä¶\";\n              });else if (d) {\n                var _h4 = [],\n                  _d = [];\n                for (; o.firstChild && o.firstChild !== t;) _d.push(o.firstChild), o.removeChild(o.firstChild);\n                for (; l.length;) l.length && !_this3.noWrap && p > 0 && (_h4.push(t.textContent || \"\"), t.textContent = l.join(\" \").replace(/- /g, \"-\")), _this3.truncate(t, void 0, l, 0 === p && u || 0, a, function (t, e) {\n                  return l.slice(0, e).join(\" \").replace(/- /g, \"-\");\n                }), u = e.actualWidth, p++;\n                _d.forEach(function (e) {\n                  o.insertBefore(e, t);\n                }), _h4.forEach(function (e) {\n                  o.insertBefore(s.createTextNode(e), t);\n                  var a = s.createElementNS(r, \"tspan\");\n                  a.textContent = \"‚Äã\", n(a, {\n                    dy: c,\n                    x: i\n                  }), o.insertBefore(a, t);\n                });\n              }\n            },\n            _l4 = function l(t) {\n              [].slice.call(t.childNodes).forEach(function (i) {\n                i.nodeType === o.Node.TEXT_NODE ? h(i, t) : (-1 !== i.className.baseVal.indexOf(\"highcharts-br\") && (e.actualWidth = 0), _l4(i));\n              });\n            };\n          _l4(e.element);\n        }\n      }, {\n        key: \"getLineHeight\",\n        value: function getLineHeight(t) {\n          var e = t.nodeType === o.Node.TEXT_NODE ? t.parentElement : t;\n          return this.textLineHeight ? parseInt(this.textLineHeight.toString(), 10) : this.renderer.fontMetrics(e || this.svgElement.element).h;\n        }\n      }, {\n        key: \"modifyTree\",\n        value: function modifyTree(t) {\n          var _this4 = this;\n          var _e15 = function e(i, s) {\n            var _i$attributes = i.attributes,\n              r = _i$attributes === void 0 ? {} : _i$attributes,\n              o = i.children,\n              _i$style = i.style,\n              n = _i$style === void 0 ? {} : _i$style,\n              h = i.tagName,\n              l = _this4.renderer.styledMode;\n            if (\"b\" === h || \"strong\" === h ? l ? r[\"class\"] = \"highcharts-strong\" : n.fontWeight = \"bold\" : (\"i\" === h || \"em\" === h) && (l ? r[\"class\"] = \"highcharts-emphasized\" : n.fontStyle = \"italic\"), n && n.color && (n.fill = n.color), \"br\" === h) {\n              r[\"class\"] = \"highcharts-br\", i.textContent = \"‚Äã\";\n              var _e14 = t[s + 1];\n              _e14 && _e14.textContent && (_e14.textContent = _e14.textContent.replace(/^ +/gm, \"\"));\n            } else \"a\" === h && o && o.some(function (t) {\n              return \"#text\" === t.tagName;\n            }) && (i.children = [{\n              children: o,\n              tagName: \"tspan\"\n            }]);\n            \"#text\" !== h && \"a\" !== h && (i.tagName = \"tspan\"), a(i, {\n              attributes: r,\n              style: n\n            }), o && o.filter(function (t) {\n              return \"#text\" !== t.tagName;\n            }).forEach(_e15);\n          };\n          t.forEach(_e15), h(this.svgElement, \"afterModifyTree\", {\n            nodes: t\n          });\n        }\n      }, {\n        key: \"truncate\",\n        value: function truncate(t, e, i, s, r, o) {\n          var n, a;\n          var h = this.svgElement,\n            l = h.rotation,\n            d = [],\n            c = i ? 1 : 0,\n            p = (e || i || \"\").length,\n            u = p,\n            g = function g(e, r) {\n              var o = r || e,\n                n = t.parentNode;\n              if (n && void 0 === d[o] && n.getSubStringLength) try {\n                d[o] = s + n.getSubStringLength(0, i ? o + 1 : o);\n              } catch (t) {}\n              return d[o];\n            };\n          if (h.rotation = 0, s + (a = g(t.textContent.length)) > r) {\n            for (; c <= p;) u = Math.ceil((c + p) / 2), i && (n = o(i, u)), a = g(u, n && n.length - 1), c === p ? c = p + 1 : a > r ? p = u - 1 : c = u;\n            0 === p ? t.textContent = \"\" : e && p === e.length - 1 || (t.textContent = n || o(e || i, u));\n          }\n          i && i.splice(0, u), h.actualWidth = a, h.rotation = l;\n        }\n      }, {\n        key: \"unescapeEntities\",\n        value: function unescapeEntities(t, e) {\n          return d(this.renderer.escapes, function (i, s) {\n            e && -1 !== e.indexOf(i) || (t = t.toString().replace(RegExp(i, \"g\"), s));\n          }), t;\n        }\n      }]);\n    }();\n  }), i(e, \"Core/Renderer/SVG/SVGRenderer.js\", [e[\"Core/Renderer/HTML/AST.js\"], e[\"Core/Defaults.js\"], e[\"Core/Color/Color.js\"], e[\"Core/Globals.js\"], e[\"Core/Renderer/RendererRegistry.js\"], e[\"Core/Renderer/SVG/SVGElement.js\"], e[\"Core/Renderer/SVG/SVGLabel.js\"], e[\"Core/Renderer/SVG/Symbols.js\"], e[\"Core/Renderer/SVG/TextBuilder.js\"], e[\"Core/Utilities.js\"]], function (t, e, i, s, r, o, n, a, h, l) {\n    var d;\n    var c = e.defaultOptions,\n      p = s.charts,\n      u = s.deg2rad,\n      g = s.doc,\n      f = s.isFirefox,\n      m = s.isMS,\n      x = s.isWebKit,\n      y = s.noop,\n      b = s.SVG_NS,\n      v = s.symbolSizes,\n      S = s.win,\n      C = l.addEvent,\n      k = l.attr,\n      M = l.createElement,\n      w = l.crisp,\n      A = l.css,\n      T = l.defined,\n      P = l.destroyObjectProperties,\n      L = l.extend,\n      O = l.isArray,\n      D = l.isNumber,\n      E = l.isObject,\n      I = l.isString,\n      j = l.merge,\n      B = l.pick,\n      R = l.pInt,\n      z = l.replaceNested,\n      N = l.uniqueKey;\n    var W = /*#__PURE__*/function () {\n      function W(t, e, i, s, r, o, n) {\n        _classCallCheck(this, W);\n        var a, h;\n        var l = this.createElement(\"svg\").attr({\n            version: \"1.1\",\n            \"class\": \"highcharts-root\"\n          }),\n          d = l.element;\n        n || l.css(this.getStyle(s || {})), t.appendChild(d), k(t, \"dir\", \"ltr\"), -1 === t.innerHTML.indexOf(\"xmlns\") && k(d, \"xmlns\", this.SVG_NS), this.box = d, this.boxWrapper = l, this.alignedObjects = [], this.url = this.getReferenceURL(), this.createElement(\"desc\").add().element.appendChild(g.createTextNode(\"Created with Highcharts 11.4.7\")), this.defs = this.createElement(\"defs\").add(), this.allowHTML = o, this.forExport = r, this.styledMode = n, this.gradients = {}, this.cache = {}, this.cacheKeys = [], this.imgCount = 0, this.rootFontSize = l.getStyle(\"font-size\"), this.setSize(e, i, !1), f && t.getBoundingClientRect && ((a = function a() {\n          A(t, {\n            left: 0,\n            top: 0\n          }), h = t.getBoundingClientRect(), A(t, {\n            left: Math.ceil(h.left) - h.left + \"px\",\n            top: Math.ceil(h.top) - h.top + \"px\"\n          });\n        })(), this.unSubPixelFix = C(S, \"resize\", a));\n      }\n      return _createClass(W, [{\n        key: \"definition\",\n        value: function definition(e) {\n          return new t([e]).addToDOM(this.defs.element);\n        }\n      }, {\n        key: \"getReferenceURL\",\n        value: function getReferenceURL() {\n          if ((f || x) && g.getElementsByTagName(\"base\").length) {\n            if (!T(d)) {\n              var _e16 = N(),\n                _i18 = new t([{\n                  tagName: \"svg\",\n                  attributes: {\n                    width: 8,\n                    height: 8\n                  },\n                  children: [{\n                    tagName: \"defs\",\n                    children: [{\n                      tagName: \"clipPath\",\n                      attributes: {\n                        id: _e16\n                      },\n                      children: [{\n                        tagName: \"rect\",\n                        attributes: {\n                          width: 4,\n                          height: 4\n                        }\n                      }]\n                    }]\n                  }, {\n                    tagName: \"rect\",\n                    attributes: {\n                      id: \"hitme\",\n                      width: 8,\n                      height: 8,\n                      \"clip-path\": \"url(#\".concat(_e16, \")\"),\n                      fill: \"rgba(0,0,0,0.001)\"\n                    }\n                  }]\n                }]).addToDOM(g.body);\n              A(_i18, {\n                position: \"fixed\",\n                top: 0,\n                left: 0,\n                zIndex: 9e5\n              });\n              var _s17 = g.elementFromPoint(6, 6);\n              d = \"hitme\" === (_s17 && _s17.id), g.body.removeChild(_i18);\n            }\n            if (d) return z(S.location.href.split(\"#\")[0], [/<[^>]*>/g, \"\"], [/([\\('\\)])/g, \"\\\\$1\"], [/ /g, \"%20\"]);\n          }\n          return \"\";\n        }\n      }, {\n        key: \"getStyle\",\n        value: function getStyle(t) {\n          return this.style = L({\n            fontFamily: \"Helvetica, Arial, sans-serif\",\n            fontSize: \"1rem\"\n          }, t), this.style;\n        }\n      }, {\n        key: \"setStyle\",\n        value: function setStyle(t) {\n          this.boxWrapper.css(this.getStyle(t));\n        }\n      }, {\n        key: \"isHidden\",\n        value: function isHidden() {\n          return !this.boxWrapper.getBBox().width;\n        }\n      }, {\n        key: \"destroy\",\n        value: function destroy() {\n          var t = this.defs;\n          return this.box = null, this.boxWrapper = this.boxWrapper.destroy(), P(this.gradients || {}), this.gradients = null, this.defs = t.destroy(), this.unSubPixelFix && this.unSubPixelFix(), this.alignedObjects = null, null;\n        }\n      }, {\n        key: \"createElement\",\n        value: function createElement(t) {\n          return new this.Element(this, t);\n        }\n      }, {\n        key: \"getRadialAttr\",\n        value: function getRadialAttr(t, e) {\n          return {\n            cx: t[0] - t[2] / 2 + (e.cx || 0) * t[2],\n            cy: t[1] - t[2] / 2 + (e.cy || 0) * t[2],\n            r: (e.r || 0) * t[2]\n          };\n        }\n      }, {\n        key: \"shadowDefinition\",\n        value: function shadowDefinition(t) {\n          var e = [\"highcharts-drop-shadow-\".concat(this.chartIndex)].concat(_toConsumableArray(Object.keys(t).map(function (e) {\n              return \"\".concat(e, \"-\").concat(t[e]);\n            }))).join(\"-\").toLowerCase().replace(/[^a-z\\d\\-]/g, \"\"),\n            i = j({\n              color: \"#000000\",\n              offsetX: 1,\n              offsetY: 1,\n              opacity: .15,\n              width: 5\n            }, t);\n          return this.defs.element.querySelector(\"#\".concat(e)) || this.definition({\n            tagName: \"filter\",\n            attributes: {\n              id: e,\n              filterUnits: i.filterUnits\n            },\n            children: this.getShadowFilterContent(i)\n          }), e;\n        }\n      }, {\n        key: \"getShadowFilterContent\",\n        value: function getShadowFilterContent(t) {\n          return [{\n            tagName: \"feDropShadow\",\n            attributes: {\n              dx: t.offsetX,\n              dy: t.offsetY,\n              \"flood-color\": t.color,\n              \"flood-opacity\": Math.min(5 * t.opacity, 1),\n              stdDeviation: t.width / 2\n            }\n          }];\n        }\n      }, {\n        key: \"buildText\",\n        value: function buildText(t) {\n          new h(t).buildSVG();\n        }\n      }, {\n        key: \"getContrast\",\n        value: function getContrast(t) {\n          var e = i.parse(t).rgba.map(function (t) {\n              var e = t / 255;\n              return e <= .03928 ? e / 12.92 : Math.pow((e + .055) / 1.055, 2.4);\n            }),\n            s = .2126 * e[0] + .7152 * e[1] + .0722 * e[2];\n          return 1.05 / (s + .05) > (s + .05) / .05 ? \"#FFFFFF\" : \"#000000\";\n        }\n      }, {\n        key: \"button\",\n        value: function button(e, i, s, r) {\n          var o = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n          var n = arguments.length > 5 ? arguments[5] : undefined;\n          var a = arguments.length > 6 ? arguments[6] : undefined;\n          var h = arguments.length > 7 ? arguments[7] : undefined;\n          var l = arguments.length > 8 ? arguments[8] : undefined;\n          var d = arguments.length > 9 ? arguments[9] : undefined;\n          var p = this.label(e, i, s, l, void 0, void 0, d, void 0, \"button\"),\n            u = this.styledMode,\n            g = arguments,\n            f = 0;\n          o = j(c.global.buttonTheme, o), u && (delete o.fill, delete o.stroke, delete o[\"stroke-width\"]);\n          var x = o.states || {},\n            y = o.style || {};\n          delete o.states, delete o.style;\n          var b = [t.filterUserAttributes(o)],\n            v = [y];\n          return u || [\"hover\", \"select\", \"disabled\"].forEach(function (e, i) {\n            b.push(j(b[0], t.filterUserAttributes(g[i + 5] || x[e] || {}))), v.push(b[i + 1].style), delete b[i + 1].style;\n          }), C(p.element, m ? \"mouseover\" : \"mouseenter\", function () {\n            3 !== f && p.setState(1);\n          }), C(p.element, m ? \"mouseout\" : \"mouseleave\", function () {\n            3 !== f && p.setState(f);\n          }), p.setState = function () {\n            var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n            if (1 !== t && (p.state = f = t), p.removeClass(/highcharts-button-(normal|hover|pressed|disabled)/).addClass(\"highcharts-button-\" + [\"normal\", \"hover\", \"pressed\", \"disabled\"][t]), !u) {\n              p.attr(b[t]);\n              var _e17 = v[t];\n              E(_e17) && p.css(_e17);\n            }\n          }, p.attr(b[0]), !u && (p.css(L({\n            cursor: \"default\"\n          }, y)), d && p.text.css({\n            pointerEvents: \"none\"\n          })), p.on(\"touchstart\", function (t) {\n            return t.stopPropagation();\n          }).on(\"click\", function (t) {\n            3 !== f && r.call(p, t);\n          });\n        }\n      }, {\n        key: \"crispLine\",\n        value: function crispLine(t, e) {\n          var _t24 = _slicedToArray(t, 2),\n            i = _t24[0],\n            s = _t24[1];\n          return T(i[1]) && i[1] === s[1] && (i[1] = s[1] = w(i[1], e)), T(i[2]) && i[2] === s[2] && (i[2] = s[2] = w(i[2], e)), t;\n        }\n      }, {\n        key: \"path\",\n        value: function path(t) {\n          var e = this.styledMode ? {} : {\n            fill: \"none\"\n          };\n          return O(t) ? e.d = t : E(t) && L(e, t), this.createElement(\"path\").attr(e);\n        }\n      }, {\n        key: \"circle\",\n        value: function circle(t, e, i) {\n          var s = E(t) ? t : void 0 === t ? {} : {\n              x: t,\n              y: e,\n              r: i\n            },\n            r = this.createElement(\"circle\");\n          return r.xSetter = r.ySetter = function (t, e, i) {\n            i.setAttribute(\"c\" + e, t);\n          }, r.attr(s);\n        }\n      }, {\n        key: \"arc\",\n        value: function arc(t, e, i, s, r, o) {\n          var n;\n          E(t) ? (e = (n = t).y, i = n.r, s = n.innerR, r = n.start, o = n.end, t = n.x) : n = {\n            innerR: s,\n            start: r,\n            end: o\n          };\n          var a = this.symbol(\"arc\", t, e, i, i, n);\n          return a.r = i, a;\n        }\n      }, {\n        key: \"rect\",\n        value: function rect(t, e, i, s, r, o) {\n          var n = E(t) ? t : void 0 === t ? {} : {\n              x: t,\n              y: e,\n              r: r,\n              width: Math.max(i || 0, 0),\n              height: Math.max(s || 0, 0)\n            },\n            a = this.createElement(\"rect\");\n          return this.styledMode || (void 0 !== o && (n[\"stroke-width\"] = o, L(n, a.crisp(n))), n.fill = \"none\"), a.rSetter = function (t, e, i) {\n            a.r = t, k(i, {\n              rx: t,\n              ry: t\n            });\n          }, a.rGetter = function () {\n            return a.r || 0;\n          }, a.attr(n);\n        }\n      }, {\n        key: \"roundedRect\",\n        value: function roundedRect(t) {\n          return this.symbol(\"roundedRect\").attr(t);\n        }\n      }, {\n        key: \"setSize\",\n        value: function setSize(t, e, i) {\n          this.width = t, this.height = e, this.boxWrapper.animate({\n            width: t,\n            height: e\n          }, {\n            step: function step() {\n              this.attr({\n                viewBox: \"0 0 \" + this.attr(\"width\") + \" \" + this.attr(\"height\")\n              });\n            },\n            duration: B(i, !0) ? void 0 : 0\n          }), this.alignElements();\n        }\n      }, {\n        key: \"g\",\n        value: function g(t) {\n          var e = this.createElement(\"g\");\n          return t ? e.attr({\n            \"class\": \"highcharts-\" + t\n          }) : e;\n        }\n      }, {\n        key: \"image\",\n        value: function image(t, e, i, s, r, o) {\n          var n = {\n            preserveAspectRatio: \"none\"\n          };\n          D(e) && (n.x = e), D(i) && (n.y = i), D(s) && (n.width = s), D(r) && (n.height = r);\n          var a = this.createElement(\"image\").attr(n),\n            h = function h(e) {\n              a.attr({\n                href: t\n              }), o.call(a, e);\n            };\n          if (o) {\n            a.attr({\n              href: \"data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\"\n            });\n            var _e18 = new S.Image();\n            C(_e18, \"load\", h), _e18.src = t, _e18.complete && h({});\n          } else a.attr({\n            href: t\n          });\n          return a;\n        }\n      }, {\n        key: \"symbol\",\n        value: function symbol(t, e, i, s, r, o) {\n          var n, a, h, l;\n          var d = this,\n            c = /^url\\((.*?)\\)$/,\n            u = c.test(t),\n            f = !u && (this.symbols[t] ? t : \"circle\"),\n            m = f && this.symbols[f];\n          if (m) \"number\" == typeof e && (a = m.call(this.symbols, e || 0, i || 0, s || 0, r || 0, o)), n = this.path(a), d.styledMode || n.attr(\"fill\", \"none\"), L(n, {\n            symbolName: f || void 0,\n            x: e,\n            y: i,\n            width: s,\n            height: r\n          }), o && L(n, o);else if (u) {\n            h = t.match(c)[1];\n            var _s18 = n = this.image(h);\n            _s18.imgwidth = B(o && o.width, v[h] && v[h].width), _s18.imgheight = B(o && o.height, v[h] && v[h].height), l = function l(t) {\n              return t.attr({\n                width: t.width,\n                height: t.height\n              });\n            }, [\"width\", \"height\"].forEach(function (t) {\n              _s18[\"\".concat(t, \"Setter\")] = function (t, e) {\n                this[e] = t;\n                var i = this.alignByTranslate,\n                  s = this.element,\n                  r = this.width,\n                  n = this.height,\n                  a = this.imgwidth,\n                  h = this.imgheight,\n                  l = \"width\" === e ? a : h,\n                  d = 1;\n                o && \"within\" === o.backgroundSize && r && n && a && h ? (d = Math.min(r / a, n / h), k(s, {\n                  width: Math.round(a * d),\n                  height: Math.round(h * d)\n                })) : s && l && s.setAttribute(e, l), !i && a && h && this.translate(((r || 0) - a * d) / 2, ((n || 0) - h * d) / 2);\n              };\n            }), T(e) && _s18.attr({\n              x: e,\n              y: i\n            }), _s18.isImg = !0, T(_s18.imgwidth) && T(_s18.imgheight) ? l(_s18) : (_s18.attr({\n              width: 0,\n              height: 0\n            }), M(\"img\", {\n              onload: function onload() {\n                var t = p[d.chartIndex];\n                0 === this.width && (A(this, {\n                  position: \"absolute\",\n                  top: \"-999em\"\n                }), g.body.appendChild(this)), v[h] = {\n                  width: this.width,\n                  height: this.height\n                }, _s18.imgwidth = this.width, _s18.imgheight = this.height, _s18.element && l(_s18), this.parentNode && this.parentNode.removeChild(this), d.imgCount--, d.imgCount || !t || t.hasLoaded || t.onload();\n              },\n              src: h\n            }), this.imgCount++);\n          }\n          return n;\n        }\n      }, {\n        key: \"clipRect\",\n        value: function clipRect(t, e, i, s) {\n          return this.rect(t, e, i, s, 0);\n        }\n      }, {\n        key: \"text\",\n        value: function text(t, e, i, s) {\n          var r = {};\n          if (s && (this.allowHTML || !this.forExport)) return this.html(t, e, i);\n          r.x = Math.round(e || 0), i && (r.y = Math.round(i)), T(t) && (r.text = t);\n          var o = this.createElement(\"text\").attr(r);\n          return s && (!this.forExport || this.allowHTML) || (o.xSetter = function (t, e, i) {\n            var s = i.getElementsByTagName(\"tspan\"),\n              r = i.getAttribute(e);\n            for (var _i19 = 0, _o10; _i19 < s.length; _i19++) (_o10 = s[_i19]).getAttribute(e) === r && _o10.setAttribute(e, t);\n            i.setAttribute(e, t);\n          }), o;\n        }\n      }, {\n        key: \"fontMetrics\",\n        value: function fontMetrics(t) {\n          var e = R(o.prototype.getStyle.call(t, \"font-size\") || 0),\n            i = e < 24 ? e + 3 : Math.round(1.2 * e),\n            s = Math.round(.8 * i);\n          return {\n            h: i,\n            b: s,\n            f: e\n          };\n        }\n      }, {\n        key: \"rotCorr\",\n        value: function rotCorr(t, e, i) {\n          var s = t;\n          return e && i && (s = Math.max(s * Math.cos(e * u), 4)), {\n            x: -t / 3 * Math.sin(e * u),\n            y: s\n          };\n        }\n      }, {\n        key: \"pathToSegments\",\n        value: function pathToSegments(t) {\n          var e = [],\n            i = [],\n            s = {\n              A: 8,\n              C: 7,\n              H: 2,\n              L: 3,\n              M: 3,\n              Q: 5,\n              S: 5,\n              T: 3,\n              V: 2\n            };\n          for (var _r5 = 0; _r5 < t.length; _r5++) I(i[0]) && D(t[_r5]) && i.length === s[i[0].toUpperCase()] && t.splice(_r5, 0, i[0].replace(\"M\", \"L\").replace(\"m\", \"l\")), \"string\" == typeof t[_r5] && (i.length && e.push(i.slice(0)), i.length = 0), i.push(t[_r5]);\n          return e.push(i.slice(0)), e;\n        }\n      }, {\n        key: \"label\",\n        value: function label(t, e, i, s, r, o, a, h, l) {\n          return new n(this, t, e, i, s, r, o, a, h, l);\n        }\n      }, {\n        key: \"alignElements\",\n        value: function alignElements() {\n          this.alignedObjects.forEach(function (t) {\n            return t.align();\n          });\n        }\n      }]);\n    }();\n    return L(W.prototype, {\n      Element: o,\n      SVG_NS: b,\n      escapes: {\n        \"&\": \"&amp;\",\n        \"<\": \"&lt;\",\n        \">\": \"&gt;\",\n        \"'\": \"&#39;\",\n        '\"': \"&quot;\"\n      },\n      symbols: a,\n      draw: y\n    }), r.registerRendererType(\"svg\", W, !0), W;\n  }), i(e, \"Core/Renderer/HTML/HTMLElement.js\", [e[\"Core/Renderer/HTML/AST.js\"], e[\"Core/Globals.js\"], e[\"Core/Renderer/SVG/SVGElement.js\"], e[\"Core/Utilities.js\"]], function (t, e, i, s) {\n    var r = e.composed,\n      o = s.attr,\n      n = s.css,\n      a = s.createElement,\n      h = s.defined,\n      l = s.extend,\n      d = s.pInt,\n      c = s.pushUnique;\n    function p(t, e, s) {\n      var _this$div;\n      var r = ((_this$div = this.div) === null || _this$div === void 0 ? void 0 : _this$div.style) || s.style;\n      i.prototype[\"\".concat(e, \"Setter\")].call(this, t, e, s), r && (r[e] = t);\n    }\n    var u = function u(t, e) {\n      if (!t.div) {\n        var _t$parentGroup;\n        var _s19 = o(t.element, \"class\"),\n          _r6 = t.css,\n          _n4 = a(\"div\", _s19 ? {\n            className: _s19\n          } : void 0, _objectSpread(_objectSpread({\n            position: \"absolute\",\n            left: \"\".concat(t.translateX || 0, \"px\"),\n            top: \"\".concat(t.translateY || 0, \"px\")\n          }, t.styles), {}, {\n            display: t.display,\n            opacity: t.opacity,\n            visibility: t.visibility\n          }), ((_t$parentGroup = t.parentGroup) === null || _t$parentGroup === void 0 ? void 0 : _t$parentGroup.div) || e);\n        t.classSetter = function (t, e, i) {\n          i.setAttribute(\"class\", t), _n4.className = t;\n        }, t.translateXSetter = t.translateYSetter = function (e, i) {\n          t[i] = e, _n4.style[\"translateX\" === i ? \"left\" : \"top\"] = \"\".concat(e, \"px\"), t.doTransform = !0;\n        }, t.opacitySetter = t.visibilitySetter = p, t.css = function (e) {\n          return _r6.call(t, e), e.cursor && (_n4.style.cursor = e.cursor), e.pointerEvents && (_n4.style.pointerEvents = e.pointerEvents), t;\n        }, t.on = function () {\n          return i.prototype.on.apply({\n            element: _n4,\n            onEvents: t.onEvents\n          }, arguments), t;\n        }, t.div = _n4;\n      }\n      return t.div;\n    };\n    var g = /*#__PURE__*/function (_i20) {\n      function g(t, e) {\n        var _this5;\n        _classCallCheck(this, g);\n        _this5 = _callSuper(this, g, [t, e]), _this5.css(_objectSpread({\n          position: \"absolute\"\n        }, t.styledMode ? {} : {\n          fontFamily: t.style.fontFamily,\n          fontSize: t.style.fontSize\n        })), _this5.element.style.whiteSpace = \"nowrap\";\n        return _this5;\n      }\n      _inherits(g, _i20);\n      return _createClass(g, [{\n        key: \"getSpanCorrection\",\n        value: function getSpanCorrection(t, e, i) {\n          this.xCorr = -t * i, this.yCorr = -e;\n        }\n      }, {\n        key: \"css\",\n        value: function css(t) {\n          var e;\n          var i = this.element,\n            s = \"SPAN\" === i.tagName && t && \"width\" in t,\n            r = s && t.width;\n          return s && (delete t.width, this.textWidth = d(r) || void 0, e = !0), (t === null || t === void 0 ? void 0 : t.textOverflow) === \"ellipsis\" && (t.whiteSpace = \"nowrap\", t.overflow = \"hidden\"), l(this.styles, t), n(i, t), e && this.updateTransform(), this;\n        }\n      }, {\n        key: \"htmlGetBBox\",\n        value: function htmlGetBBox() {\n          var t = this.element;\n          return {\n            x: t.offsetLeft,\n            y: t.offsetTop,\n            width: t.offsetWidth,\n            height: t.offsetHeight\n          };\n        }\n      }, {\n        key: \"updateTransform\",\n        value: function updateTransform() {\n          if (!this.added) {\n            this.alignOnAdd = !0;\n            return;\n          }\n          var t = this.element,\n            e = this.renderer,\n            i = this.rotation,\n            s = this.rotationOriginX,\n            r = this.rotationOriginY,\n            o = this.styles,\n            _this$textAlign = this.textAlign,\n            a = _this$textAlign === void 0 ? \"left\" : _this$textAlign,\n            l = this.textWidth,\n            _this$translateX3 = this.translateX,\n            d = _this$translateX3 === void 0 ? 0 : _this$translateX3,\n            _this$translateY3 = this.translateY,\n            c = _this$translateY3 === void 0 ? 0 : _this$translateY3,\n            _this$x = this.x,\n            p = _this$x === void 0 ? 0 : _this$x,\n            _this$y = this.y,\n            u = _this$y === void 0 ? 0 : _this$y,\n            _g2 = {\n              left: 0,\n              center: .5,\n              right: 1\n            }[a],\n            f = o.whiteSpace;\n          if (n(t, {\n            marginLeft: \"\".concat(d, \"px\"),\n            marginTop: \"\".concat(c, \"px\")\n          }), \"SPAN\" === t.tagName) {\n            var _this$parentGroup2;\n            var _o11 = [i, a, t.innerHTML, l, this.textAlign].join(\",\"),\n              _d2 = -(((_this$parentGroup2 = this.parentGroup) === null || _this$parentGroup2 === void 0 ? void 0 : _this$parentGroup2.padding) * 1) || 0,\n              _c2,\n              m = !1;\n            if (l !== this.oldTextWidth) {\n              var _e19 = this.textPxLength ? this.textPxLength : (n(t, {\n                  width: \"\",\n                  whiteSpace: f || \"nowrap\"\n                }), t.offsetWidth),\n                _s20 = l || 0;\n              (_s20 > this.oldTextWidth || _e19 > _s20) && (/[ \\-]/.test(t.textContent || t.innerText) || \"ellipsis\" === t.style.textOverflow) && (n(t, {\n                width: _e19 > _s20 || i ? l + \"px\" : \"auto\",\n                display: \"block\",\n                whiteSpace: f || \"normal\"\n              }), this.oldTextWidth = l, m = !0);\n            }\n            this.hasBoxWidthChanged = m, _o11 !== this.cTT && (_c2 = e.fontMetrics(t).b, h(i) && (i !== (this.oldRotation || 0) || a !== this.oldAlign) && this.setSpanRotation(i, _d2, _d2), this.getSpanCorrection(!h(i) && this.textPxLength || t.offsetWidth, _c2, _g2));\n            var _this$xCorr = this.xCorr,\n              x = _this$xCorr === void 0 ? 0 : _this$xCorr,\n              _this$yCorr = this.yCorr,\n              y = _this$yCorr === void 0 ? 0 : _this$yCorr,\n              b = (s !== null && s !== void 0 ? s : p) - x - p - _d2,\n              v = (r !== null && r !== void 0 ? r : u) - y - u - _d2;\n            n(t, {\n              left: \"\".concat(p + x, \"px\"),\n              top: \"\".concat(u + y, \"px\"),\n              transformOrigin: \"\".concat(b, \"px \").concat(v, \"px\")\n            }), this.cTT = _o11, this.oldRotation = i, this.oldAlign = a;\n          }\n        }\n      }, {\n        key: \"setSpanRotation\",\n        value: function setSpanRotation(t, e, i) {\n          n(this.element, {\n            transform: \"rotate(\".concat(t, \"deg)\"),\n            transformOrigin: \"\".concat(e, \"% \").concat(i, \"px\")\n          });\n        }\n      }, {\n        key: \"add\",\n        value: function add(t) {\n          var e;\n          var i = this.renderer.box.parentNode,\n            s = [];\n          if (this.parentGroup = t, t && !(e = t.div)) {\n            var _r7 = t;\n            for (; _r7;) s.push(_r7), _r7 = _r7.parentGroup;\n            var _iterator2 = _createForOfIteratorHelper(s.reverse()),\n              _step2;\n            try {\n              for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n                var _t25 = _step2.value;\n                e = u(_t25, i);\n              }\n            } catch (err) {\n              _iterator2.e(err);\n            } finally {\n              _iterator2.f();\n            }\n          }\n          return (e || i).appendChild(this.element), this.added = !0, this.alignOnAdd && this.updateTransform(), this;\n        }\n      }, {\n        key: \"textSetter\",\n        value: function textSetter(e) {\n          e !== this.textStr && (delete this.bBox, delete this.oldTextWidth, t.setElementHTML(this.element, e !== null && e !== void 0 ? e : \"\"), this.textStr = e, this.doTransform = !0);\n        }\n      }, {\n        key: \"alignSetter\",\n        value: function alignSetter(t) {\n          this.alignValue = this.textAlign = t, this.doTransform = !0;\n        }\n      }, {\n        key: \"xSetter\",\n        value: function xSetter(t, e) {\n          this[e] = t, this.doTransform = !0;\n        }\n      }], [{\n        key: \"compose\",\n        value: function compose(t) {\n          c(r, this.compose) && (t.prototype.html = function (t, e, i) {\n            return new g(this, \"span\").attr({\n              text: t,\n              x: Math.round(e),\n              y: Math.round(i)\n            });\n          });\n        }\n      }]);\n    }(i);\n    var f = g.prototype;\n    return f.visibilitySetter = f.opacitySetter = p, f.ySetter = f.rotationSetter = f.rotationOriginXSetter = f.rotationOriginYSetter = f.xSetter, g;\n  }), i(e, \"Core/Axis/AxisDefaults.js\", [], function () {\n    var t, e;\n    return (e = t || (t = {})).xAxis = {\n      alignTicks: !0,\n      allowDecimals: void 0,\n      panningEnabled: !0,\n      zIndex: 2,\n      zoomEnabled: !0,\n      dateTimeLabelFormats: {\n        millisecond: {\n          main: \"%H:%M:%S.%L\",\n          range: !1\n        },\n        second: {\n          main: \"%H:%M:%S\",\n          range: !1\n        },\n        minute: {\n          main: \"%H:%M\",\n          range: !1\n        },\n        hour: {\n          main: \"%H:%M\",\n          range: !1\n        },\n        day: {\n          main: \"%e %b\"\n        },\n        week: {\n          main: \"%e %b\"\n        },\n        month: {\n          main: \"%b '%y\"\n        },\n        year: {\n          main: \"%Y\"\n        }\n      },\n      endOnTick: !1,\n      gridLineDashStyle: \"Solid\",\n      gridZIndex: 1,\n      labels: {\n        autoRotationLimit: 80,\n        distance: 15,\n        enabled: !0,\n        indentation: 10,\n        overflow: \"justify\",\n        reserveSpace: void 0,\n        rotation: void 0,\n        staggerLines: 0,\n        step: 0,\n        useHTML: !1,\n        zIndex: 7,\n        style: {\n          color: \"#333333\",\n          cursor: \"default\",\n          fontSize: \"0.8em\"\n        }\n      },\n      maxPadding: .01,\n      minorGridLineDashStyle: \"Solid\",\n      minorTickLength: 2,\n      minorTickPosition: \"outside\",\n      minorTicksPerMajor: 5,\n      minPadding: .01,\n      offset: void 0,\n      reversed: void 0,\n      reversedStacks: !1,\n      showEmpty: !0,\n      showFirstLabel: !0,\n      showLastLabel: !0,\n      startOfWeek: 1,\n      startOnTick: !1,\n      tickLength: 10,\n      tickPixelInterval: 100,\n      tickmarkPlacement: \"between\",\n      tickPosition: \"outside\",\n      title: {\n        align: \"middle\",\n        useHTML: !1,\n        x: 0,\n        y: 0,\n        style: {\n          color: \"#666666\",\n          fontSize: \"0.8em\"\n        }\n      },\n      type: \"linear\",\n      uniqueNames: !0,\n      visible: !0,\n      minorGridLineColor: \"#f2f2f2\",\n      minorGridLineWidth: 1,\n      minorTickColor: \"#999999\",\n      lineColor: \"#333333\",\n      lineWidth: 1,\n      gridLineColor: \"#e6e6e6\",\n      gridLineWidth: void 0,\n      tickColor: \"#333333\"\n    }, e.yAxis = {\n      reversedStacks: !0,\n      endOnTick: !0,\n      maxPadding: .05,\n      minPadding: .05,\n      tickPixelInterval: 72,\n      showLastLabel: !0,\n      labels: {\n        x: void 0\n      },\n      startOnTick: !0,\n      title: {\n        text: \"Values\"\n      },\n      stackLabels: {\n        animation: {},\n        allowOverlap: !1,\n        enabled: !1,\n        crop: !0,\n        overflow: \"justify\",\n        formatter: function formatter() {\n          var t = this.axis.chart.numberFormatter;\n          return t(this.total || 0, -1);\n        },\n        style: {\n          color: \"#000000\",\n          fontSize: \"0.7em\",\n          fontWeight: \"bold\",\n          textOutline: \"1px contrast\"\n        }\n      },\n      gridLineWidth: 1,\n      lineWidth: 0\n    }, t;\n  }), i(e, \"Core/Foundation.js\", [e[\"Core/Utilities.js\"]], function (t) {\n    var e;\n    var i = t.addEvent,\n      s = t.isFunction,\n      r = t.objectEach,\n      o = t.removeEvent;\n    return (e || (e = {})).registerEventOptions = function (t, e) {\n      t.eventOptions = t.eventOptions || {}, r(e.events, function (e, r) {\n        t.eventOptions[r] !== e && (t.eventOptions[r] && (o(t, r, t.eventOptions[r]), delete t.eventOptions[r]), s(e) && (t.eventOptions[r] = e, i(t, r, e, {\n          order: 0\n        })));\n      });\n    }, e;\n  }), i(e, \"Core/Axis/Tick.js\", [e[\"Core/Templating.js\"], e[\"Core/Globals.js\"], e[\"Core/Utilities.js\"]], function (t, e, i) {\n    var s = e.deg2rad,\n      r = i.clamp,\n      o = i.correctFloat,\n      n = i.defined,\n      a = i.destroyObjectProperties,\n      h = i.extend,\n      l = i.fireEvent,\n      d = i.isNumber,\n      c = i.merge,\n      p = i.objectEach,\n      u = i.pick;\n    return /*#__PURE__*/function () {\n      function _class2(t, e, i, s, r) {\n        _classCallCheck(this, _class2);\n        this.isNew = !0, this.isNewLabel = !0, this.axis = t, this.pos = e, this.type = i || \"\", this.parameters = r || {}, this.tickmarkOffset = this.parameters.tickmarkOffset, this.options = this.parameters.options, l(this, \"init\"), i || s || this.addLabel();\n      }\n      return _createClass(_class2, [{\n        key: \"addLabel\",\n        value: function addLabel() {\n          var e = this,\n            i = e.axis,\n            s = i.options,\n            r = i.chart,\n            a = i.categories,\n            c = i.logarithmic,\n            p = i.names,\n            g = e.pos,\n            f = u(e.options && e.options.labels, s.labels),\n            m = i.tickPositions,\n            x = g === m[0],\n            y = g === m[m.length - 1],\n            b = (!f.step || 1 === f.step) && 1 === i.tickInterval,\n            v = m.info,\n            S = e.label,\n            C,\n            k,\n            M,\n            w = this.parameters.category || (a ? u(a[g], p[g], g) : g);\n          c && d(w) && (w = o(c.lin2log(w))), i.dateTime && (v ? C = (k = r.time.resolveDTLFormat(s.dateTimeLabelFormats[!s.grid && v.higherRanks[g] || v.unitName])).main : d(w) && (C = i.dateTime.getXDateFormat(w, s.dateTimeLabelFormats || {}))), e.isFirst = x, e.isLast = y;\n          var A = {\n            axis: i,\n            chart: r,\n            dateTimeLabelFormat: C,\n            isFirst: x,\n            isLast: y,\n            pos: g,\n            tick: e,\n            tickPositionInfo: v,\n            value: w\n          };\n          l(this, \"labelFormat\", A);\n          var T = function T(e) {\n              return f.formatter ? f.formatter.call(e, e) : f.format ? (e.text = i.defaultLabelFormatter.call(e), t.format(f.format, e, r)) : i.defaultLabelFormatter.call(e);\n            },\n            P = T.call(A, A),\n            L = k && k.list;\n          L ? e.shortenLabel = function () {\n            for (M = 0; M < L.length; M++) if (h(A, {\n              dateTimeLabelFormat: L[M]\n            }), S.attr({\n              text: T.call(A, A)\n            }), S.getBBox().width < i.getSlotWidth(e) - 2 * (f.padding || 0)) return;\n            S.attr({\n              text: \"\"\n            });\n          } : e.shortenLabel = void 0, b && i._addedPlotLB && e.moveLabel(P, f), n(S) || e.movedLabel ? S && S.textStr !== P && !b && (!S.textWidth || f.style.width || S.styles.width || S.css({\n            width: null\n          }), S.attr({\n            text: P\n          }), S.textPxLength = S.getBBox().width) : (e.label = S = e.createLabel(P, f), e.rotation = 0);\n        }\n      }, {\n        key: \"createLabel\",\n        value: function createLabel(t, e, i) {\n          var s = this.axis,\n            r = s.chart,\n            o = n(t) && e.enabled ? r.renderer.text(t, i === null || i === void 0 ? void 0 : i.x, i === null || i === void 0 ? void 0 : i.y, e.useHTML).add(s.labelGroup) : void 0;\n          return o && (r.styledMode || o.css(c(e.style)), o.textPxLength = o.getBBox().width), o;\n        }\n      }, {\n        key: \"destroy\",\n        value: function destroy() {\n          a(this, this.axis);\n        }\n      }, {\n        key: \"getPosition\",\n        value: function getPosition(t, e, i, s) {\n          var n = this.axis,\n            a = n.chart,\n            h = s && a.oldChartHeight || a.chartHeight,\n            d = {\n              x: t ? o(n.translate(e + i, void 0, void 0, s) + n.transB) : n.left + n.offset + (n.opposite ? (s && a.oldChartWidth || a.chartWidth) - n.right - n.left : 0),\n              y: t ? h - n.bottom + n.offset - (n.opposite ? n.height : 0) : o(h - n.translate(e + i, void 0, void 0, s) - n.transB)\n            };\n          return d.y = r(d.y, -1e5, 1e5), l(this, \"afterGetPosition\", {\n            pos: d\n          }), d;\n        }\n      }, {\n        key: \"getLabelPosition\",\n        value: function getLabelPosition(t, e, i, r, o, a, h, d) {\n          var c, p;\n          var g = this.axis,\n            f = g.transA,\n            m = g.isLinked && g.linkedParent ? g.linkedParent.reversed : g.reversed,\n            x = g.staggerLines,\n            y = g.tickRotCorr || {\n              x: 0,\n              y: 0\n            },\n            b = r || g.reserveSpaceDefault ? 0 : -g.labelOffset * (\"center\" === g.labelAlign ? .5 : 1),\n            v = o.distance,\n            S = {};\n          return c = 0 === g.side ? i.rotation ? -v : -i.getBBox().height : 2 === g.side ? y.y + v : Math.cos(i.rotation * s) * (y.y - i.getBBox(!1, 0).height / 2), n(o.y) && (c = 0 === g.side && g.horiz ? o.y + c : o.y), t = t + u(o.x, [0, 1, 0, -1][g.side] * v) + b + y.x - (a && r ? a * f * (m ? -1 : 1) : 0), e = e + c - (a && !r ? a * f * (m ? 1 : -1) : 0), x && (p = h / (d || 1) % x, g.opposite && (p = x - p - 1), e += p * (g.labelOffset / x)), S.x = t, S.y = Math.round(e), l(this, \"afterGetLabelPosition\", {\n            pos: S,\n            tickmarkOffset: a,\n            index: h\n          }), S;\n        }\n      }, {\n        key: \"getLabelSize\",\n        value: function getLabelSize() {\n          return this.label ? this.label.getBBox()[this.axis.horiz ? \"height\" : \"width\"] : 0;\n        }\n      }, {\n        key: \"getMarkPath\",\n        value: function getMarkPath(t, e, i, s) {\n          var r = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : !1;\n          var o = arguments.length > 5 ? arguments[5] : undefined;\n          return o.crispLine([[\"M\", t, e], [\"L\", t + (r ? 0 : -i), e + (r ? i : 0)]], s);\n        }\n      }, {\n        key: \"handleOverflow\",\n        value: function handleOverflow(t) {\n          var e = this.axis,\n            i = e.options.labels,\n            r = t.x,\n            o = e.chart.chartWidth,\n            n = e.chart.spacing,\n            a = u(e.labelLeft, Math.min(e.pos, n[3])),\n            h = u(e.labelRight, Math.max(e.isRadial ? 0 : e.pos + e.len, o - n[1])),\n            l = this.label,\n            d = this.rotation,\n            c = {\n              left: 0,\n              center: .5,\n              right: 1\n            }[e.labelAlign || l.attr(\"align\")],\n            p = l.getBBox().width,\n            g = e.getSlotWidth(this),\n            f = {},\n            m = g,\n            x = 1,\n            y,\n            b,\n            v;\n          d || \"justify\" !== i.overflow ? d < 0 && r - c * p < a ? v = Math.round(r / Math.cos(d * s) - a) : d > 0 && r + c * p > h && (v = Math.round((o - r) / Math.cos(d * s))) : (y = r - c * p, b = r + (1 - c) * p, y < a ? m = t.x + m * (1 - c) - a : b > h && (m = h - t.x + m * c, x = -1), (m = Math.min(g, m)) < g && \"center\" === e.labelAlign && (t.x += x * (g - m - c * (g - Math.min(p, m)))), (p > m || e.autoRotation && (l.styles || {}).width) && (v = m)), v && (this.shortenLabel ? this.shortenLabel() : (f.width = Math.floor(v) + \"px\", (i.style || {}).textOverflow || (f.textOverflow = \"ellipsis\"), l.css(f)));\n        }\n      }, {\n        key: \"moveLabel\",\n        value: function moveLabel(t, e) {\n          var i = this,\n            s = i.label,\n            r = i.axis,\n            o = !1,\n            n;\n          s && s.textStr === t ? (i.movedLabel = s, o = !0, delete i.label) : p(r.ticks, function (e) {\n            o || e.isNew || e === i || !e.label || e.label.textStr !== t || (i.movedLabel = e.label, o = !0, e.labelPos = i.movedLabel.xy, delete e.label);\n          }), !o && (i.labelPos || s) && (n = i.labelPos || s.xy, i.movedLabel = i.createLabel(t, e, n), i.movedLabel && i.movedLabel.attr({\n            opacity: 0\n          }));\n        }\n      }, {\n        key: \"render\",\n        value: function render(t, e, i) {\n          var s = this.axis,\n            r = s.horiz,\n            n = this.pos,\n            a = u(this.tickmarkOffset, s.tickmarkOffset),\n            h = this.getPosition(r, n, a, e),\n            d = h.x,\n            c = h.y,\n            p = s.pos,\n            g = p + s.len,\n            f = r ? d : c;\n          !s.chart.polar && this.isNew && (o(f) < p || f > g) && (i = 0);\n          var m = u(i, this.label && this.label.newOpacity, 1);\n          i = u(i, 1), this.isActive = !0, this.renderGridLine(e, i), this.renderMark(h, i), this.renderLabel(h, e, m, t), this.isNew = !1, l(this, \"afterRender\");\n        }\n      }, {\n        key: \"renderGridLine\",\n        value: function renderGridLine(t, e) {\n          var i = this.axis,\n            s = i.options,\n            r = {},\n            o = this.pos,\n            n = this.type,\n            a = u(this.tickmarkOffset, i.tickmarkOffset),\n            h = i.chart.renderer,\n            l = this.gridLine,\n            d,\n            c = s.gridLineWidth,\n            p = s.gridLineColor,\n            g = s.gridLineDashStyle;\n          \"minor\" === this.type && (c = s.minorGridLineWidth, p = s.minorGridLineColor, g = s.minorGridLineDashStyle), l || (i.chart.styledMode || (r.stroke = p, r[\"stroke-width\"] = c || 0, r.dashstyle = g), n || (r.zIndex = 1), t && (e = 0), this.gridLine = l = h.path().attr(r).addClass(\"highcharts-\" + (n ? n + \"-\" : \"\") + \"grid-line\").add(i.gridGroup)), l && (d = i.getPlotLinePath({\n            value: o + a,\n            lineWidth: l.strokeWidth(),\n            force: \"pass\",\n            old: t,\n            acrossPanes: !1\n          })) && l[t || this.isNew ? \"attr\" : \"animate\"]({\n            d: d,\n            opacity: e\n          });\n        }\n      }, {\n        key: \"renderMark\",\n        value: function renderMark(t, e) {\n          var i = this.axis,\n            s = i.options,\n            r = i.chart.renderer,\n            o = this.type,\n            n = i.tickSize(o ? o + \"Tick\" : \"tick\"),\n            a = t.x,\n            h = t.y,\n            l = u(s[\"minor\" !== o ? \"tickWidth\" : \"minorTickWidth\"], !o && i.isXAxis ? 1 : 0),\n            d = s[\"minor\" !== o ? \"tickColor\" : \"minorTickColor\"],\n            c = this.mark,\n            p = !c;\n          n && (i.opposite && (n[0] = -n[0]), c || (this.mark = c = r.path().addClass(\"highcharts-\" + (o ? o + \"-\" : \"\") + \"tick\").add(i.axisGroup), i.chart.styledMode || c.attr({\n            stroke: d,\n            \"stroke-width\": l\n          })), c[p ? \"attr\" : \"animate\"]({\n            d: this.getMarkPath(a, h, n[0], c.strokeWidth(), i.horiz, r),\n            opacity: e\n          }));\n        }\n      }, {\n        key: \"renderLabel\",\n        value: function renderLabel(t, e, i, s) {\n          var r = this.axis,\n            o = r.horiz,\n            n = r.options,\n            a = this.label,\n            h = n.labels,\n            l = h.step,\n            c = u(this.tickmarkOffset, r.tickmarkOffset),\n            p = t.x,\n            g = t.y,\n            f = !0;\n          a && d(p) && (a.xy = t = this.getLabelPosition(p, g, a, o, h, c, s, l), (!this.isFirst || this.isLast || n.showFirstLabel) && (!this.isLast || this.isFirst || n.showLastLabel) ? !o || h.step || h.rotation || e || 0 === i || this.handleOverflow(t) : f = !1, l && s % l && (f = !1), f && d(t.y) ? (t.opacity = i, a[this.isNewLabel ? \"attr\" : \"animate\"](t).show(!0), this.isNewLabel = !1) : (a.hide(), this.isNewLabel = !0));\n        }\n      }, {\n        key: \"replaceMovedLabel\",\n        value: function replaceMovedLabel() {\n          var t = this.label,\n            e = this.axis;\n          t && !this.isNew && (t.animate({\n            opacity: 0\n          }, void 0, t.destroy), delete this.label), e.isDirty = !0, this.label = this.movedLabel, delete this.movedLabel;\n        }\n      }]);\n    }();\n  }), i(e, \"Core/Axis/Axis.js\", [e[\"Core/Animation/AnimationUtilities.js\"], e[\"Core/Axis/AxisDefaults.js\"], e[\"Core/Color/Color.js\"], e[\"Core/Defaults.js\"], e[\"Core/Foundation.js\"], e[\"Core/Globals.js\"], e[\"Core/Axis/Tick.js\"], e[\"Core/Utilities.js\"]], function (t, e, i, s, r, o, n, a) {\n    var h = t.animObject,\n      l = e.xAxis,\n      d = e.yAxis,\n      c = s.defaultOptions,\n      p = r.registerEventOptions,\n      u = o.deg2rad,\n      g = a.arrayMax,\n      f = a.arrayMin,\n      m = a.clamp,\n      x = a.correctFloat,\n      y = a.defined,\n      b = a.destroyObjectProperties,\n      v = a.erase,\n      S = a.error,\n      C = a.extend,\n      k = a.fireEvent,\n      M = a.getClosestDistance,\n      w = a.insertItem,\n      A = a.isArray,\n      T = a.isNumber,\n      P = a.isString,\n      L = a.merge,\n      O = a.normalizeTickInterval,\n      D = a.objectEach,\n      E = a.pick,\n      I = a.relativeLength,\n      j = a.removeEvent,\n      B = a.splat,\n      R = a.syncTimeout,\n      z = function z(t, e) {\n        return O(e, void 0, void 0, E(t.options.allowDecimals, e < .5 || void 0 !== t.tickAmount), !!t.tickAmount);\n      };\n    C(c, {\n      xAxis: l,\n      yAxis: L(l, d)\n    });\n    var N = /*#__PURE__*/function () {\n      function N(t, e, i) {\n        _classCallCheck(this, N);\n        this.init(t, e, i);\n      }\n      return _createClass(N, [{\n        key: \"init\",\n        value: function init(t, e) {\n          var _this$len;\n          var i = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.coll;\n          var s = \"xAxis\" === i,\n            r = this.isZAxis || (t.inverted ? !s : s);\n          this.chart = t, this.horiz = r, this.isXAxis = s, this.coll = i, k(this, \"init\", {\n            userOptions: e\n          }), this.opposite = E(e.opposite, this.opposite), this.side = E(e.side, this.side, r ? this.opposite ? 0 : 2 : this.opposite ? 1 : 3), this.setOptions(e);\n          var o = this.options,\n            n = o.labels,\n            a = o.type;\n          this.userOptions = e, this.minPixelPadding = 0, this.reversed = E(o.reversed, this.reversed), this.visible = o.visible, this.zoomEnabled = o.zoomEnabled, this.hasNames = \"category\" === a || !0 === o.categories, this.categories = A(o.categories) && o.categories || (this.hasNames ? [] : void 0), this.names || (this.names = [], this.names.keys = {}), this.plotLinesAndBandsGroups = {}, this.positiveValuesOnly = !!this.logarithmic, this.isLinked = y(o.linkedTo), this.ticks = {}, this.labelEdge = [], this.minorTicks = {}, this.plotLinesAndBands = [], this.alternateBands = {}, (_this$len = this.len) !== null && _this$len !== void 0 ? _this$len : this.len = 0, this.minRange = this.userMinRange = o.minRange || o.maxZoom, this.range = o.range, this.offset = o.offset || 0, this.max = void 0, this.min = void 0;\n          var h = E(o.crosshair, B(t.options.tooltip.crosshairs)[s ? 0 : 1]);\n          this.crosshair = !0 === h ? {} : h, -1 === t.axes.indexOf(this) && (s ? t.axes.splice(t.xAxis.length, 0, this) : t.axes.push(this), w(this, t[this.coll])), t.orderItems(this.coll), this.series = this.series || [], t.inverted && !this.isZAxis && s && !y(this.reversed) && (this.reversed = !0), this.labelRotation = T(n.rotation) ? n.rotation : void 0, p(this, o), k(this, \"afterInit\");\n        }\n      }, {\n        key: \"setOptions\",\n        value: function setOptions(t) {\n          var e = this.horiz ? {\n            labels: {\n              autoRotation: [-45],\n              padding: 4\n            },\n            margin: 15\n          } : {\n            labels: {\n              padding: 1\n            },\n            title: {\n              rotation: 90 * this.side\n            }\n          };\n          this.options = L(e, c[this.coll], t), k(this, \"afterSetOptions\", {\n            userOptions: t\n          });\n        }\n      }, {\n        key: \"defaultLabelFormatter\",\n        value: function defaultLabelFormatter() {\n          var t = this.axis,\n            e = this.chart.numberFormatter,\n            i = T(this.value) ? this.value : NaN,\n            s = t.chart.time,\n            r = t.categories,\n            o = this.dateTimeLabelFormat,\n            n = c.lang,\n            a = n.numericSymbols,\n            h = n.numericSymbolMagnitude || 1e3,\n            l = t.logarithmic ? Math.abs(i) : t.tickInterval,\n            d = a && a.length,\n            p,\n            u;\n          if (r) u = \"\".concat(this.value);else if (o) u = s.dateFormat(o, i);else if (d && a && l >= 1e3) for (; d-- && void 0 === u;) l >= (p = Math.pow(h, d + 1)) && 10 * i % p == 0 && null !== a[d] && 0 !== i && (u = e(i / p, -1) + a[d]);\n          return void 0 === u && (u = Math.abs(i) >= 1e4 ? e(i, -1) : e(i, -1, void 0, \"\")), u;\n        }\n      }, {\n        key: \"getSeriesExtremes\",\n        value: function getSeriesExtremes() {\n          var t;\n          var e = this;\n          k(this, \"getSeriesExtremes\", null, function () {\n            e.hasVisibleSeries = !1, e.dataMin = e.dataMax = e.threshold = void 0, e.softThreshold = !e.isXAxis, e.series.forEach(function (i) {\n              if (i.reserveSpace()) {\n                var _s21 = i.options,\n                  _r8,\n                  _o12 = _s21.threshold,\n                  _n5,\n                  _a6;\n                if (e.hasVisibleSeries = !0, e.positiveValuesOnly && 0 >= (_o12 || 0) && (_o12 = void 0), e.isXAxis) (_r8 = i.xData) && _r8.length && (_r8 = e.logarithmic ? _r8.filter(function (t) {\n                  return t > 0;\n                }) : _r8, _n5 = (t = i.getXExtremes(_r8)).min, _a6 = t.max, T(_n5) || _n5 instanceof Date || (_r8 = _r8.filter(T), _n5 = (t = i.getXExtremes(_r8)).min, _a6 = t.max), _r8.length && (e.dataMin = Math.min(E(e.dataMin, _n5), _n5), e.dataMax = Math.max(E(e.dataMax, _a6), _a6)));else {\n                  var _t26 = i.applyExtremes();\n                  T(_t26.dataMin) && (_n5 = _t26.dataMin, e.dataMin = Math.min(E(e.dataMin, _n5), _n5)), T(_t26.dataMax) && (_a6 = _t26.dataMax, e.dataMax = Math.max(E(e.dataMax, _a6), _a6)), y(_o12) && (e.threshold = _o12), (!_s21.softThreshold || e.positiveValuesOnly) && (e.softThreshold = !1);\n                }\n              }\n            });\n          }), k(this, \"afterGetSeriesExtremes\");\n        }\n      }, {\n        key: \"translate\",\n        value: function translate(t, e, i, s, r, o) {\n          var _n$brokenAxis;\n          var n = this.linkedParent || this,\n            a = s && n.old ? n.old.min : n.min;\n          if (!T(a)) return NaN;\n          var h = n.minPixelPadding,\n            l = (n.isOrdinal || ((_n$brokenAxis = n.brokenAxis) === null || _n$brokenAxis === void 0 ? void 0 : _n$brokenAxis.hasBreaks) || n.logarithmic && r) && n.lin2val,\n            d = 1,\n            c = 0,\n            p = s && n.old ? n.old.transA : n.transA,\n            u = 0;\n          return p || (p = n.transA), i && (d *= -1, c = n.len), n.reversed && (d *= -1, c -= d * (n.sector || n.len)), e ? (u = (t = t * d + c - h) / p + a, l && (u = n.lin2val(u))) : (l && (t = n.val2lin(t)), u = d * (t - a) * p + c + d * h + (T(o) ? p * o : 0), n.isRadial || (u = x(u))), u;\n        }\n      }, {\n        key: \"toPixels\",\n        value: function toPixels(t, e) {\n          return this.translate(t, !1, !this.horiz, void 0, !0) + (e ? 0 : this.pos);\n        }\n      }, {\n        key: \"toValue\",\n        value: function toValue(t, e) {\n          return this.translate(t - (e ? 0 : this.pos), !0, !this.horiz, void 0, !0);\n        }\n      }, {\n        key: \"getPlotLinePath\",\n        value: function getPlotLinePath(t) {\n          var e = this,\n            i = e.chart,\n            s = e.left,\n            r = e.top,\n            o = t.old,\n            n = t.value,\n            a = t.lineWidth,\n            h = o && i.oldChartHeight || i.chartHeight,\n            l = o && i.oldChartWidth || i.chartWidth,\n            d = e.transB,\n            c = t.translatedValue,\n            p = t.force,\n            u,\n            g,\n            f,\n            x,\n            y;\n          function b(t, e, i) {\n            return \"pass\" !== p && (t < e || t > i) && (p ? t = m(t, e, i) : y = !0), t;\n          }\n          var v = {\n            value: n,\n            lineWidth: a,\n            old: o,\n            force: p,\n            acrossPanes: t.acrossPanes,\n            translatedValue: c\n          };\n          return k(this, \"getPlotLinePath\", v, function (t) {\n            u = f = (c = m(c = E(c, e.translate(n, void 0, void 0, o)), -1e5, 1e5)) + d, g = x = h - c - d, T(c) ? e.horiz ? (g = r, x = h - e.bottom + (e.options.isInternal ? 0 : i.scrollablePixelsY || 0), u = f = b(u, s, s + e.width)) : (u = s, f = l - e.right + (i.scrollablePixelsX || 0), g = x = b(g, r, r + e.height)) : (y = !0, p = !1), t.path = y && !p ? void 0 : i.renderer.crispLine([[\"M\", u, g], [\"L\", f, x]], a || 1);\n          }), v.path;\n        }\n      }, {\n        key: \"getLinearTickPositions\",\n        value: function getLinearTickPositions(t, e, i) {\n          var s, r, o;\n          var n = x(Math.floor(e / t) * t),\n            a = x(Math.ceil(i / t) * t),\n            h = [];\n          if (x(n + t) === n && (o = 20), this.single) return [e];\n          for (s = n; s <= a && (h.push(s), (s = x(s + t, o)) !== r);) r = s;\n          return h;\n        }\n      }, {\n        key: \"getMinorTickInterval\",\n        value: function getMinorTickInterval() {\n          var _this$options = this.options,\n            t = _this$options.minorTicks,\n            e = _this$options.minorTickInterval;\n          return !0 === t ? E(e, \"auto\") : !1 !== t ? e : void 0;\n        }\n      }, {\n        key: \"getMinorTickPositions\",\n        value: function getMinorTickPositions() {\n          var t = this.options,\n            e = this.tickPositions,\n            i = this.minorTickInterval,\n            s = this.pointRangePadding || 0,\n            r = (this.min || 0) - s,\n            o = (this.max || 0) + s,\n            n = o - r,\n            a = [],\n            h;\n          if (n && n / i < this.len / 3) {\n            var _s22 = this.logarithmic;\n            if (_s22) this.paddedTicks.forEach(function (t, e, r) {\n              e && a.push.apply(a, _s22.getLogTickPositions(i, r[e - 1], r[e], !0));\n            });else if (this.dateTime && \"auto\" === this.getMinorTickInterval()) a = a.concat(this.getTimeTicks(this.dateTime.normalizeTimeTickInterval(i), r, o, t.startOfWeek));else for (h = r + (e[0] - r) % i; h <= o && h !== a[0]; h += i) a.push(h);\n          }\n          return 0 !== a.length && this.trimTicks(a), a;\n        }\n      }, {\n        key: \"adjustForMinRange\",\n        value: function adjustForMinRange() {\n          var t = this.options,\n            e = this.logarithmic,\n            i = this.max,\n            s = this.min,\n            r = this.minRange,\n            o,\n            n,\n            a,\n            h;\n          this.isXAxis && void 0 === r && !e && (r = y(t.min) || y(t.max) || y(t.floor) || y(t.ceiling) ? null : Math.min(5 * (M(this.series.map(function (t) {\n            var _t$xData;\n            return (t.xIncrement ? (_t$xData = t.xData) === null || _t$xData === void 0 ? void 0 : _t$xData.slice(0, 2) : t.xData) || [];\n          })) || 0), this.dataMax - this.dataMin)), T(i) && T(s) && T(r) && i - s < r && (n = this.dataMax - this.dataMin >= r, o = (r - i + s) / 2, a = [s - o, E(t.min, s - o)], n && (a[2] = e ? e.log2lin(this.dataMin) : this.dataMin), h = [(s = g(a)) + r, E(t.max, s + r)], n && (h[2] = e ? e.log2lin(this.dataMax) : this.dataMax), (i = f(h)) - s < r && (a[0] = i - r, a[1] = E(t.min, i - r), s = g(a))), this.minRange = r, this.min = s, this.max = i;\n        }\n      }, {\n        key: \"getClosest\",\n        value: function getClosest() {\n          var t, e;\n          if (this.categories) e = 1;else {\n            var _i21 = [];\n            this.series.forEach(function (t) {\n              var _t$xData2;\n              var s = t.closestPointRange;\n              ((_t$xData2 = t.xData) === null || _t$xData2 === void 0 ? void 0 : _t$xData2.length) === 1 ? _i21.push(t.xData[0]) : !t.noSharedTooltip && y(s) && t.reserveSpace() && (e = y(e) ? Math.min(e, s) : s);\n            }), _i21.length && (_i21.sort(function (t, e) {\n              return t - e;\n            }), t = M([_i21]));\n          }\n          return t && e ? Math.min(t, e) : t || e;\n        }\n      }, {\n        key: \"nameToX\",\n        value: function nameToX(t) {\n          var e = A(this.options.categories),\n            i = e ? this.categories : this.names,\n            s = t.options.x,\n            r;\n          return t.series.requireSorting = !1, y(s) || (s = this.options.uniqueNames && i ? e ? i.indexOf(t.name) : E(i.keys[t.name], -1) : t.series.autoIncrement()), -1 === s ? !e && i && (r = i.length) : r = s, void 0 !== r ? (this.names[r] = t.name, this.names.keys[t.name] = r) : t.x && (r = t.x), r;\n        }\n      }, {\n        key: \"updateNames\",\n        value: function updateNames() {\n          var t = this,\n            e = this.names;\n          e.length > 0 && (Object.keys(e.keys).forEach(function (t) {\n            delete e.keys[t];\n          }), e.length = 0, this.minRange = this.userMinRange, (this.series || []).forEach(function (e) {\n            e.xIncrement = null, (!e.points || e.isDirtyData) && (t.max = Math.max(t.max, e.xData.length - 1), e.processData(), e.generatePoints()), e.data.forEach(function (i, s) {\n              var r;\n              (i === null || i === void 0 ? void 0 : i.options) && void 0 !== i.name && void 0 !== (r = t.nameToX(i)) && r !== i.x && (i.x = r, e.xData[s] = r);\n            });\n          }));\n        }\n      }, {\n        key: \"setAxisTranslation\",\n        value: function setAxisTranslation() {\n          var t = this,\n            e = t.max - t.min,\n            i = t.linkedParent,\n            s = !!t.categories,\n            r = t.isXAxis,\n            o = t.axisPointRange || 0,\n            n,\n            a = 0,\n            h = 0,\n            l,\n            d = t.transA;\n          (r || s || o) && (n = t.getClosest(), i ? (a = i.minPointOffset, h = i.pointRangePadding) : t.series.forEach(function (e) {\n            var i = s ? 1 : r ? E(e.options.pointRange, n, 0) : t.axisPointRange || 0,\n              l = e.options.pointPlacement;\n            if (o = Math.max(o, i), !t.single || s) {\n              var _t27 = e.is(\"xrange\") ? !r : r;\n              a = Math.max(a, _t27 && P(l) ? 0 : i / 2), h = Math.max(h, _t27 && \"on\" === l ? 0 : i);\n            }\n          }), l = t.ordinal && t.ordinal.slope && n ? t.ordinal.slope / n : 1, t.minPointOffset = a *= l, t.pointRangePadding = h *= l, t.pointRange = Math.min(o, t.single && s ? 1 : e), r && n && (t.closestPointRange = n)), t.translationSlope = t.transA = d = t.staticScale || t.len / (e + h || 1), t.transB = t.horiz ? t.left : t.bottom, t.minPixelPadding = d * a, k(this, \"afterSetAxisTranslation\");\n        }\n      }, {\n        key: \"minFromRange\",\n        value: function minFromRange() {\n          var t = this.max,\n            e = this.min;\n          return T(t) && T(e) && t - e || void 0;\n        }\n      }, {\n        key: \"setTickInterval\",\n        value: function setTickInterval(t) {\n          var _i$this$coll;\n          var e = this.categories,\n            i = this.chart,\n            s = this.dataMax,\n            r = this.dataMin,\n            o = this.dateTime,\n            n = this.isXAxis,\n            a = this.logarithmic,\n            h = this.options,\n            l = this.softThreshold,\n            d = T(this.threshold) ? this.threshold : void 0,\n            c = this.minRange || 0,\n            p = h.ceiling,\n            u = h.floor,\n            g = h.linkedTo,\n            f = h.softMax,\n            m = h.softMin,\n            b = T(g) && ((_i$this$coll = i[this.coll]) === null || _i$this$coll === void 0 ? void 0 : _i$this$coll[g]),\n            v = h.tickPixelInterval,\n            C = h.maxPadding,\n            M = h.minPadding,\n            w = 0,\n            A,\n            P = T(h.tickInterval) && h.tickInterval >= 0 ? h.tickInterval : void 0,\n            L,\n            O,\n            D,\n            I;\n          if (o || e || b || this.getTickAmount(), D = E(this.userMin, h.min), I = E(this.userMax, h.max), b ? (this.linkedParent = b, A = b.getExtremes(), this.min = E(A.min, A.dataMin), this.max = E(A.max, A.dataMax), h.type !== b.options.type && S(11, !0, i)) : (l && y(d) && T(s) && T(r) && (r >= d ? (L = d, M = 0) : s <= d && (O = d, C = 0)), this.min = E(D, L, r), this.max = E(I, O, s)), T(this.max) && T(this.min) && (a && (this.positiveValuesOnly && !t && 0 >= Math.min(this.min, E(r, this.min)) && S(10, !0, i), this.min = x(a.log2lin(this.min), 16), this.max = x(a.log2lin(this.max), 16)), this.range && T(r) && (this.userMin = this.min = D = Math.max(r, this.minFromRange() || 0), this.userMax = I = this.max, this.range = void 0)), k(this, \"foundExtremes\"), this.adjustForMinRange(), T(this.min) && T(this.max)) {\n            var _this$stacking;\n            if (!T(this.userMin) && T(m) && m < this.min && (this.min = D = m), !T(this.userMax) && T(f) && f > this.max && (this.max = I = f), e || this.axisPointRange || (_this$stacking = this.stacking) !== null && _this$stacking !== void 0 && _this$stacking.usePercentage || b || !(w = this.max - this.min) || (!y(D) && M && (this.min -= w * M), y(I) || !C || (this.max += w * C)), !T(this.userMin) && T(u) && (this.min = Math.max(this.min, u)), !T(this.userMax) && T(p) && (this.max = Math.min(this.max, p)), l && T(r) && T(s)) {\n              var _t28 = d || 0;\n              !y(D) && this.min < _t28 && r >= _t28 ? this.min = h.minRange ? Math.min(_t28, this.max - c) : _t28 : !y(I) && this.max > _t28 && s <= _t28 && (this.max = h.minRange ? Math.max(_t28, this.min + c) : _t28);\n            }\n            !i.polar && this.min > this.max && (y(h.min) ? this.max = this.min : y(h.max) && (this.min = this.max)), w = this.max - this.min;\n          }\n          if (this.min !== this.max && T(this.min) && T(this.max) ? b && !P && v === b.options.tickPixelInterval ? this.tickInterval = P = b.tickInterval : this.tickInterval = E(P, this.tickAmount ? w / Math.max(this.tickAmount - 1, 1) : void 0, e ? 1 : w * v / Math.max(this.len, v)) : this.tickInterval = 1, n && !t) {\n            var _this$old, _this$old2;\n            var _t29 = this.min !== ((_this$old = this.old) === null || _this$old === void 0 ? void 0 : _this$old.min) || this.max !== ((_this$old2 = this.old) === null || _this$old2 === void 0 ? void 0 : _this$old2.max);\n            this.series.forEach(function (e) {\n              var _e$forceCropping;\n              e.forceCrop = (_e$forceCropping = e.forceCropping) === null || _e$forceCropping === void 0 ? void 0 : _e$forceCropping.call(e), e.processData(_t29);\n            }), k(this, \"postProcessData\", {\n              hasExtremesChanged: _t29\n            });\n          }\n          this.setAxisTranslation(), k(this, \"initialAxisTranslation\"), this.pointRange && !P && (this.tickInterval = Math.max(this.pointRange, this.tickInterval));\n          var j = E(h.minTickInterval, o && !this.series.some(function (t) {\n            return t.noSharedTooltip;\n          }) ? this.closestPointRange : 0);\n          !P && this.tickInterval < j && (this.tickInterval = j), o || a || P || (this.tickInterval = z(this, this.tickInterval)), this.tickAmount || (this.tickInterval = this.unsquish()), this.setTickPositions();\n        }\n      }, {\n        key: \"setTickPositions\",\n        value: function setTickPositions() {\n          var t = this.options,\n            e = t.tickPositions,\n            i = t.tickPositioner,\n            s = this.getMinorTickInterval(),\n            r = !this.isPanning,\n            o = r && t.startOnTick,\n            n = r && t.endOnTick,\n            a = [],\n            h;\n          if (this.tickmarkOffset = this.categories && \"between\" === t.tickmarkPlacement && 1 === this.tickInterval ? .5 : 0, this.minorTickInterval = \"auto\" === s && this.tickInterval ? this.tickInterval / t.minorTicksPerMajor : s, this.single = this.min === this.max && y(this.min) && !this.tickAmount && (this.min % 1 == 0 || !1 !== t.allowDecimals), e) a = e.slice();else if (T(this.min) && T(this.max)) {\n            var _this$ordinal, _this$ordinal2;\n            if (!((_this$ordinal = this.ordinal) !== null && _this$ordinal !== void 0 && _this$ordinal.positions) && (this.max - this.min) / this.tickInterval > Math.max(2 * this.len, 200)) a = [this.min, this.max], S(19, !1, this.chart);else if (this.dateTime) a = this.getTimeTicks(this.dateTime.normalizeTimeTickInterval(this.tickInterval, t.units), this.min, this.max, t.startOfWeek, (_this$ordinal2 = this.ordinal) === null || _this$ordinal2 === void 0 ? void 0 : _this$ordinal2.positions, this.closestPointRange, !0);else if (this.logarithmic) a = this.logarithmic.getLogTickPositions(this.tickInterval, this.min, this.max);else {\n              var _t30 = this.tickInterval,\n                _e20 = _t30;\n              for (; _e20 <= 2 * _t30;) if (a = this.getLinearTickPositions(this.tickInterval, this.min, this.max), this.tickAmount && a.length > this.tickAmount) this.tickInterval = z(this, _e20 *= 1.1);else break;\n            }\n            a.length > this.len && (a = [a[0], a[a.length - 1]])[0] === a[1] && (a.length = 1), i && (this.tickPositions = a, (h = i.apply(this, [this.min, this.max])) && (a = h));\n          }\n          this.tickPositions = a, this.paddedTicks = a.slice(0), this.trimTicks(a, o, n), !this.isLinked && T(this.min) && T(this.max) && (this.single && a.length < 2 && !this.categories && !this.series.some(function (t) {\n            return t.is(\"heatmap\") && \"between\" === t.options.pointPlacement;\n          }) && (this.min -= .5, this.max += .5), e || h || this.adjustTickAmount()), k(this, \"afterSetTickPositions\");\n        }\n      }, {\n        key: \"trimTicks\",\n        value: function trimTicks(t, e, i) {\n          var s = t[0],\n            r = t[t.length - 1],\n            o = !this.isOrdinal && this.minPointOffset || 0;\n          if (k(this, \"trimTicks\"), !this.isLinked) {\n            if (e && s !== -1 / 0) this.min = s;else for (; this.min - o > t[0];) t.shift();\n            if (i) this.max = r;else for (; this.max + o < t[t.length - 1];) t.pop();\n            0 === t.length && y(s) && !this.options.tickPositions && t.push((r + s) / 2);\n          }\n        }\n      }, {\n        key: \"alignToOthers\",\n        value: function alignToOthers() {\n          var t;\n          var e = this,\n            i = e.chart,\n            s = [this],\n            r = e.options,\n            o = i.options.chart,\n            n = \"yAxis\" === this.coll && o.alignThresholds,\n            a = [];\n          if (e.thresholdAlignment = void 0, (!1 !== o.alignTicks && r.alignTicks || n) && !1 !== r.startOnTick && !1 !== r.endOnTick && !e.logarithmic) {\n            var _r9 = function _r9(t) {\n                var e = t.horiz,\n                  i = t.options;\n                return [e ? i.left : i.top, i.width, i.height, i.pane].join(\",\");\n              },\n              _o13 = _r9(this);\n            i[this.coll].forEach(function (i) {\n              var n = i.series;\n              n.length && n.some(function (t) {\n                return t.visible;\n              }) && i !== e && _r9(i) === _o13 && (t = !0, s.push(i));\n            });\n          }\n          if (t && n) {\n            s.forEach(function (t) {\n              var i = t.getThresholdAlignment(e);\n              T(i) && a.push(i);\n            });\n            var _t31 = a.length > 1 ? a.reduce(function (t, e) {\n              return t += e;\n            }, 0) / a.length : void 0;\n            s.forEach(function (e) {\n              e.thresholdAlignment = _t31;\n            });\n          }\n          return t;\n        }\n      }, {\n        key: \"getThresholdAlignment\",\n        value: function getThresholdAlignment(t) {\n          if ((!T(this.dataMin) || this !== t && this.series.some(function (t) {\n            return t.isDirty || t.isDirtyData;\n          })) && this.getSeriesExtremes(), T(this.threshold)) {\n            var _t32 = m((this.threshold - (this.dataMin || 0)) / ((this.dataMax || 0) - (this.dataMin || 0)), 0, 1);\n            return this.options.reversed && (_t32 = 1 - _t32), _t32;\n          }\n        }\n      }, {\n        key: \"getTickAmount\",\n        value: function getTickAmount() {\n          var t = this.options,\n            e = t.tickPixelInterval,\n            i = t.tickAmount;\n          y(t.tickInterval) || i || !(this.len < e) || this.isRadial || this.logarithmic || !t.startOnTick || !t.endOnTick || (i = 2), !i && this.alignToOthers() && (i = Math.ceil(this.len / e) + 1), i < 4 && (this.finalTickAmt = i, i = 5), this.tickAmount = i;\n        }\n      }, {\n        key: \"adjustTickAmount\",\n        value: function adjustTickAmount() {\n          var t = this,\n            e = t.finalTickAmt,\n            i = t.max,\n            s = t.min,\n            r = t.options,\n            o = t.tickPositions,\n            n = t.tickAmount,\n            a = t.thresholdAlignment,\n            h = o === null || o === void 0 ? void 0 : o.length,\n            l = E(t.threshold, t.softThreshold ? 0 : null),\n            d,\n            c,\n            p = t.tickInterval,\n            u,\n            g = function g() {\n              return o.push(x(o[o.length - 1] + p));\n            },\n            f = function f() {\n              return o.unshift(x(o[0] - p));\n            };\n          if (T(a) && (u = a < .5 ? Math.ceil(a * (n - 1)) : Math.floor(a * (n - 1)), r.reversed && (u = n - 1 - u)), t.hasData() && T(s) && T(i)) {\n            var _a7 = function _a7() {\n              t.transA *= (h - 1) / (n - 1), t.min = r.startOnTick ? o[0] : Math.min(s, o[0]), t.max = r.endOnTick ? o[o.length - 1] : Math.max(i, o[o.length - 1]);\n            };\n            if (T(u) && T(t.threshold)) {\n              for (; o[u] !== l || o.length !== n || o[0] > s || o[o.length - 1] < i;) {\n                for (o.length = 0, o.push(t.threshold); o.length < n;) void 0 === o[u] || o[u] > t.threshold ? f() : g();\n                if (p > 8 * t.tickInterval) break;\n                p *= 2;\n              }\n              _a7();\n            } else if (h < n) {\n              for (; o.length < n;) o.length % 2 || s === l ? g() : f();\n              _a7();\n            }\n            if (y(e)) {\n              for (c = d = o.length; c--;) (3 === e && c % 2 == 1 || e <= 2 && c > 0 && c < d - 1) && o.splice(c, 1);\n              t.finalTickAmt = void 0;\n            }\n          }\n        }\n      }, {\n        key: \"setScale\",\n        value: function setScale() {\n          var _this$old3, _this$old4;\n          var t = this.coll,\n            e = this.stacking,\n            i = !1,\n            s = !1;\n          this.series.forEach(function (t) {\n            i = i || t.isDirtyData || t.isDirty, s = s || t.xAxis && t.xAxis.isDirty || !1;\n          }), this.setAxisSize();\n          var r = this.len !== (this.old && this.old.len);\n          r || i || s || this.isLinked || this.forceRedraw || this.userMin !== (this.old && this.old.userMin) || this.userMax !== (this.old && this.old.userMax) || this.alignToOthers() ? (e && \"yAxis\" === t && e.buildStacks(), this.forceRedraw = !1, this.userMinRange || (this.minRange = void 0), this.getSeriesExtremes(), this.setTickInterval(), e && \"xAxis\" === t && e.buildStacks(), this.isDirty || (this.isDirty = r || this.min !== ((_this$old3 = this.old) === null || _this$old3 === void 0 ? void 0 : _this$old3.min) || this.max !== ((_this$old4 = this.old) === null || _this$old4 === void 0 ? void 0 : _this$old4.max))) : e && e.cleanStacks(), i && delete this.allExtremes, k(this, \"afterSetScale\");\n        }\n      }, {\n        key: \"setExtremes\",\n        value: function setExtremes(t, e) {\n          var _this6 = this;\n          var i = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !0;\n          var s = arguments.length > 3 ? arguments[3] : undefined;\n          var r = arguments.length > 4 ? arguments[4] : undefined;\n          this.series.forEach(function (t) {\n            delete t.kdTree;\n          }), k(this, \"setExtremes\", r = C(r, {\n            min: t,\n            max: e\n          }), function (t) {\n            _this6.userMin = t.min, _this6.userMax = t.max, _this6.eventArgs = t, i && _this6.chart.redraw(s);\n          });\n        }\n      }, {\n        key: \"setAxisSize\",\n        value: function setAxisSize() {\n          var t = this.chart,\n            e = this.options,\n            i = e.offsets || [0, 0, 0, 0],\n            s = this.horiz,\n            r = this.width = Math.round(I(E(e.width, t.plotWidth - i[3] + i[1]), t.plotWidth)),\n            o = this.height = Math.round(I(E(e.height, t.plotHeight - i[0] + i[2]), t.plotHeight)),\n            n = this.top = Math.round(I(E(e.top, t.plotTop + i[0]), t.plotHeight, t.plotTop)),\n            a = this.left = Math.round(I(E(e.left, t.plotLeft + i[3]), t.plotWidth, t.plotLeft));\n          this.bottom = t.chartHeight - o - n, this.right = t.chartWidth - r - a, this.len = Math.max(s ? r : o, 0), this.pos = s ? a : n;\n        }\n      }, {\n        key: \"getExtremes\",\n        value: function getExtremes() {\n          var t = this.logarithmic;\n          return {\n            min: t ? x(t.lin2log(this.min)) : this.min,\n            max: t ? x(t.lin2log(this.max)) : this.max,\n            dataMin: this.dataMin,\n            dataMax: this.dataMax,\n            userMin: this.userMin,\n            userMax: this.userMax\n          };\n        }\n      }, {\n        key: \"getThreshold\",\n        value: function getThreshold(t) {\n          var e = this.logarithmic,\n            i = e ? e.lin2log(this.min) : this.min,\n            s = e ? e.lin2log(this.max) : this.max;\n          return null === t || t === -1 / 0 ? t = i : t === 1 / 0 ? t = s : i > t ? t = i : s < t && (t = s), this.translate(t, 0, 1, 0, 1);\n        }\n      }, {\n        key: \"autoLabelAlign\",\n        value: function autoLabelAlign(t) {\n          var e = (E(t, 0) - 90 * this.side + 720) % 360,\n            i = {\n              align: \"center\"\n            };\n          return k(this, \"autoLabelAlign\", i, function (t) {\n            e > 15 && e < 165 ? t.align = \"right\" : e > 195 && e < 345 && (t.align = \"left\");\n          }), i.align;\n        }\n      }, {\n        key: \"tickSize\",\n        value: function tickSize(t) {\n          var e = this.options,\n            i = E(e[\"tick\" === t ? \"tickWidth\" : \"minorTickWidth\"], \"tick\" === t && this.isXAxis && !this.categories ? 1 : 0),\n            s = e[\"tick\" === t ? \"tickLength\" : \"minorTickLength\"],\n            r;\n          i && s && (\"inside\" === e[t + \"Position\"] && (s = -s), r = [s, i]);\n          var o = {\n            tickSize: r\n          };\n          return k(this, \"afterTickSize\", o), o.tickSize;\n        }\n      }, {\n        key: \"labelMetrics\",\n        value: function labelMetrics() {\n          var t = this.chart.renderer,\n            e = this.ticks,\n            i = e[Object.keys(e)[0]] || {};\n          return this.chart.renderer.fontMetrics(i.label || i.movedLabel || t.box);\n        }\n      }, {\n        key: \"unsquish\",\n        value: function unsquish() {\n          var t = this.options.labels,\n            e = t.padding || 0,\n            i = this.horiz,\n            s = this.tickInterval,\n            r = this.len / (((this.categories ? 1 : 0) + this.max - this.min) / s),\n            o = t.rotation,\n            n = x(.8 * this.labelMetrics().h),\n            a = Math.max(this.max - this.min, 0),\n            h = function h(t) {\n              var i = (t + 2 * e) / (r || 1);\n              return (i = i > 1 ? Math.ceil(i) : 1) * s > a && t !== 1 / 0 && r !== 1 / 0 && a && (i = Math.ceil(a / s)), x(i * s);\n            },\n            l = s,\n            d,\n            c = Number.MAX_VALUE,\n            p;\n          if (i) {\n            if (!t.staggerLines && (T(o) ? p = [o] : r < t.autoRotationLimit && (p = t.autoRotation)), p) {\n              var _t33, _e21;\n              var _iterator3 = _createForOfIteratorHelper(p),\n                _step3;\n              try {\n                for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n                  var _i22 = _step3.value;\n                  (_i22 === o || _i22 && _i22 >= -90 && _i22 <= 90) && (_e21 = (_t33 = h(Math.abs(n / Math.sin(u * _i22)))) + Math.abs(_i22 / 360)) < c && (c = _e21, d = _i22, l = _t33);\n                }\n              } catch (err) {\n                _iterator3.e(err);\n              } finally {\n                _iterator3.f();\n              }\n            }\n          } else l = h(.75 * n);\n          return this.autoRotation = p, this.labelRotation = E(d, T(o) ? o : 0), t.step ? s : l;\n        }\n      }, {\n        key: \"getSlotWidth\",\n        value: function getSlotWidth(t) {\n          var e = this.chart,\n            i = this.horiz,\n            s = this.options.labels,\n            r = Math.max(this.tickPositions.length - (this.categories ? 0 : 1), 1),\n            o = e.margin[3];\n          if (t && T(t.slotWidth)) return t.slotWidth;\n          if (i && s.step < 2) return s.rotation ? 0 : (this.staggerLines || 1) * this.len / r;\n          if (!i) {\n            var _t34 = s.style.width;\n            if (void 0 !== _t34) return parseInt(String(_t34), 10);\n            if (o) return o - e.spacing[3];\n          }\n          return .33 * e.chartWidth;\n        }\n      }, {\n        key: \"renderUnsquish\",\n        value: function renderUnsquish() {\n          var t = this.chart,\n            e = t.renderer,\n            i = this.tickPositions,\n            s = this.ticks,\n            r = this.options.labels,\n            o = r.style,\n            n = this.horiz,\n            a = this.getSlotWidth(),\n            h = Math.max(1, Math.round(a - (n ? 2 * (r.padding || 0) : r.distance || 0))),\n            l = {},\n            d = this.labelMetrics(),\n            c = o.textOverflow,\n            p,\n            u,\n            g = 0,\n            f,\n            m;\n          if (P(r.rotation) || (l.rotation = r.rotation || 0), i.forEach(function (t) {\n            var e = s[t];\n            e.movedLabel && e.replaceMovedLabel(), e && e.label && e.label.textPxLength > g && (g = e.label.textPxLength);\n          }), this.maxLabelLength = g, this.autoRotation) g > h && g > d.h ? l.rotation = this.labelRotation : this.labelRotation = 0;else if (a && (p = h, !c)) for (u = \"clip\", m = i.length; !n && m--;) (f = s[i[m]].label) && (\"ellipsis\" === f.styles.textOverflow ? f.css({\n            textOverflow: \"clip\"\n          }) : f.textPxLength > a && f.css({\n            width: a + \"px\"\n          }), f.getBBox().height > this.len / i.length - (d.h - d.f) && (f.specificTextOverflow = \"ellipsis\"));\n          l.rotation && (p = g > .5 * t.chartHeight ? .33 * t.chartHeight : g, c || (u = \"ellipsis\")), this.labelAlign = r.align || this.autoLabelAlign(this.labelRotation), this.labelAlign && (l.align = this.labelAlign), i.forEach(function (t) {\n            var e = s[t],\n              i = e && e.label,\n              r = o.width,\n              n = {};\n            i && (i.attr(l), e.shortenLabel ? e.shortenLabel() : p && !r && \"nowrap\" !== o.whiteSpace && (p < i.textPxLength || \"SPAN\" === i.element.tagName) ? (n.width = p + \"px\", c || (n.textOverflow = i.specificTextOverflow || u), i.css(n)) : !i.styles.width || n.width || r || i.css({\n              width: null\n            }), delete i.specificTextOverflow, e.rotation = l.rotation);\n          }, this), this.tickRotCorr = e.rotCorr(d.b, this.labelRotation || 0, 0 !== this.side);\n        }\n      }, {\n        key: \"hasData\",\n        value: function hasData() {\n          return this.series.some(function (t) {\n            return t.hasData();\n          }) || this.options.showEmpty && y(this.min) && y(this.max);\n        }\n      }, {\n        key: \"addTitle\",\n        value: function addTitle(t) {\n          var e;\n          var i = this.chart.renderer,\n            s = this.horiz,\n            r = this.opposite,\n            o = this.options.title,\n            n = this.chart.styledMode;\n          this.axisTitle || ((e = o.textAlign) || (e = (s ? {\n            low: \"left\",\n            middle: \"center\",\n            high: \"right\"\n          } : {\n            low: r ? \"right\" : \"left\",\n            middle: \"center\",\n            high: r ? \"left\" : \"right\"\n          })[o.align]), this.axisTitle = i.text(o.text || \"\", 0, 0, o.useHTML).attr({\n            zIndex: 7,\n            rotation: o.rotation || 0,\n            align: e\n          }).addClass(\"highcharts-axis-title\"), n || this.axisTitle.css(L(o.style)), this.axisTitle.add(this.axisGroup), this.axisTitle.isNew = !0), n || o.style.width || this.isRadial || this.axisTitle.css({\n            width: this.len + \"px\"\n          }), this.axisTitle[t ? \"show\" : \"hide\"](t);\n        }\n      }, {\n        key: \"generateTick\",\n        value: function generateTick(t) {\n          var e = this.ticks;\n          e[t] ? e[t].addLabel() : e[t] = new n(this, t);\n        }\n      }, {\n        key: \"createGroups\",\n        value: function createGroups() {\n          var _this7 = this;\n          var t = this.axisParent,\n            e = this.chart,\n            i = this.coll,\n            s = this.options,\n            r = e.renderer,\n            o = function o(e, _o14, n) {\n              return r.g(e).attr({\n                zIndex: n\n              }).addClass(\"highcharts-\".concat(i.toLowerCase()).concat(_o14, \" \") + (_this7.isRadial ? \"highcharts-radial-axis\".concat(_o14, \" \") : \"\") + (s.className || \"\")).add(t);\n            };\n          this.axisGroup || (this.gridGroup = o(\"grid\", \"-grid\", s.gridZIndex), this.axisGroup = o(\"axis\", \"\", s.zIndex), this.labelGroup = o(\"axis-labels\", \"-labels\", s.labels.zIndex));\n        }\n      }, {\n        key: \"getOffset\",\n        value: function getOffset() {\n          var t = this,\n            e = t.chart,\n            i = t.horiz,\n            s = t.options,\n            r = t.side,\n            o = t.ticks,\n            n = t.tickPositions,\n            a = t.coll,\n            h = e.inverted && !t.isZAxis ? [1, 0, 3, 2][r] : r,\n            l = t.hasData(),\n            d = s.title,\n            c = s.labels,\n            p = T(s.crossing),\n            u = e.axisOffset,\n            g = e.clipOffset,\n            f = [-1, 1, 1, -1][r],\n            m,\n            x = 0,\n            b,\n            v = 0,\n            S = 0,\n            C,\n            M;\n          if (t.showAxis = m = l || s.showEmpty, t.staggerLines = t.horiz && c.staggerLines || void 0, t.createGroups(), l || t.isLinked ? (n.forEach(function (e) {\n            t.generateTick(e);\n          }), t.renderUnsquish(), t.reserveSpaceDefault = 0 === r || 2 === r || {\n            1: \"left\",\n            3: \"right\"\n          }[r] === t.labelAlign, E(c.reserveSpace, !p && null, \"center\" === t.labelAlign || null, t.reserveSpaceDefault) && n.forEach(function (t) {\n            S = Math.max(o[t].getLabelSize(), S);\n          }), t.staggerLines && (S *= t.staggerLines), t.labelOffset = S * (t.opposite ? -1 : 1)) : D(o, function (t, e) {\n            t.destroy(), delete o[e];\n          }), d !== null && d !== void 0 && d.text && !1 !== d.enabled && (t.addTitle(m), m && !p && !1 !== d.reserveSpace && (t.titleOffset = x = t.axisTitle.getBBox()[i ? \"height\" : \"width\"], v = y(b = d.offset) ? 0 : E(d.margin, i ? 5 : 10))), t.renderLine(), t.offset = f * E(s.offset, u[r] ? u[r] + (s.margin || 0) : 0), t.tickRotCorr = t.tickRotCorr || {\n            x: 0,\n            y: 0\n          }, M = 0 === r ? -t.labelMetrics().h : 2 === r ? t.tickRotCorr.y : 0, C = Math.abs(S) + v, S && (C -= M, C += f * (i ? E(c.y, t.tickRotCorr.y + f * c.distance) : E(c.x, f * c.distance))), t.axisTitleMargin = E(b, C), t.getMaxLabelDimensions && (t.maxLabelDimensions = t.getMaxLabelDimensions(o, n)), \"colorAxis\" !== a && g) {\n            var _e22 = this.tickSize(\"tick\");\n            u[r] = Math.max(u[r], (t.axisTitleMargin || 0) + x + f * t.offset, C, n && n.length && _e22 ? _e22[0] + f * t.offset : 0);\n            var _i23 = !t.axisLine || s.offset ? 0 : t.axisLine.strokeWidth() / 2;\n            g[h] = Math.max(g[h], _i23);\n          }\n          k(this, \"afterGetOffset\");\n        }\n      }, {\n        key: \"getLinePath\",\n        value: function getLinePath(t) {\n          var e = this.chart,\n            i = this.opposite,\n            s = this.offset,\n            r = this.horiz,\n            o = this.left + (i ? this.width : 0) + s,\n            n = e.chartHeight - this.bottom - (i ? this.height : 0) + s;\n          return i && (t *= -1), e.renderer.crispLine([[\"M\", r ? this.left : o, r ? n : this.top], [\"L\", r ? e.chartWidth - this.right : o, r ? n : e.chartHeight - this.bottom]], t);\n        }\n      }, {\n        key: \"renderLine\",\n        value: function renderLine() {\n          this.axisLine || (this.axisLine = this.chart.renderer.path().addClass(\"highcharts-axis-line\").add(this.axisGroup), this.chart.styledMode || this.axisLine.attr({\n            stroke: this.options.lineColor,\n            \"stroke-width\": this.options.lineWidth,\n            zIndex: 7\n          }));\n        }\n      }, {\n        key: \"getTitlePosition\",\n        value: function getTitlePosition(t) {\n          var e = this.horiz,\n            i = this.left,\n            s = this.top,\n            r = this.len,\n            o = this.options.title,\n            n = e ? i : s,\n            a = this.opposite,\n            h = this.offset,\n            l = o.x,\n            d = o.y,\n            c = this.chart.renderer.fontMetrics(t),\n            p = t ? Math.max(t.getBBox(!1, 0).height - c.h - 1, 0) : 0,\n            u = {\n              low: n + (e ? 0 : r),\n              middle: n + r / 2,\n              high: n + (e ? r : 0)\n            }[o.align],\n            g = (e ? s + this.height : i) + (e ? 1 : -1) * (a ? -1 : 1) * (this.axisTitleMargin || 0) + [-p, p, c.f, -p][this.side],\n            f = {\n              x: e ? u + l : g + (a ? this.width : 0) + h + l,\n              y: e ? g + d - (a ? this.height : 0) + h : u + d\n            };\n          return k(this, \"afterGetTitlePosition\", {\n            titlePosition: f\n          }), f;\n        }\n      }, {\n        key: \"renderMinorTick\",\n        value: function renderMinorTick(t, e) {\n          var i = this.minorTicks;\n          i[t] || (i[t] = new n(this, t, \"minor\")), e && i[t].isNew && i[t].render(null, !0), i[t].render(null, !1, 1);\n        }\n      }, {\n        key: \"renderTick\",\n        value: function renderTick(t, e, i) {\n          var s = this.isLinked,\n            r = this.ticks;\n          (!s || t >= this.min && t <= this.max || this.grid && this.grid.isColumn) && (r[t] || (r[t] = new n(this, t)), i && r[t].isNew && r[t].render(e, !0, -1), r[t].render(e));\n        }\n      }, {\n        key: \"render\",\n        value: function render() {\n          var t, e;\n          var i = this,\n            s = i.chart,\n            r = i.logarithmic,\n            a = s.renderer,\n            l = i.options,\n            d = i.isLinked,\n            c = i.tickPositions,\n            p = i.axisTitle,\n            u = i.ticks,\n            g = i.minorTicks,\n            f = i.alternateBands,\n            m = l.stackLabels,\n            x = l.alternateGridColor,\n            y = l.crossing,\n            b = i.tickmarkOffset,\n            v = i.axisLine,\n            S = i.showAxis,\n            C = h(a.globalAnimation);\n          if (i.labelEdge.length = 0, i.overlap = !1, [u, g, f].forEach(function (t) {\n            D(t, function (t) {\n              t.isActive = !1;\n            });\n          }), T(y)) {\n            var _t35 = this.isXAxis ? s.yAxis[0] : s.xAxis[0],\n              _e23 = [1, -1, -1, 1][this.side];\n            if (_t35) {\n              var _s23 = _t35.toPixels(y, !0);\n              i.horiz && (_s23 = _t35.len - _s23), i.offset = _e23 * _s23;\n            }\n          }\n          if (i.hasData() || d) {\n            var _a8 = i.chart.hasRendered && i.old && T(i.old.min);\n            i.minorTickInterval && !i.categories && i.getMinorTickPositions().forEach(function (t) {\n              i.renderMinorTick(t, _a8);\n            }), c.length && (c.forEach(function (t, e) {\n              i.renderTick(t, e, _a8);\n            }), b && (0 === i.min || i.single) && (u[-1] || (u[-1] = new n(i, -1, null, !0)), u[-1].render(-1))), x && c.forEach(function (n, a) {\n              e = void 0 !== c[a + 1] ? c[a + 1] + b : i.max - b, a % 2 == 0 && n < i.max && e <= i.max + (s.polar ? -b : b) && (f[n] || (f[n] = new o.PlotLineOrBand(i, {})), t = n + b, f[n].options = {\n                from: r ? r.lin2log(t) : t,\n                to: r ? r.lin2log(e) : e,\n                color: x,\n                className: \"highcharts-alternate-grid\"\n              }, f[n].render(), f[n].isActive = !0);\n            }), i._addedPlotLB || (i._addedPlotLB = !0, (l.plotLines || []).concat(l.plotBands || []).forEach(function (t) {\n              i.addPlotBandOrLine(t);\n            }));\n          }\n          [u, g, f].forEach(function (t) {\n            var e = [],\n              i = C.duration;\n            D(t, function (t, i) {\n              t.isActive || (t.render(i, !1, 0), t.isActive = !1, e.push(i));\n            }), R(function () {\n              var i = e.length;\n              for (; i--;) t[e[i]] && !t[e[i]].isActive && (t[e[i]].destroy(), delete t[e[i]]);\n            }, t !== f && s.hasRendered && i ? i : 0);\n          }), v && (v[v.isPlaced ? \"animate\" : \"attr\"]({\n            d: this.getLinePath(v.strokeWidth())\n          }), v.isPlaced = !0, v[S ? \"show\" : \"hide\"](S)), p && S && (p[p.isNew ? \"attr\" : \"animate\"](i.getTitlePosition(p)), p.isNew = !1), m && m.enabled && i.stacking && i.stacking.renderStackTotals(), i.old = {\n            len: i.len,\n            max: i.max,\n            min: i.min,\n            transA: i.transA,\n            userMax: i.userMax,\n            userMin: i.userMin\n          }, i.isDirty = !1, k(this, \"afterRender\");\n        }\n      }, {\n        key: \"redraw\",\n        value: function redraw() {\n          this.visible && (this.render(), this.plotLinesAndBands.forEach(function (t) {\n            t.render();\n          })), this.series.forEach(function (t) {\n            t.isDirty = !0;\n          });\n        }\n      }, {\n        key: \"getKeepProps\",\n        value: function getKeepProps() {\n          return this.keepProps || N.keepProps;\n        }\n      }, {\n        key: \"destroy\",\n        value: function destroy(t) {\n          var e = this,\n            i = e.plotLinesAndBands,\n            s = this.eventOptions;\n          if (k(this, \"destroy\", {\n            keepEvents: t\n          }), t || j(e), [e.ticks, e.minorTicks, e.alternateBands].forEach(function (t) {\n            b(t);\n          }), i) {\n            var _t36 = i.length;\n            for (; _t36--;) i[_t36].destroy();\n          }\n          for (var _t37 in [\"axisLine\", \"axisTitle\", \"axisGroup\", \"gridGroup\", \"labelGroup\", \"cross\", \"scrollbar\"].forEach(function (t) {\n            e[t] && (e[t] = e[t].destroy());\n          }), e.plotLinesAndBandsGroups) e.plotLinesAndBandsGroups[_t37] = e.plotLinesAndBandsGroups[_t37].destroy();\n          D(e, function (t, i) {\n            -1 === e.getKeepProps().indexOf(i) && delete e[i];\n          }), this.eventOptions = s;\n        }\n      }, {\n        key: \"drawCrosshair\",\n        value: function drawCrosshair(t, e) {\n          var s = this.crosshair,\n            r = E(s && s.snap, !0),\n            o = this.chart,\n            n,\n            a,\n            h,\n            l = this.cross,\n            d;\n          if (k(this, \"drawCrosshair\", {\n            e: t,\n            point: e\n          }), t || (t = this.cross && this.cross.e), s && !1 !== (y(e) || !r)) {\n            if (r ? y(e) && (a = E(\"colorAxis\" !== this.coll ? e.crosshairPos : null, this.isXAxis ? e.plotX : this.len - e.plotY)) : a = t && (this.horiz ? t.chartX - this.pos : this.len - t.chartY + this.pos), y(a) && (d = {\n              value: e && (this.isXAxis ? e.x : E(e.stackY, e.y)),\n              translatedValue: a\n            }, o.polar && C(d, {\n              isCrosshair: !0,\n              chartX: t && t.chartX,\n              chartY: t && t.chartY,\n              point: e\n            }), n = this.getPlotLinePath(d) || null), !y(n)) {\n              this.hideCrosshair();\n              return;\n            }\n            h = this.categories && !this.isRadial, l || (this.cross = l = o.renderer.path().addClass(\"highcharts-crosshair highcharts-crosshair-\" + (h ? \"category \" : \"thin \") + (s.className || \"\")).attr({\n              zIndex: E(s.zIndex, 2)\n            }).add(), !o.styledMode && (l.attr({\n              stroke: s.color || (h ? i.parse(\"#ccd3ff\").setOpacity(.25).get() : \"#cccccc\"),\n              \"stroke-width\": E(s.width, 1)\n            }).css({\n              \"pointer-events\": \"none\"\n            }), s.dashStyle && l.attr({\n              dashstyle: s.dashStyle\n            }))), l.show().attr({\n              d: n\n            }), h && !s.width && l.attr({\n              \"stroke-width\": this.transA\n            }), this.cross.e = t;\n          } else this.hideCrosshair();\n          k(this, \"afterDrawCrosshair\", {\n            e: t,\n            point: e\n          });\n        }\n      }, {\n        key: \"hideCrosshair\",\n        value: function hideCrosshair() {\n          this.cross && this.cross.hide(), k(this, \"afterHideCrosshair\");\n        }\n      }, {\n        key: \"update\",\n        value: function update(t, e) {\n          var i = this.chart;\n          t = L(this.userOptions, t), this.destroy(!0), this.init(i, t), i.isDirtyBox = !0, E(e, !0) && i.redraw();\n        }\n      }, {\n        key: \"remove\",\n        value: function remove(t) {\n          var e = this.chart,\n            i = this.coll,\n            s = this.series,\n            r = s.length;\n          for (; r--;) s[r] && s[r].remove(!1);\n          v(e.axes, this), v(e[i] || [], this), e.orderItems(i), this.destroy(), e.isDirtyBox = !0, E(t, !0) && e.redraw();\n        }\n      }, {\n        key: \"setTitle\",\n        value: function setTitle(t, e) {\n          this.update({\n            title: t\n          }, e);\n        }\n      }, {\n        key: \"setCategories\",\n        value: function setCategories(t, e) {\n          this.update({\n            categories: t\n          }, e);\n        }\n      }]);\n    }();\n    return N.keepProps = [\"coll\", \"extKey\", \"hcEvents\", \"len\", \"names\", \"series\", \"userMax\", \"userMin\"], N;\n  }), i(e, \"Core/Axis/DateTimeAxis.js\", [e[\"Core/Utilities.js\"]], function (t) {\n    var e;\n    var i = t.addEvent,\n      s = t.getMagnitude,\n      r = t.normalizeTickInterval,\n      o = t.timeUnits;\n    return function (t) {\n      function e() {\n        return this.chart.time.getTimeTicks.apply(this.chart.time, arguments);\n      }\n      function n() {\n        if (\"datetime\" !== this.options.type) {\n          this.dateTime = void 0;\n          return;\n        }\n        this.dateTime || (this.dateTime = new a(this));\n      }\n      t.compose = function (t) {\n        return t.keepProps.includes(\"dateTime\") || (t.keepProps.push(\"dateTime\"), t.prototype.getTimeTicks = e, i(t, \"afterSetOptions\", n)), t;\n      };\n      var a = /*#__PURE__*/function () {\n        function a(t) {\n          _classCallCheck(this, a);\n          this.axis = t;\n        }\n        return _createClass(a, [{\n          key: \"normalizeTimeTickInterval\",\n          value: function normalizeTimeTickInterval(t, e) {\n            var i = e || [[\"millisecond\", [1, 2, 5, 10, 20, 25, 50, 100, 200, 500]], [\"second\", [1, 2, 5, 10, 15, 30]], [\"minute\", [1, 2, 5, 10, 15, 30]], [\"hour\", [1, 2, 3, 4, 6, 8, 12]], [\"day\", [1, 2]], [\"week\", [1, 2]], [\"month\", [1, 2, 3, 4, 6]], [\"year\", null]],\n              n = i[i.length - 1],\n              _a9 = o[n[0]],\n              h = n[1],\n              l;\n            for (l = 0; l < i.length && (_a9 = o[(n = i[l])[0]], h = n[1], !i[l + 1] || !(t <= (_a9 * h[h.length - 1] + o[i[l + 1][0]]) / 2)); l++);\n            _a9 === o.year && t < 5 * _a9 && (h = [1, 2, 5]);\n            var d = r(t / _a9, h, \"year\" === n[0] ? Math.max(s(t / _a9), 1) : 1);\n            return {\n              unitRange: _a9,\n              count: d,\n              unitName: n[0]\n            };\n          }\n        }, {\n          key: \"getXDateFormat\",\n          value: function getXDateFormat(t, e) {\n            var i = this.axis,\n              s = i.chart.time;\n            return i.closestPointRange ? s.getDateFormat(i.closestPointRange, t, i.options.startOfWeek, e) || s.resolveDTLFormat(e.year).main : s.resolveDTLFormat(e.day).main;\n          }\n        }]);\n      }();\n      t.Additions = a;\n    }(e || (e = {})), e;\n  }), i(e, \"Core/Axis/LogarithmicAxis.js\", [e[\"Core/Utilities.js\"]], function (t) {\n    var e;\n    var i = t.addEvent,\n      s = t.normalizeTickInterval,\n      r = t.pick;\n    return function (t) {\n      function e(t) {\n        var e = t.userOptions,\n          i = this.logarithmic;\n        \"logarithmic\" !== e.type ? this.logarithmic = void 0 : i || (i = this.logarithmic = new n(this));\n      }\n      function o() {\n        var t = this.logarithmic;\n        t && (this.lin2val = function (e) {\n          return t.lin2log(e);\n        }, this.val2lin = function (e) {\n          return t.log2lin(e);\n        });\n      }\n      t.compose = function (t) {\n        return t.keepProps.includes(\"logarithmic\") || (t.keepProps.push(\"logarithmic\"), i(t, \"init\", e), i(t, \"afterInit\", o)), t;\n      };\n      var n = /*#__PURE__*/function () {\n        function n(t) {\n          _classCallCheck(this, n);\n          this.axis = t;\n        }\n        return _createClass(n, [{\n          key: \"getLogTickPositions\",\n          value: function getLogTickPositions(t, e, i, o) {\n            var _n6 = this.axis,\n              a = _n6.len,\n              h = _n6.options,\n              l = [];\n            if (o || (this.minorAutoInterval = void 0), t >= .5) t = Math.round(t), l = _n6.getLinearTickPositions(t, e, i);else if (t >= .08) {\n              var _s24, _r10, _n7, _a10, _h5, d, c;\n              var _p3 = Math.floor(e);\n              for (_s24 = t > .3 ? [1, 2, 4] : t > .15 ? [1, 2, 4, 6, 8] : [1, 2, 3, 4, 5, 6, 7, 8, 9], _r10 = _p3; _r10 < i + 1 && !c; _r10++) for (_n7 = 0, _a10 = _s24.length; _n7 < _a10 && !c; _n7++) (_h5 = this.log2lin(this.lin2log(_r10) * _s24[_n7])) > e && (!o || d <= i) && void 0 !== d && l.push(d), d > i && (c = !0), d = _h5;\n            } else {\n              var _d3 = this.lin2log(e),\n                _c3 = this.lin2log(i),\n                _p4 = o ? _n6.getMinorTickInterval() : h.tickInterval,\n                u = h.tickPixelInterval / (o ? 5 : 1),\n                g = o ? a / _n6.tickPositions.length : a;\n              t = s(t = r(\"auto\" === _p4 ? null : _p4, this.minorAutoInterval, (_c3 - _d3) * u / (g || 1))), l = _n6.getLinearTickPositions(t, _d3, _c3).map(this.log2lin), o || (this.minorAutoInterval = t / 5);\n            }\n            return o || (_n6.tickInterval = t), l;\n          }\n        }, {\n          key: \"lin2log\",\n          value: function lin2log(t) {\n            return Math.pow(10, t);\n          }\n        }, {\n          key: \"log2lin\",\n          value: function log2lin(t) {\n            return Math.log(t) / Math.LN10;\n          }\n        }]);\n      }();\n      t.Additions = n;\n    }(e || (e = {})), e;\n  }), i(e, \"Core/Axis/PlotLineOrBand/PlotLineOrBandAxis.js\", [e[\"Core/Utilities.js\"]], function (t) {\n    var e;\n    var i = t.erase,\n      s = t.extend,\n      r = t.isNumber;\n    return function (t) {\n      var e;\n      function o(t) {\n        return this.addPlotBandOrLine(t, \"plotBands\");\n      }\n      function n(t, i) {\n        var _this8 = this;\n        var s = this.userOptions,\n          r = new e(this, t);\n        if (this.visible && (r = r.render()), r) {\n          if (this._addedPlotLB || (this._addedPlotLB = !0, (s.plotLines || []).concat(s.plotBands || []).forEach(function (t) {\n            _this8.addPlotBandOrLine(t);\n          })), i) {\n            var _e24 = s[i] || [];\n            _e24.push(t), s[i] = _e24;\n          }\n          this.plotLinesAndBands.push(r);\n        }\n        return r;\n      }\n      function a(t) {\n        return this.addPlotBandOrLine(t, \"plotLines\");\n      }\n      function h(t, e, i) {\n        i = i || this.options;\n        var s = this.getPlotLinePath({\n            value: e,\n            force: !0,\n            acrossPanes: i.acrossPanes\n          }),\n          o = [],\n          n = this.horiz,\n          a = !r(this.min) || !r(this.max) || t < this.min && e < this.min || t > this.max && e > this.max,\n          h = this.getPlotLinePath({\n            value: t,\n            force: !0,\n            acrossPanes: i.acrossPanes\n          }),\n          l,\n          d = 1,\n          c;\n        if (h && s) for (a && (c = h.toString() === s.toString(), d = 0), l = 0; l < h.length; l += 2) {\n          var _t38 = h[l],\n            _e25 = h[l + 1],\n            _i24 = s[l],\n            _r11 = s[l + 1];\n          (\"M\" === _t38[0] || \"L\" === _t38[0]) && (\"M\" === _e25[0] || \"L\" === _e25[0]) && (\"M\" === _i24[0] || \"L\" === _i24[0]) && (\"M\" === _r11[0] || \"L\" === _r11[0]) && (n && _i24[1] === _t38[1] ? (_i24[1] += d, _r11[1] += d) : n || _i24[2] !== _t38[2] || (_i24[2] += d, _r11[2] += d), o.push([\"M\", _t38[1], _t38[2]], [\"L\", _e25[1], _e25[2]], [\"L\", _r11[1], _r11[2]], [\"L\", _i24[1], _i24[2]], [\"Z\"])), o.isFlat = c;\n        }\n        return o;\n      }\n      function l(t) {\n        this.removePlotBandOrLine(t);\n      }\n      function d(t) {\n        var e = this.plotLinesAndBands,\n          s = this.options,\n          r = this.userOptions;\n        if (e) {\n          var _o15 = e.length;\n          for (; _o15--;) e[_o15].id === t && e[_o15].destroy();\n          [s.plotLines || [], r.plotLines || [], s.plotBands || [], r.plotBands || []].forEach(function (e) {\n            for (_o15 = e.length; _o15--;) (e[_o15] || {}).id === t && i(e, e[_o15]);\n          });\n        }\n      }\n      function c(t) {\n        this.removePlotBandOrLine(t);\n      }\n      t.compose = function (t, i) {\n        var r = i.prototype;\n        return r.addPlotBand || (e = t, s(r, {\n          addPlotBand: o,\n          addPlotLine: a,\n          addPlotBandOrLine: n,\n          getPlotBandPath: h,\n          removePlotBand: l,\n          removePlotLine: c,\n          removePlotBandOrLine: d\n        })), i;\n      };\n    }(e || (e = {})), e;\n  }), i(e, \"Core/Axis/PlotLineOrBand/PlotLineOrBand.js\", [e[\"Core/Axis/PlotLineOrBand/PlotLineOrBandAxis.js\"], e[\"Core/Utilities.js\"]], function (t, e) {\n    var i = e.arrayMax,\n      s = e.arrayMin,\n      r = e.defined,\n      o = e.destroyObjectProperties,\n      n = e.erase,\n      a = e.fireEvent,\n      h = e.merge,\n      l = e.objectEach,\n      d = e.pick;\n    var c = /*#__PURE__*/function () {\n      function c(t, e) {\n        _classCallCheck(this, c);\n        this.axis = t, this.options = e, this.id = e.id;\n      }\n      return _createClass(c, [{\n        key: \"render\",\n        value: function render() {\n          var _s$log2lin,\n            _this9 = this,\n            _S,\n            _S2;\n          a(this, \"render\");\n          var t = this.axis,\n            e = this.options,\n            i = t.horiz,\n            s = t.logarithmic,\n            o = e.color,\n            n = e.events,\n            _e$zIndex = e.zIndex,\n            _c4 = _e$zIndex === void 0 ? 0 : _e$zIndex,\n            p = {},\n            u = t.chart.renderer,\n            g = e.to,\n            f = e.from,\n            m = e.value,\n            x = e.borderWidth,\n            y = e.label,\n            b = this.label,\n            v = this.svgElem,\n            S = [],\n            C,\n            k = r(f) && r(g),\n            M = r(m),\n            w = !v,\n            A = {\n              \"class\": \"highcharts-plot-\" + (k ? \"band \" : \"line \") + (e.className || \"\")\n            },\n            T = k ? \"bands\" : \"lines\";\n          if (!t.chart.styledMode && (M ? (A.stroke = o || \"#999999\", A[\"stroke-width\"] = d(e.width, 1), e.dashStyle && (A.dashstyle = e.dashStyle)) : k && (A.fill = o || \"#e6e9ff\", x && (A.stroke = e.borderColor, A[\"stroke-width\"] = x))), p.zIndex = _c4, T += \"-\" + _c4, (C = t.plotLinesAndBandsGroups[T]) || (t.plotLinesAndBandsGroups[T] = C = u.g(\"plot-\" + T).attr(p).add()), v || (this.svgElem = v = u.path().attr(A).add(C)), r(m)) S = t.getPlotLinePath({\n            value: (_s$log2lin = s === null || s === void 0 ? void 0 : s.log2lin(m)) !== null && _s$log2lin !== void 0 ? _s$log2lin : m,\n            lineWidth: v.strokeWidth(),\n            acrossPanes: e.acrossPanes\n          });else {\n            var _s$log2lin2, _s$log2lin3;\n            if (!(r(f) && r(g))) return;\n            S = t.getPlotBandPath((_s$log2lin2 = s === null || s === void 0 ? void 0 : s.log2lin(f)) !== null && _s$log2lin2 !== void 0 ? _s$log2lin2 : f, (_s$log2lin3 = s === null || s === void 0 ? void 0 : s.log2lin(g)) !== null && _s$log2lin3 !== void 0 ? _s$log2lin3 : g, e);\n          }\n          return !this.eventsAdded && n && (l(n, function (t, e) {\n            var _v2;\n            (_v2 = v) === null || _v2 === void 0 || _v2.on(e, function (t) {\n              n[e].apply(_this9, [t]);\n            });\n          }), this.eventsAdded = !0), (w || !v.d) && (_S = S) !== null && _S !== void 0 && _S.length ? v.attr({\n            d: S\n          }) : v && (S ? (v.show(), v.animate({\n            d: S\n          })) : v.d && (v.hide(), b && (this.label = b = b.destroy()))), y && (r(y.text) || r(y.formatter)) && (_S2 = S) !== null && _S2 !== void 0 && _S2.length && t.width > 0 && t.height > 0 && !S.isFlat ? (y = h({\n            align: i && k ? \"center\" : void 0,\n            x: i ? !k && 4 : 10,\n            verticalAlign: !i && k ? \"middle\" : void 0,\n            y: i ? k ? 16 : 10 : k ? 6 : -4,\n            rotation: i && !k ? 90 : 0\n          }, y), this.renderLabel(y, S, k, _c4)) : b && b.hide(), this;\n        }\n      }, {\n        key: \"renderLabel\",\n        value: function renderLabel(t, e, r, o) {\n          var n = this.axis,\n            a = n.chart.renderer,\n            l = this.label;\n          l || (this.label = l = a.text(this.getLabelText(t), 0, 0, t.useHTML).attr({\n            align: t.textAlign || t.align,\n            rotation: t.rotation,\n            \"class\": \"highcharts-plot-\" + (r ? \"band\" : \"line\") + \"-label \" + (t.className || \"\"),\n            zIndex: o\n          }), n.chart.styledMode || l.css(h({\n            fontSize: \"0.8em\",\n            textOverflow: \"ellipsis\"\n          }, t.style)), l.add());\n          var d = e.xBounds || [e[0][1], e[1][1], r ? e[2][1] : e[0][1]],\n            _c5 = e.yBounds || [e[0][2], e[1][2], r ? e[2][2] : e[0][2]],\n            p = s(d),\n            u = s(_c5);\n          if (l.align(t, !1, {\n            x: p,\n            y: u,\n            width: i(d) - p,\n            height: i(_c5) - u\n          }), !l.alignValue || \"left\" === l.alignValue) {\n            var _e26 = t.clip ? n.width : n.chart.chartWidth;\n            l.css({\n              width: (90 === l.rotation ? n.height - (l.alignAttr.y - n.top) : _e26 - (l.alignAttr.x - n.left)) + \"px\"\n            });\n          }\n          l.show(!0);\n        }\n      }, {\n        key: \"getLabelText\",\n        value: function getLabelText(t) {\n          return r(t.formatter) ? t.formatter.call(this) : t.text;\n        }\n      }, {\n        key: \"destroy\",\n        value: function destroy() {\n          n(this.axis.plotLinesAndBands, this), delete this.axis, o(this);\n        }\n      }], [{\n        key: \"compose\",\n        value: function compose(e) {\n          return t.compose(c, e);\n        }\n      }]);\n    }();\n    return c;\n  }), i(e, \"Core/Tooltip.js\", [e[\"Core/Animation/AnimationUtilities.js\"], e[\"Core/Templating.js\"], e[\"Core/Globals.js\"], e[\"Core/Renderer/RendererUtilities.js\"], e[\"Core/Renderer/RendererRegistry.js\"], e[\"Core/Utilities.js\"]], function (t, e, i, s, r, o) {\n    var n;\n    var a = t.animObject,\n      h = e.format,\n      l = i.composed,\n      d = i.doc,\n      c = i.isSafari,\n      p = s.distribute,\n      u = o.addEvent,\n      g = o.clamp,\n      f = o.css,\n      m = o.discardElement,\n      x = o.extend,\n      y = o.fireEvent,\n      b = o.isArray,\n      v = o.isNumber,\n      S = o.isString,\n      C = o.merge,\n      k = o.pick,\n      M = o.pushUnique,\n      w = o.splat,\n      A = o.syncTimeout;\n    var T = /*#__PURE__*/function () {\n      function T(t, e, i) {\n        _classCallCheck(this, T);\n        this.allowShared = !0, this.crosshairs = [], this.distance = 0, this.isHidden = !0, this.isSticky = !1, this.options = {}, this.outside = !1, this.chart = t, this.init(t, e), this.pointer = i;\n      }\n      return _createClass(T, [{\n        key: \"bodyFormatter\",\n        value: function bodyFormatter(t) {\n          return t.map(function (t) {\n            var e = t.series.tooltipOptions;\n            return (e[(t.point.formatPrefix || \"point\") + \"Formatter\"] || t.point.tooltipFormatter).call(t.point, e[(t.point.formatPrefix || \"point\") + \"Format\"] || \"\");\n          });\n        }\n      }, {\n        key: \"cleanSplit\",\n        value: function cleanSplit(t) {\n          this.chart.series.forEach(function (e) {\n            var i = e && e.tt;\n            i && (!i.isActive || t ? e.tt = i.destroy() : i.isActive = !1);\n          });\n        }\n      }, {\n        key: \"defaultFormatter\",\n        value: function defaultFormatter(t) {\n          var e;\n          var i = this.points || w(this);\n          return (e = (e = [t.tooltipFooterHeaderFormatter(i[0])]).concat(t.bodyFormatter(i))).push(t.tooltipFooterHeaderFormatter(i[0], !0)), e;\n        }\n      }, {\n        key: \"destroy\",\n        value: function destroy() {\n          this.label && (this.label = this.label.destroy()), this.split && (this.cleanSplit(!0), this.tt && (this.tt = this.tt.destroy())), this.renderer && (this.renderer = this.renderer.destroy(), m(this.container)), o.clearTimeout(this.hideTimer);\n        }\n      }, {\n        key: \"getAnchor\",\n        value: function getAnchor(t, e) {\n          var i;\n          var s = this.chart,\n            r = this.pointer,\n            o = s.inverted,\n            n = s.plotTop,\n            a = s.plotLeft;\n          if ((t = w(t))[0].series && t[0].series.yAxis && !t[0].series.yAxis.options.reversedStacks && (t = t.slice().reverse()), this.followPointer && e) void 0 === e.chartX && (e = r.normalize(e)), i = [e.chartX - a, e.chartY - n];else if (t[0].tooltipPos) i = t[0].tooltipPos;else {\n            var _s25 = 0,\n              _r12 = 0;\n            t.forEach(function (t) {\n              var e = t.pos(!0);\n              e && (_s25 += e[0], _r12 += e[1]);\n            }), _s25 /= t.length, _r12 /= t.length, this.shared && t.length > 1 && e && (o ? _s25 = e.chartX : _r12 = e.chartY), i = [_s25 - a, _r12 - n];\n          }\n          return i.map(Math.round);\n        }\n      }, {\n        key: \"getClassName\",\n        value: function getClassName(t, e, i) {\n          var s = this.options,\n            r = t.series,\n            o = r.options;\n          return [s.className, \"highcharts-label\", i && \"highcharts-tooltip-header\", e ? \"highcharts-tooltip-box\" : \"highcharts-tooltip\", !i && \"highcharts-color-\" + k(t.colorIndex, r.colorIndex), o && o.className].filter(S).join(\" \");\n        }\n      }, {\n        key: \"getLabel\",\n        value: function getLabel() {\n          var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n              anchorX: 0,\n              anchorY: 0\n            },\n            t = _ref.anchorX,\n            e = _ref.anchorY;\n          var s = this,\n            o = this.chart.styledMode,\n            n = this.options,\n            a = this.split && this.allowShared,\n            h = this.container,\n            l = this.chart.renderer;\n          if (this.label) {\n            var _t39 = !this.label.hasClass(\"highcharts-label\");\n            (!a && _t39 || a && !_t39) && this.destroy();\n          }\n          if (!this.label) {\n            if (this.outside) {\n              var _t40 = this.chart.options.chart.style,\n                _e27 = r.getRendererType();\n              this.container = h = i.doc.createElement(\"div\"), h.className = \"highcharts-tooltip-container\", f(h, {\n                position: \"absolute\",\n                top: \"1px\",\n                pointerEvents: \"none\",\n                zIndex: Math.max(this.options.style.zIndex || 0, (_t40 && _t40.zIndex || 0) + 3)\n              }), this.renderer = l = new _e27(h, 0, 0, _t40, void 0, void 0, l.styledMode);\n            }\n            if (a ? this.label = l.g(\"tooltip\") : (this.label = l.label(\"\", t, e, n.shape, void 0, void 0, n.useHTML, void 0, \"tooltip\").attr({\n              padding: n.padding,\n              r: n.borderRadius\n            }), o || this.label.attr({\n              fill: n.backgroundColor,\n              \"stroke-width\": n.borderWidth || 0\n            }).css(n.style).css({\n              pointerEvents: n.style.pointerEvents || (this.shouldStickOnContact() ? \"auto\" : \"none\")\n            })), s.outside) {\n              var _t41 = this.label;\n              [_t41.xSetter, _t41.ySetter].forEach(function (e, i) {\n                _t41[i ? \"ySetter\" : \"xSetter\"] = function (r) {\n                  e.call(_t41, s.distance), _t41[i ? \"y\" : \"x\"] = r, h && (h.style[i ? \"top\" : \"left\"] = \"\".concat(r, \"px\"));\n                };\n              });\n            }\n            this.label.attr({\n              zIndex: 8\n            }).shadow(n.shadow).add();\n          }\n          return h && !h.parentElement && i.doc.body.appendChild(h), this.label;\n        }\n      }, {\n        key: \"getPlayingField\",\n        value: function getPlayingField() {\n          var t = d.body,\n            e = d.documentElement,\n            i = this.chart,\n            s = this.distance,\n            r = this.outside;\n          return {\n            width: r ? Math.max(t.scrollWidth, e.scrollWidth, t.offsetWidth, e.offsetWidth, e.clientWidth) - 2 * s : i.chartWidth,\n            height: r ? Math.max(t.scrollHeight, e.scrollHeight, t.offsetHeight, e.offsetHeight, e.clientHeight) : i.chartHeight\n          };\n        }\n      }, {\n        key: \"getPosition\",\n        value: function getPosition(t, e, i) {\n          var _r$hoverSeries;\n          var s = this.distance,\n            r = this.chart,\n            o = this.outside,\n            n = this.pointer,\n            a = r.inverted,\n            h = r.plotLeft,\n            l = r.plotTop,\n            d = r.polar,\n            _i$plotX = i.plotX,\n            c = _i$plotX === void 0 ? 0 : _i$plotX,\n            _i$plotY = i.plotY,\n            p = _i$plotY === void 0 ? 0 : _i$plotY,\n            u = {},\n            g = a && i.h || 0,\n            _this$getPlayingField = this.getPlayingField(),\n            f = _this$getPlayingField.height,\n            m = _this$getPlayingField.width,\n            x = n.getChartPosition(),\n            y = function y(t) {\n              return t * x.scaleX;\n            },\n            b = function b(t) {\n              return t * x.scaleY;\n            },\n            v = function v(i) {\n              var n = \"x\" === i;\n              return [i, n ? m : f, n ? t : e].concat(o ? [n ? y(t) : b(e), n ? x.left - s + y(c + h) : x.top - s + b(p + l), 0, n ? m : f] : [n ? t : e, n ? c + h : p + l, n ? h : l, n ? h + r.plotWidth : l + r.plotHeight]);\n            },\n            S = v(\"y\"),\n            C = v(\"x\"),\n            M,\n            w = !!i.negative;\n          !d && ((_r$hoverSeries = r.hoverSeries) === null || _r$hoverSeries === void 0 || (_r$hoverSeries = _r$hoverSeries.yAxis) === null || _r$hoverSeries === void 0 ? void 0 : _r$hoverSeries.reversed) && (w = !w);\n          var A = !this.followPointer && k(i.ttBelow, !d && !a === w),\n            _T = function _T(t, e, i, r, n, a, h) {\n              var l = o ? \"y\" === t ? b(s) : y(s) : s,\n                d = (i - r) / 2,\n                c = r < n - s,\n                p = n + s + r < e,\n                f = n - l - i + d,\n                m = n + l - d;\n              if (A && p) u[t] = m;else if (!A && c) u[t] = f;else if (c) u[t] = Math.min(h - r, f - g < 0 ? f : f - g);else {\n                if (!p) return !1;\n                u[t] = Math.max(a, m + g + i > e ? m : m + g);\n              }\n            },\n            P = function P(t, e, i, r, o) {\n              if (o < s || o > e - s) return !1;\n              o < i / 2 ? u[t] = 1 : o > e - r / 2 ? u[t] = e - r - 2 : u[t] = o - i / 2;\n            },\n            L = function L(t) {\n              var _ref2;\n              (_ref2 = [C, S], S = _ref2[0], C = _ref2[1]), M = t;\n            },\n            _O = function O() {\n              !1 !== _T.apply(0, S) ? !1 !== P.apply(0, C) || M || (L(!0), _O()) : M ? u.x = u.y = 0 : (L(!0), _O());\n            };\n          return (a && !d || this.len > 1) && L(), _O(), u;\n        }\n      }, {\n        key: \"hide\",\n        value: function hide(t) {\n          var e = this;\n          o.clearTimeout(this.hideTimer), t = k(t, this.options.hideDelay), this.isHidden || (this.hideTimer = A(function () {\n            var i = e.getLabel();\n            e.getLabel().animate({\n              opacity: 0\n            }, {\n              duration: t ? 150 : t,\n              complete: function complete() {\n                i.hide(), e.container && e.container.remove();\n              }\n            }), e.isHidden = !0;\n          }, t));\n        }\n      }, {\n        key: \"init\",\n        value: function init(t, e) {\n          this.chart = t, this.options = e, this.crosshairs = [], this.isHidden = !0, this.split = e.split && !t.inverted && !t.polar, this.shared = e.shared || this.split, this.outside = k(e.outside, !!(t.scrollablePixelsX || t.scrollablePixelsY));\n        }\n      }, {\n        key: \"shouldStickOnContact\",\n        value: function shouldStickOnContact(t) {\n          return !!(!this.followPointer && this.options.stickOnContact && (!t || this.pointer.inClass(t.target, \"highcharts-tooltip\")));\n        }\n      }, {\n        key: \"move\",\n        value: function move(t, e, i, s) {\n          var r = this,\n            o = a(!r.isHidden && r.options.animation),\n            n = r.followPointer || (r.len || 0) > 1,\n            h = {\n              x: t,\n              y: e\n            };\n          n || (h.anchorX = i, h.anchorY = s), o.step = function () {\n            return r.drawTracker();\n          }, r.getLabel().animate(h, o);\n        }\n      }, {\n        key: \"refresh\",\n        value: function refresh(t, e) {\n          var i = this.chart,\n            s = this.options,\n            r = this.pointer,\n            n = this.shared,\n            a = w(t),\n            l = a[0],\n            d = [],\n            c = s.format,\n            p = s.formatter || this.defaultFormatter,\n            u = i.styledMode,\n            g = {},\n            f = this.allowShared;\n          if (!s.enabled || !l.series) return;\n          o.clearTimeout(this.hideTimer), this.allowShared = !(!b(t) && t.series && t.series.noSharedTooltip), f = f && !this.allowShared, this.followPointer = !this.split && l.series.tooltipOptions.followPointer;\n          var m = this.getAnchor(t, e),\n            x = m[0],\n            v = m[1];\n          n && this.allowShared ? (r.applyInactiveState(a), a.forEach(function (t) {\n            t.setState(\"hover\"), d.push(t.getLabelConfig());\n          }), (g = l.getLabelConfig()).points = d) : g = l.getLabelConfig(), this.len = d.length;\n          var C = S(c) ? h(c, g, i) : p.call(g, this),\n            M = l.series;\n          if (this.distance = k(M.tooltipOptions.distance, 16), !1 === C) this.hide();else {\n            if (this.split && this.allowShared) this.renderSplit(C, a);else {\n              var _t42 = x,\n                _o16 = v;\n              if (e && r.isDirectTouch && (_t42 = e.chartX - i.plotLeft, _o16 = e.chartY - i.plotTop), i.polar || !1 === M.options.clip || a.some(function (e) {\n                return r.isDirectTouch || e.series.shouldShowTooltip(_t42, _o16);\n              })) {\n                var _t43 = this.getLabel(f && this.tt || {});\n                (!s.style.width || u) && _t43.css({\n                  width: (this.outside ? this.getPlayingField() : i.spacingBox).width + \"px\"\n                }), _t43.attr({\n                  \"class\": this.getClassName(l),\n                  text: C && C.join ? C.join(\"\") : C\n                }), u || _t43.attr({\n                  stroke: s.borderColor || l.color || M.color || \"#666666\"\n                }), this.updatePosition({\n                  plotX: x,\n                  plotY: v,\n                  negative: l.negative,\n                  ttBelow: l.ttBelow,\n                  h: m[2] || 0\n                });\n              } else {\n                this.hide();\n                return;\n              }\n            }\n            this.isHidden && this.label && this.label.attr({\n              opacity: 1\n            }).show(), this.isHidden = !1;\n          }\n          y(this, \"refresh\");\n        }\n      }, {\n        key: \"renderSplit\",\n        value: function renderSplit(t, e) {\n          var _s$scrollablePlotArea;\n          var i = this,\n            s = i.chart,\n            _i$chart = i.chart,\n            r = _i$chart.chartWidth,\n            o = _i$chart.chartHeight,\n            n = _i$chart.plotHeight,\n            a = _i$chart.plotLeft,\n            h = _i$chart.plotTop,\n            _i$chart$scrollablePi = _i$chart.scrollablePixelsY,\n            l = _i$chart$scrollablePi === void 0 ? 0 : _i$chart$scrollablePi,\n            u = _i$chart.scrollablePixelsX,\n            f = _i$chart.styledMode,\n            m = i.distance,\n            y = i.options,\n            b = i.options.positioner,\n            v = i.pointer,\n            _ref3 = ((_s$scrollablePlotArea = s.scrollablePlotArea) === null || _s$scrollablePlotArea === void 0 ? void 0 : _s$scrollablePlotArea.scrollingContainer) || {},\n            _ref3$scrollLeft = _ref3.scrollLeft,\n            C = _ref3$scrollLeft === void 0 ? 0 : _ref3$scrollLeft,\n            _ref3$scrollTop = _ref3.scrollTop,\n            M = _ref3$scrollTop === void 0 ? 0 : _ref3$scrollTop,\n            w = i.outside && \"number\" != typeof u ? d.documentElement.getBoundingClientRect() : {\n              left: C,\n              right: C + r,\n              top: M,\n              bottom: M + o\n            },\n            A = i.getLabel(),\n            _T2 = this.renderer || s.renderer,\n            P = !!(s.xAxis[0] && s.xAxis[0].opposite),\n            _v$getChartPosition = v.getChartPosition(),\n            L = _v$getChartPosition.left,\n            O = _v$getChartPosition.top,\n            D = h + M,\n            E = 0,\n            I = n - l;\n          function j(t, e, s, r) {\n            var o = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : !0;\n            var n, a;\n            return s ? (n = P ? 0 : I, a = g(t - r / 2, w.left, w.right - r - (i.outside ? L : 0))) : (n = e - D, a = g(a = o ? t - r - m : t + m, o ? a : w.left, w.right)), {\n              x: a,\n              y: n\n            };\n          }\n          S(t) && (t = [!1, t]);\n          var B = t.slice(0, e.length + 1).reduce(function (t, s, r) {\n            if (!1 !== s && \"\" !== s) {\n              var _o17 = e[r - 1] || {\n                  isHeader: !0,\n                  plotX: e[0].plotX,\n                  plotY: n,\n                  series: {}\n                },\n                _l5 = _o17.isHeader,\n                _d4 = _l5 ? i : _o17.series,\n                _c6 = _d4.tt = function (t, e, s) {\n                  var r = t,\n                    o = e.isHeader,\n                    n = e.series;\n                  if (!r) {\n                    var _y$borderWidth;\n                    var _t44 = {\n                      padding: y.padding,\n                      r: y.borderRadius\n                    };\n                    f || (_t44.fill = y.backgroundColor, _t44[\"stroke-width\"] = (_y$borderWidth = y.borderWidth) !== null && _y$borderWidth !== void 0 ? _y$borderWidth : 1), r = _T2.label(\"\", 0, 0, y[o ? \"headerShape\" : \"shape\"], void 0, void 0, y.useHTML).addClass(i.getClassName(e, !0, o)).attr(_t44).add(A);\n                  }\n                  return r.isActive = !0, r.attr({\n                    text: s\n                  }), f || r.css(y.style).attr({\n                    stroke: y.borderColor || e.color || n.color || \"#333333\"\n                  }), r;\n                }(_d4.tt, _o17, s.toString()),\n                _p5 = _c6.getBBox(),\n                _u = _p5.width + _c6.strokeWidth();\n              _l5 && (E = _p5.height, I += E, P && (D -= E));\n              var _ref4 = function (t) {\n                  var e, i;\n                  var s = t.isHeader,\n                    _t$plotX = t.plotX,\n                    r = _t$plotX === void 0 ? 0 : _t$plotX,\n                    _t$plotY = t.plotY,\n                    o = _t$plotY === void 0 ? 0 : _t$plotY,\n                    l = t.series;\n                  if (s) e = Math.max(a + r, a), i = h + n / 2;else {\n                    var _t45 = l.xAxis,\n                      _s26 = l.yAxis;\n                    e = _t45.pos + g(r, -m, _t45.len + m), l.shouldShowTooltip(0, _s26.pos - h + o, {\n                      ignoreX: !0\n                    }) && (i = _s26.pos + o);\n                  }\n                  return {\n                    anchorX: e = g(e, w.left - m, w.right + m),\n                    anchorY: i\n                  };\n                }(_o17),\n                _x2 = _ref4.anchorX,\n                _v3 = _ref4.anchorY;\n              if (\"number\" == typeof _v3) {\n                var _e28 = _p5.height + 1,\n                  _s27 = b ? b.call(i, _u, _e28, _o17) : j(_x2, _v3, _l5, _u);\n                t.push({\n                  align: b ? 0 : void 0,\n                  anchorX: _x2,\n                  anchorY: _v3,\n                  boxWidth: _u,\n                  point: _o17,\n                  rank: k(_s27.rank, _l5 ? 1 : 0),\n                  size: _e28,\n                  target: _s27.y,\n                  tt: _c6,\n                  x: _s27.x\n                });\n              } else _c6.isActive = !1;\n            }\n            return t;\n          }, []);\n          !b && B.some(function (t) {\n            var e = i.outside,\n              s = (e ? L : 0) + t.anchorX;\n            return s < w.left && s + t.boxWidth < w.right || s < L - w.left + t.boxWidth && w.right - s > s;\n          }) && (B = B.map(function (t) {\n            var _j = j(t.anchorX, t.anchorY, t.point.isHeader, t.boxWidth, !1),\n              e = _j.x,\n              i = _j.y;\n            return x(t, {\n              target: i,\n              x: e\n            });\n          })), i.cleanSplit(), p(B, I);\n          var R = {\n            left: L,\n            right: L\n          };\n          B.forEach(function (t) {\n            var e = t.x,\n              s = t.boxWidth,\n              r = t.isHeader;\n            !r && (i.outside && L + e < R.left && (R.left = L + e), !r && i.outside && R.left + s > R.right && (R.right = L + e));\n          }), B.forEach(function (t) {\n            var e = t.x,\n              s = t.anchorX,\n              r = t.anchorY,\n              o = t.pos,\n              n = t.point.isHeader,\n              a = {\n                visibility: void 0 === o ? \"hidden\" : \"inherit\",\n                x: e,\n                y: (o || 0) + D,\n                anchorX: s,\n                anchorY: r\n              };\n            if (i.outside && e < s) {\n              var _t46 = L - R.left;\n              _t46 > 0 && (n || (a.x = e + _t46, a.anchorX = s + _t46), n && (a.x = (R.right - R.left) / 2, a.anchorX = s + _t46));\n            }\n            t.tt.attr(a);\n          });\n          var z = i.container,\n            N = i.outside,\n            W = i.renderer;\n          if (N && z && W) {\n            var _A$getBBox = A.getBBox(),\n              _t47 = _A$getBBox.width,\n              _e29 = _A$getBBox.height,\n              _i25 = _A$getBBox.x,\n              _s28 = _A$getBBox.y;\n            W.setSize(_t47 + _i25, _e29 + _s28, !1), z.style.left = R.left + \"px\", z.style.top = O + \"px\";\n          }\n          c && A.attr({\n            opacity: 1 === A.opacity ? .999 : 1\n          });\n        }\n      }, {\n        key: \"drawTracker\",\n        value: function drawTracker() {\n          if (!this.shouldStickOnContact()) {\n            this.tracker && (this.tracker = this.tracker.destroy());\n            return;\n          }\n          var t = this.chart,\n            e = this.label,\n            i = this.shared ? t.hoverPoints : t.hoverPoint;\n          if (!e || !i) return;\n          var s = {\n              x: 0,\n              y: 0,\n              width: 0,\n              height: 0\n            },\n            r = this.getAnchor(i),\n            o = e.getBBox();\n          r[0] += t.plotLeft - (e.translateX || 0), r[1] += t.plotTop - (e.translateY || 0), s.x = Math.min(0, r[0]), s.y = Math.min(0, r[1]), s.width = r[0] < 0 ? Math.max(Math.abs(r[0]), o.width - r[0]) : Math.max(Math.abs(r[0]), o.width), s.height = r[1] < 0 ? Math.max(Math.abs(r[1]), o.height - Math.abs(r[1])) : Math.max(Math.abs(r[1]), o.height), this.tracker ? this.tracker.attr(s) : (this.tracker = e.renderer.rect(s).addClass(\"highcharts-tracker\").add(e), t.styledMode || this.tracker.attr({\n            fill: \"rgba(0,0,0,0)\"\n          }));\n        }\n      }, {\n        key: \"styledModeFormat\",\n        value: function styledModeFormat(t) {\n          return t.replace('style=\"font-size: 0.8em\"', 'class=\"highcharts-header\"').replace(/style=\"color:{(point|series)\\.color}\"/g, 'class=\"highcharts-color-{$1.colorIndex} {series.options.className} {point.options.className}\"');\n        }\n      }, {\n        key: \"tooltipFooterHeaderFormatter\",\n        value: function tooltipFooterHeaderFormatter(t, e) {\n          var i = t.series,\n            s = i.tooltipOptions,\n            r = i.xAxis,\n            o = r && r.dateTime,\n            n = {\n              isFooter: e,\n              labelConfig: t\n            },\n            a = s.xDateFormat,\n            l = s[e ? \"footerFormat\" : \"headerFormat\"];\n          return y(this, \"headerFormatter\", n, function (e) {\n            o && !a && v(t.key) && (a = o.getXDateFormat(t.key, s.dateTimeLabelFormats)), o && a && (t.point && t.point.tooltipDateKeys || [\"key\"]).forEach(function (t) {\n              l = l.replace(\"{point.\" + t + \"}\", \"{point.\" + t + \":\" + a + \"}\");\n            }), i.chart.styledMode && (l = this.styledModeFormat(l)), e.text = h(l, {\n              point: t,\n              series: i\n            }, this.chart);\n          }), n.text;\n        }\n      }, {\n        key: \"update\",\n        value: function update(t) {\n          this.destroy(), this.init(this.chart, C(!0, this.options, t));\n        }\n      }, {\n        key: \"updatePosition\",\n        value: function updatePosition(t) {\n          var e = this.chart,\n            i = this.container,\n            s = this.distance,\n            r = this.options,\n            o = this.pointer,\n            n = this.renderer,\n            _this$getLabel = this.getLabel(),\n            _this$getLabel$height = _this$getLabel.height,\n            a = _this$getLabel$height === void 0 ? 0 : _this$getLabel$height,\n            _this$getLabel$width = _this$getLabel.width,\n            h = _this$getLabel$width === void 0 ? 0 : _this$getLabel$width,\n            _o$getChartPosition = o.getChartPosition(),\n            l = _o$getChartPosition.left,\n            d = _o$getChartPosition.top,\n            c = _o$getChartPosition.scaleX,\n            p = _o$getChartPosition.scaleY,\n            u = (r.positioner || this.getPosition).call(this, h, a, t),\n            g = (t.plotX || 0) + e.plotLeft,\n            m = (t.plotY || 0) + e.plotTop,\n            x;\n          n && i && (r.positioner && (u.x += l - s, u.y += d - s), x = (r.borderWidth || 0) + 2 * s + 2, n.setSize(h + x, a + x, !1), (1 !== c || 1 !== p) && (f(i, {\n            transform: \"scale(\".concat(c, \", \").concat(p, \")\")\n          }), g *= c, m *= p), g += l - u.x, m += d - u.y), this.move(Math.round(u.x), Math.round(u.y || 0), g, m);\n        }\n      }]);\n    }();\n    return (n = T || (T = {})).compose = function (t) {\n      M(l, \"Core.Tooltip\") && u(t, \"afterInit\", function () {\n        var t = this.chart;\n        t.options.tooltip && (t.tooltip = new n(t, t.options.tooltip, this));\n      });\n    }, T;\n  }), i(e, \"Core/Series/Point.js\", [e[\"Core/Renderer/HTML/AST.js\"], e[\"Core/Animation/AnimationUtilities.js\"], e[\"Core/Defaults.js\"], e[\"Core/Templating.js\"], e[\"Core/Utilities.js\"]], function (t, e, i, s, r) {\n    var o = e.animObject,\n      n = i.defaultOptions,\n      a = s.format,\n      h = r.addEvent,\n      l = r.crisp,\n      d = r.erase,\n      c = r.extend,\n      p = r.fireEvent,\n      u = r.getNestedProperty,\n      g = r.isArray,\n      f = r.isFunction,\n      m = r.isNumber,\n      x = r.isObject,\n      y = r.merge,\n      b = r.pick,\n      v = r.syncTimeout,\n      S = r.removeEvent,\n      C = r.uniqueKey;\n    var k = /*#__PURE__*/function () {\n      function k(t, e, i) {\n        var _this$id;\n        _classCallCheck(this, k);\n        this.formatPrefix = \"point\", this.visible = !0, this.series = t, this.applyOptions(e, i), (_this$id = this.id) !== null && _this$id !== void 0 ? _this$id : this.id = C(), this.resolveColor(), t.chart.pointCount++, p(this, \"afterInit\");\n      }\n      return _createClass(k, [{\n        key: \"animateBeforeDestroy\",\n        value: function animateBeforeDestroy() {\n          var t = this,\n            e = {\n              x: t.startXPos,\n              opacity: 0\n            },\n            i = t.getGraphicalProps();\n          i.singular.forEach(function (i) {\n            t[i] = t[i].animate(\"dataLabel\" === i ? {\n              x: t[i].startXPos,\n              y: t[i].startYPos,\n              opacity: 0\n            } : e);\n          }), i.plural.forEach(function (e) {\n            t[e].forEach(function (e) {\n              e.element && e.animate(c({\n                x: t.startXPos\n              }, e.startYPos ? {\n                x: e.startXPos,\n                y: e.startYPos\n              } : {}));\n            });\n          });\n        }\n      }, {\n        key: \"applyOptions\",\n        value: function applyOptions(t, e) {\n          var i = this.series,\n            s = i.options.pointValKey || i.pointValKey;\n          return c(this, t = k.prototype.optionsToObject.call(this, t)), this.options = this.options ? c(this.options, t) : t, t.group && delete this.group, t.dataLabels && delete this.dataLabels, s && (this.y = k.prototype.getNestedProperty.call(this, s)), this.selected && (this.state = \"select\"), \"name\" in this && void 0 === e && i.xAxis && i.xAxis.hasNames && (this.x = i.xAxis.nameToX(this)), void 0 === this.x && i ? this.x = e !== null && e !== void 0 ? e : i.autoIncrement() : m(t.x) && i.options.relativeXValue && (this.x = i.autoIncrement(t.x)), this.isNull = this.isValid && !this.isValid(), this.formatPrefix = this.isNull ? \"null\" : \"point\", this;\n        }\n      }, {\n        key: \"destroy\",\n        value: function destroy() {\n          if (!this.destroyed) {\n            var _t48 = this,\n              _e30 = _t48.series,\n              _i26 = _e30.chart,\n              _s29 = _e30.options.dataSorting,\n              _r13 = _i26.hoverPoints,\n              _n8 = o(_t48.series.chart.renderer.globalAnimation),\n              _a11 = function _a11() {\n                for (var _e31 in (_t48.graphic || _t48.graphics || _t48.dataLabel || _t48.dataLabels) && (S(_t48), _t48.destroyElements()), _t48) delete _t48[_e31];\n              };\n            _t48.legendItem && _i26.legend.destroyItem(_t48), _r13 && (_t48.setState(), d(_r13, _t48), _r13.length || (_i26.hoverPoints = null)), _t48 === _i26.hoverPoint && _t48.onMouseOut(), _s29 && _s29.enabled ? (this.animateBeforeDestroy(), v(_a11, _n8.duration)) : _a11(), _i26.pointCount--;\n          }\n          this.destroyed = !0;\n        }\n      }, {\n        key: \"destroyElements\",\n        value: function destroyElements(t) {\n          var e = this,\n            i = e.getGraphicalProps(t);\n          i.singular.forEach(function (t) {\n            e[t] = e[t].destroy();\n          }), i.plural.forEach(function (t) {\n            e[t].forEach(function (t) {\n              t && t.element && t.destroy();\n            }), delete e[t];\n          });\n        }\n      }, {\n        key: \"firePointEvent\",\n        value: function firePointEvent(t, e, i) {\n          var s = this,\n            r = this.series.options;\n          s.manageEvent(t), \"click\" === t && r.allowPointSelect && (i = function i(t) {\n            !s.destroyed && s.select && s.select(null, t.ctrlKey || t.metaKey || t.shiftKey);\n          }), p(s, t, e, i);\n        }\n      }, {\n        key: \"getClassName\",\n        value: function getClassName() {\n          return \"highcharts-point\" + (this.selected ? \" highcharts-point-select\" : \"\") + (this.negative ? \" highcharts-negative\" : \"\") + (this.isNull ? \" highcharts-null-point\" : \"\") + (void 0 !== this.colorIndex ? \" highcharts-color-\" + this.colorIndex : \"\") + (this.options.className ? \" \" + this.options.className : \"\") + (this.zone && this.zone.className ? \" \" + this.zone.className.replace(\"highcharts-negative\", \"\") : \"\");\n        }\n      }, {\n        key: \"getGraphicalProps\",\n        value: function getGraphicalProps(t) {\n          var e, i;\n          var s = this,\n            r = [],\n            o = {\n              singular: [],\n              plural: []\n            };\n          for ((t = t || {\n            graphic: 1,\n            dataLabel: 1\n          }).graphic && r.push(\"graphic\", \"connector\"), t.dataLabel && r.push(\"dataLabel\", \"dataLabelPath\", \"dataLabelUpper\"), i = r.length; i--;) s[e = r[i]] && o.singular.push(e);\n          return [\"graphic\", \"dataLabel\"].forEach(function (e) {\n            var i = e + \"s\";\n            t[e] && s[i] && o.plural.push(i);\n          }), o;\n        }\n      }, {\n        key: \"getLabelConfig\",\n        value: function getLabelConfig() {\n          return {\n            x: this.category,\n            y: this.y,\n            color: this.color,\n            colorIndex: this.colorIndex,\n            key: this.name || this.category,\n            series: this.series,\n            point: this,\n            percentage: this.percentage,\n            total: this.total || this.stackTotal\n          };\n        }\n      }, {\n        key: \"getNestedProperty\",\n        value: function getNestedProperty(t) {\n          return t ? 0 === t.indexOf(\"custom.\") ? u(t, this.options) : this[t] : void 0;\n        }\n      }, {\n        key: \"getZone\",\n        value: function getZone() {\n          var t = this.series,\n            e = t.zones,\n            i = t.zoneAxis || \"y\",\n            s,\n            r = 0;\n          for (s = e[0]; this[i] >= s.value;) s = e[++r];\n          return this.nonZonedColor || (this.nonZonedColor = this.color), s && s.color && !this.options.color ? this.color = s.color : this.color = this.nonZonedColor, s;\n        }\n      }, {\n        key: \"hasNewShapeType\",\n        value: function hasNewShapeType() {\n          return (this.graphic && (this.graphic.symbolName || this.graphic.element.nodeName)) !== this.shapeType;\n        }\n      }, {\n        key: \"isValid\",\n        value: function isValid() {\n          return (m(this.x) || this.x instanceof Date) && m(this.y);\n        }\n      }, {\n        key: \"optionsToObject\",\n        value: function optionsToObject(t) {\n          var e = this.series,\n            i = e.options.keys,\n            s = i || e.pointArrayMap || [\"y\"],\n            r = s.length,\n            o = {},\n            n,\n            a = 0,\n            h = 0;\n          if (m(t) || null === t) o[s[0]] = t;else if (g(t)) for (!i && t.length > r && (\"string\" == (n = _typeof(t[0])) ? o.name = t[0] : \"number\" === n && (o.x = t[0]), a++); h < r;) i && void 0 === t[a] || (s[h].indexOf(\".\") > 0 ? k.prototype.setNestedProperty(o, t[a], s[h]) : o[s[h]] = t[a]), a++, h++;else \"object\" == _typeof(t) && (o = t, t.dataLabels && (e.hasDataLabels = function () {\n            return !0;\n          }), t.marker && (e._hasPointMarkers = !0));\n          return o;\n        }\n      }, {\n        key: \"pos\",\n        value: function pos(t) {\n          var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.plotY;\n          if (!this.destroyed) {\n            var _i27 = this.plotX,\n              _s30 = this.series,\n              _r14 = _s30.chart,\n              _o18 = _s30.xAxis,\n              _n9 = _s30.yAxis,\n              _a12 = 0,\n              _h6 = 0;\n            if (m(_i27) && m(e)) return t && (_a12 = _o18 ? _o18.pos : _r14.plotLeft, _h6 = _n9 ? _n9.pos : _r14.plotTop), _r14.inverted && _o18 && _n9 ? [_n9.len - e + _h6, _o18.len - _i27 + _a12] : [_i27 + _a12, e + _h6];\n          }\n        }\n      }, {\n        key: \"resolveColor\",\n        value: function resolveColor() {\n          var t = this.series,\n            e = t.chart.options.chart,\n            i = t.chart.styledMode,\n            s,\n            r,\n            o = e.colorCount,\n            n;\n          delete this.nonZonedColor, t.options.colorByPoint ? (i || (s = (r = t.options.colors || t.chart.options.colors)[t.colorCounter], o = r.length), n = t.colorCounter, t.colorCounter++, t.colorCounter === o && (t.colorCounter = 0)) : (i || (s = t.color), n = t.colorIndex), this.colorIndex = b(this.options.colorIndex, n), this.color = b(this.options.color, s);\n        }\n      }, {\n        key: \"setNestedProperty\",\n        value: function setNestedProperty(t, e, i) {\n          return i.split(\".\").reduce(function (t, i, s, r) {\n            var o = r.length - 1 === s;\n            return t[i] = o ? e : x(t[i], !0) ? t[i] : {}, t[i];\n          }, t), t;\n        }\n      }, {\n        key: \"shouldDraw\",\n        value: function shouldDraw() {\n          return !this.isNull;\n        }\n      }, {\n        key: \"tooltipFormatter\",\n        value: function tooltipFormatter(t) {\n          var e = this.series,\n            i = e.tooltipOptions,\n            s = b(i.valueDecimals, \"\"),\n            r = i.valuePrefix || \"\",\n            o = i.valueSuffix || \"\";\n          return e.chart.styledMode && (t = e.chart.tooltip.styledModeFormat(t)), (e.pointArrayMap || [\"y\"]).forEach(function (e) {\n            e = \"{point.\" + e, (r || o) && (t = t.replace(RegExp(e + \"}\", \"g\"), r + e + \"}\" + o)), t = t.replace(RegExp(e + \"}\", \"g\"), e + \":,.\" + s + \"f}\");\n          }), a(t, {\n            point: this,\n            series: this.series\n          }, e.chart);\n        }\n      }, {\n        key: \"update\",\n        value: function update(t, e, i, s) {\n          var r;\n          var o = this,\n            n = o.series,\n            a = o.graphic,\n            h = n.chart,\n            l = n.options;\n          function d() {\n            o.applyOptions(t);\n            var s = a && o.hasMockGraphic,\n              d = null === o.y ? !s : s;\n            a && d && (o.graphic = a.destroy(), delete o.hasMockGraphic), x(t, !0) && (a && a.element && t && t.marker && void 0 !== t.marker.symbol && (o.graphic = a.destroy()), t !== null && t !== void 0 && t.dataLabels && o.dataLabel && (o.dataLabel = o.dataLabel.destroy())), r = o.index, n.updateParallelArrays(o, r), l.data[r] = x(l.data[r], !0) || x(t, !0) ? o.options : b(t, l.data[r]), n.isDirty = n.isDirtyData = !0, !n.fixedBox && n.hasCartesianSeries && (h.isDirtyBox = !0), \"point\" === l.legendType && (h.isDirtyLegend = !0), e && h.redraw(i);\n          }\n          e = b(e, !0), !1 === s ? d() : o.firePointEvent(\"update\", {\n            options: t\n          }, d);\n        }\n      }, {\n        key: \"remove\",\n        value: function remove(t, e) {\n          this.series.removePoint(this.series.data.indexOf(this), t, e);\n        }\n      }, {\n        key: \"select\",\n        value: function select(t, e) {\n          var i = this,\n            s = i.series,\n            r = s.chart;\n          t = b(t, !i.selected), this.selectedStaging = t, i.firePointEvent(t ? \"select\" : \"unselect\", {\n            accumulate: e\n          }, function () {\n            i.selected = i.options.selected = t, s.options.data[s.data.indexOf(i)] = i.options, i.setState(t && \"select\"), e || r.getSelectedPoints().forEach(function (t) {\n              var e = t.series;\n              t.selected && t !== i && (t.selected = t.options.selected = !1, e.options.data[e.data.indexOf(t)] = t.options, t.setState(r.hoverPoints && e.options.inactiveOtherPoints ? \"inactive\" : \"\"), t.firePointEvent(\"unselect\"));\n            });\n          }), delete this.selectedStaging;\n        }\n      }, {\n        key: \"onMouseOver\",\n        value: function onMouseOver(t) {\n          var _this$series$chart = this.series.chart,\n            e = _this$series$chart.inverted,\n            i = _this$series$chart.pointer;\n          i && (t = t ? i.normalize(t) : i.getChartCoordinatesFromPoint(this, e), i.runPointActions(t, this));\n        }\n      }, {\n        key: \"onMouseOut\",\n        value: function onMouseOut() {\n          var t = this.series.chart;\n          this.firePointEvent(\"mouseOut\"), this.series.options.inactiveOtherPoints || (t.hoverPoints || []).forEach(function (t) {\n            t.setState();\n          }), t.hoverPoints = t.hoverPoint = null;\n        }\n      }, {\n        key: \"manageEvent\",\n        value: function manageEvent(t) {\n          var _e$events, _this$hcEvents, _this$hcEvents2, _this$importedUserEve, _this$hcEvents3;\n          var e = y(this.series.options.point, this.options),\n            i = (_e$events = e.events) === null || _e$events === void 0 ? void 0 : _e$events[t];\n          f(i) && (!((_this$hcEvents = this.hcEvents) !== null && _this$hcEvents !== void 0 && _this$hcEvents[t]) || ((_this$hcEvents2 = this.hcEvents) === null || _this$hcEvents2 === void 0 || (_this$hcEvents2 = _this$hcEvents2[t]) === null || _this$hcEvents2 === void 0 ? void 0 : _this$hcEvents2.map(function (t) {\n            return t.fn;\n          }).indexOf(i)) === -1) ? ((_this$importedUserEve = this.importedUserEvent) !== null && _this$importedUserEve !== void 0 && _this$importedUserEve.call(this), this.importedUserEvent = h(this, t, i)) : this.importedUserEvent && !i && ((_this$hcEvents3 = this.hcEvents) === null || _this$hcEvents3 === void 0 ? void 0 : _this$hcEvents3[t]) && (S(this, t), delete this.hcEvents[t], Object.keys(this.hcEvents) || delete this.importedUserEvent);\n        }\n      }, {\n        key: \"setState\",\n        value: function setState(e, i) {\n          var _x3;\n          var s = this.series,\n            r = this.state,\n            o = s.options.states[e || \"normal\"] || {},\n            a = n.plotOptions[s.type].marker && s.options.marker,\n            h = a && !1 === a.enabled,\n            l = a && a.states && a.states[e || \"normal\"] || {},\n            d = !1 === l.enabled,\n            u = this.marker || {},\n            g = s.chart,\n            f = a && s.markerAttribs,\n            x = s.halo,\n            y,\n            v,\n            S,\n            C = s.stateMarkerGraphic,\n            _k;\n          if ((e = e || \"\") === this.state && !i || this.selected && \"select\" !== e || !1 === o.enabled || e && (d || h && !1 === l.enabled) || e && u.states && u.states[e] && !1 === u.states[e].enabled) return;\n          if (this.state = e, f && (y = s.markerAttribs(this, e)), this.graphic && !this.hasMockGraphic) {\n            if (r && this.graphic.removeClass(\"highcharts-point-\" + r), e && this.graphic.addClass(\"highcharts-point-\" + e), !g.styledMode) {\n              v = s.pointAttribs(this, e), S = b(g.options.chart.animation, o.animation);\n              var _t49 = v.opacity;\n              s.options.inactiveOtherPoints && m(_t49) && (this.dataLabels || []).forEach(function (e) {\n                e && !e.hasClass(\"highcharts-data-label-hidden\") && (e.animate({\n                  opacity: _t49\n                }, S), e.connector && e.connector.animate({\n                  opacity: _t49\n                }, S));\n              }), this.graphic.animate(v, S);\n            }\n            y && this.graphic.animate(y, b(g.options.chart.animation, l.animation, a.animation)), C && C.hide();\n          } else e && l && (_k = u.symbol || s.symbol, C && C.currentSymbol !== _k && (C = C.destroy()), y && (C ? C[i ? \"animate\" : \"attr\"]({\n            x: y.x,\n            y: y.y\n          }) : _k && (s.stateMarkerGraphic = C = g.renderer.symbol(_k, y.x, y.y, y.width, y.height).add(s.markerGroup), C.currentSymbol = _k)), !g.styledMode && C && \"inactive\" !== this.state && C.attr(s.pointAttribs(this, e))), C && (C[e && this.isInside ? \"show\" : \"hide\"](), C.element.point = this, C.addClass(this.getClassName(), !0));\n          var M = o.halo,\n            w = this.graphic || C,\n            A = w && w.visibility || \"inherit\";\n          M && M.size && w && \"hidden\" !== A && !this.isCluster ? (x || (s.halo = x = g.renderer.path().add(w.parentGroup)), x.show()[i ? \"animate\" : \"attr\"]({\n            d: this.haloPath(M.size)\n          }), x.attr({\n            \"class\": \"highcharts-halo highcharts-color-\" + b(this.colorIndex, s.colorIndex) + (this.className ? \" \" + this.className : \"\"),\n            visibility: A,\n            zIndex: -1\n          }), x.point = this, g.styledMode || x.attr(c({\n            fill: this.color || s.color,\n            \"fill-opacity\": M.opacity\n          }, t.filterUserAttributes(M.attributes || {})))) : ((_x3 = x) === null || _x3 === void 0 || (_x3 = _x3.point) === null || _x3 === void 0 ? void 0 : _x3.haloPath) && !x.point.destroyed && x.animate({\n            d: x.point.haloPath(0)\n          }, null, x.hide), p(this, \"afterSetState\", {\n            state: e\n          });\n        }\n      }, {\n        key: \"haloPath\",\n        value: function haloPath(t) {\n          var e = this.pos();\n          return e ? this.series.chart.renderer.symbols.circle(l(e[0], 1) - t, e[1] - t, 2 * t, 2 * t) : [];\n        }\n      }]);\n    }();\n    return k;\n  }), i(e, \"Core/Pointer.js\", [e[\"Core/Color/Color.js\"], e[\"Core/Globals.js\"], e[\"Core/Utilities.js\"]], function (t, e, i) {\n    var s;\n    var r = t.parse,\n      o = e.charts,\n      n = e.composed,\n      a = e.isTouchDevice,\n      h = i.addEvent,\n      l = i.attr,\n      d = i.css,\n      c = i.extend,\n      p = i.find,\n      u = i.fireEvent,\n      g = i.isNumber,\n      f = i.isObject,\n      m = i.objectEach,\n      x = i.offset,\n      y = i.pick,\n      b = i.pushUnique,\n      v = i.splat;\n    var S = /*#__PURE__*/function () {\n      function S(t, e) {\n        var _e$chart$events;\n        _classCallCheck(this, S);\n        this.hasDragged = 0, this.pointerCaptureEventsToUnbind = [], this.eventsToUnbind = [], this.options = e, this.chart = t, this.runChartClick = !!((_e$chart$events = e.chart.events) !== null && _e$chart$events !== void 0 && _e$chart$events.click), this.pinchDown = [], this.setDOMEvents(), u(this, \"afterInit\");\n      }\n      return _createClass(S, [{\n        key: \"applyInactiveState\",\n        value: function applyInactiveState(t) {\n          var e = [],\n            i;\n          (t || []).forEach(function (t) {\n            i = t.series, e.push(i), i.linkedParent && e.push(i.linkedParent), i.linkedSeries && (e = e.concat(i.linkedSeries)), i.navigatorSeries && e.push(i.navigatorSeries);\n          }), this.chart.series.forEach(function (t) {\n            -1 === e.indexOf(t) ? t.setState(\"inactive\", !0) : t.options.inactiveOtherPoints && t.setAllPointsToState(\"inactive\");\n          });\n        }\n      }, {\n        key: \"destroy\",\n        value: function destroy() {\n          var t = this;\n          this.eventsToUnbind.forEach(function (t) {\n            return t();\n          }), this.eventsToUnbind = [], !e.chartCount && (S.unbindDocumentMouseUp && S.unbindDocumentMouseUp.forEach(function (t) {\n            return t();\n          }), S.unbindDocumentTouchEnd && (S.unbindDocumentTouchEnd = S.unbindDocumentTouchEnd())), clearInterval(t.tooltipTimeout), m(t, function (e, i) {\n            t[i] = void 0;\n          });\n        }\n      }, {\n        key: \"getSelectionMarkerAttrs\",\n        value: function getSelectionMarkerAttrs(t, e) {\n          var _this10 = this;\n          var i = {\n            args: {\n              chartX: t,\n              chartY: e\n            },\n            attrs: {},\n            shapeType: \"rect\"\n          };\n          return u(this, \"getSelectionMarkerAttrs\", i, function (i) {\n            var s;\n            var r = _this10.chart,\n              o = _this10.zoomHor,\n              n = _this10.zoomVert,\n              _r$mouseDownX = r.mouseDownX,\n              a = _r$mouseDownX === void 0 ? 0 : _r$mouseDownX,\n              _r$mouseDownY = r.mouseDownY,\n              h = _r$mouseDownY === void 0 ? 0 : _r$mouseDownY,\n              l = i.attrs;\n            l.x = r.plotLeft, l.y = r.plotTop, l.width = o ? 1 : r.plotWidth, l.height = n ? 1 : r.plotHeight, o && (s = t - a, l.width = Math.max(1, Math.abs(s)), l.x = (s > 0 ? 0 : s) + a), n && (s = e - h, l.height = Math.max(1, Math.abs(s)), l.y = (s > 0 ? 0 : s) + h);\n          }), i;\n        }\n      }, {\n        key: \"drag\",\n        value: function drag(t) {\n          var e = this.chart,\n            _e$mouseDownX = e.mouseDownX,\n            i = _e$mouseDownX === void 0 ? 0 : _e$mouseDownX,\n            _e$mouseDownY = e.mouseDownY,\n            s = _e$mouseDownY === void 0 ? 0 : _e$mouseDownY,\n            _e$options$chart = e.options.chart,\n            o = _e$options$chart.panning,\n            n = _e$options$chart.panKey,\n            a = _e$options$chart.selectionMarkerFill,\n            h = e.plotLeft,\n            l = e.plotTop,\n            d = e.plotWidth,\n            c = e.plotHeight,\n            p = f(o) ? o.enabled : o,\n            u = n && t[\"\".concat(n, \"Key\")],\n            g = t.chartX,\n            m = t.chartY,\n            x,\n            y = this.selectionMarker;\n          if ((!y || !y.touch) && (g < h ? g = h : g > h + d && (g = h + d), m < l ? m = l : m > l + c && (m = l + c), this.hasDragged = Math.sqrt(Math.pow(i - g, 2) + Math.pow(s - m, 2)), this.hasDragged > 10)) {\n            x = e.isInsidePlot(i - h, s - l, {\n              visiblePlotOnly: !0\n            });\n            var _this$getSelectionMar = this.getSelectionMarkerAttrs(g, m),\n              _n10 = _this$getSelectionMar.shapeType,\n              _d5 = _this$getSelectionMar.attrs;\n            (e.hasCartesianSeries || e.mapView) && this.hasZoom && x && !u && !y && (this.selectionMarker = y = e.renderer[_n10](), y.attr({\n              \"class\": \"highcharts-selection-marker\",\n              zIndex: 7\n            }).add(), e.styledMode || y.attr({\n              fill: a || r(\"#334eff\").setOpacity(.25).get()\n            })), y && y.attr(_d5), x && !y && p && e.pan(t, o);\n          }\n        }\n      }, {\n        key: \"dragStart\",\n        value: function dragStart(t) {\n          var e = this.chart;\n          e.mouseIsDown = t.type, e.cancelClick = !1, e.mouseDownX = t.chartX, e.mouseDownY = t.chartY;\n        }\n      }, {\n        key: \"getSelectionBox\",\n        value: function getSelectionBox(t) {\n          var e = {\n            args: {\n              marker: t\n            },\n            result: t.getBBox()\n          };\n          return u(this, \"getSelectionBox\", e), e.result;\n        }\n      }, {\n        key: \"drop\",\n        value: function drop(t) {\n          var _this11 = this;\n          var e;\n          var i = this.chart,\n            s = this.selectionMarker;\n          var _iterator4 = _createForOfIteratorHelper(i.axes),\n            _step4;\n          try {\n            for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n              var _t50 = _step4.value;\n              _t50.isPanning && (_t50.isPanning = !1, (_t50.options.startOnTick || _t50.options.endOnTick || _t50.series.some(function (t) {\n                return t.boosted;\n              })) && (_t50.forceRedraw = !0, _t50.setExtremes(_t50.userMin, _t50.userMax, !1), e = !0));\n            }\n          } catch (err) {\n            _iterator4.e(err);\n          } finally {\n            _iterator4.f();\n          }\n          if (e && i.redraw(), s && t) {\n            if (this.hasDragged) {\n              var _e32 = this.getSelectionBox(s);\n              i.transform({\n                axes: i.axes.filter(function (t) {\n                  return t.zoomEnabled && (\"xAxis\" === t.coll && _this11.zoomX || \"yAxis\" === t.coll && _this11.zoomY);\n                }),\n                selection: _objectSpread({\n                  originalEvent: t,\n                  xAxis: [],\n                  yAxis: []\n                }, _e32),\n                from: _e32\n              });\n            }\n            g(i.index) && (this.selectionMarker = s.destroy());\n          }\n          i && g(i.index) && (d(i.container, {\n            cursor: i._cursor\n          }), i.cancelClick = this.hasDragged > 10, i.mouseIsDown = !1, this.hasDragged = 0, this.pinchDown = []);\n        }\n      }, {\n        key: \"findNearestKDPoint\",\n        value: function findNearestKDPoint(t, e, i) {\n          var s;\n          return t.forEach(function (t) {\n            var r = !(t.noSharedTooltip && e) && 0 > t.options.findNearestPointBy.indexOf(\"y\"),\n              o = t.searchPoint(i, r);\n            f(o, !0) && o.series && (!f(s, !0) || function (t, i, _i$series$group, _t$series$group) {\n              var s = t.distX - i.distX,\n                r = t.dist - i.dist,\n                o = ((_i$series$group = i.series.group) === null || _i$series$group === void 0 ? void 0 : _i$series$group.zIndex) - ((_t$series$group = t.series.group) === null || _t$series$group === void 0 ? void 0 : _t$series$group.zIndex);\n              return 0 !== s && e ? s : 0 !== r ? r : 0 !== o ? o : t.series.index > i.series.index ? -1 : 1;\n            }(s, o) > 0) && (s = o);\n          }), s;\n        }\n      }, {\n        key: \"getChartCoordinatesFromPoint\",\n        value: function getChartCoordinatesFromPoint(t, e) {\n          var _t$series = t.series,\n            i = _t$series.xAxis,\n            s = _t$series.yAxis,\n            r = t.shapeArgs;\n          if (i && s) {\n            var _ref5, _t$clientX;\n            var _o19 = (_ref5 = (_t$clientX = t.clientX) !== null && _t$clientX !== void 0 ? _t$clientX : t.plotX) !== null && _ref5 !== void 0 ? _ref5 : 0,\n              _n11 = t.plotY || 0;\n            return t.isNode && r && g(r.x) && g(r.y) && (_o19 = r.x, _n11 = r.y), e ? {\n              chartX: s.len + s.pos - _n11,\n              chartY: i.len + i.pos - _o19\n            } : {\n              chartX: _o19 + i.pos,\n              chartY: _n11 + s.pos\n            };\n          }\n          if (r && r.x && r.y) return {\n            chartX: r.x,\n            chartY: r.y\n          };\n        }\n      }, {\n        key: \"getChartPosition\",\n        value: function getChartPosition() {\n          if (this.chartPosition) return this.chartPosition;\n          var t = this.chart.container,\n            e = x(t);\n          this.chartPosition = {\n            left: e.left,\n            top: e.top,\n            scaleX: 1,\n            scaleY: 1\n          };\n          var i = t.offsetHeight,\n            s = t.offsetWidth;\n          return s > 2 && i > 2 && (this.chartPosition.scaleX = e.width / s, this.chartPosition.scaleY = e.height / i), this.chartPosition;\n        }\n      }, {\n        key: \"getCoordinates\",\n        value: function getCoordinates(t) {\n          var e = {\n            xAxis: [],\n            yAxis: []\n          };\n          var _iterator5 = _createForOfIteratorHelper(this.chart.axes),\n            _step5;\n          try {\n            for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n              var _i28 = _step5.value;\n              e[_i28.isXAxis ? \"xAxis\" : \"yAxis\"].push({\n                axis: _i28,\n                value: _i28.toValue(t[_i28.horiz ? \"chartX\" : \"chartY\"])\n              });\n            }\n          } catch (err) {\n            _iterator5.e(err);\n          } finally {\n            _iterator5.f();\n          }\n          return e;\n        }\n      }, {\n        key: \"getHoverData\",\n        value: function getHoverData(t, e, i, s, r, o) {\n          var n = [],\n            a = function a(t) {\n              return t.visible && !(!r && t.directTouch) && y(t.options.enableMouseTracking, !0);\n            },\n            h = e,\n            l,\n            d = {\n              chartX: o ? o.chartX : void 0,\n              chartY: o ? o.chartY : void 0,\n              shared: r\n            };\n          u(this, \"beforeGetHoverData\", d), l = h && !h.stickyTracking ? [h] : i.filter(function (t) {\n            return t.stickyTracking && (d.filter || a)(t);\n          });\n          var c = s && t || !o ? t : this.findNearestKDPoint(l, r, o);\n          return h = c && c.series, c && (r && !h.noSharedTooltip ? (l = i.filter(function (t) {\n            return d.filter ? d.filter(t) : a(t) && !t.noSharedTooltip;\n          })).forEach(function (t) {\n            var e = p(t.points, function (t) {\n              return t.x === c.x && !t.isNull;\n            });\n            f(e) && (t.boosted && t.boost && (e = t.boost.getPoint(e)), n.push(e));\n          }) : n.push(c)), u(this, \"afterGetHoverData\", d = {\n            hoverPoint: c\n          }), {\n            hoverPoint: d.hoverPoint,\n            hoverSeries: h,\n            hoverPoints: n\n          };\n        }\n      }, {\n        key: \"getPointFromEvent\",\n        value: function getPointFromEvent(t) {\n          var e = t.target,\n            i;\n          for (; e && !i;) i = e.point, e = e.parentNode;\n          return i;\n        }\n      }, {\n        key: \"onTrackerMouseOut\",\n        value: function onTrackerMouseOut(t) {\n          var e = this.chart,\n            i = t.relatedTarget,\n            s = e.hoverSeries;\n          this.isDirectTouch = !1, !s || !i || s.stickyTracking || this.inClass(i, \"highcharts-tooltip\") || this.inClass(i, \"highcharts-series-\" + s.index) && this.inClass(i, \"highcharts-tracker\") || s.onMouseOut();\n        }\n      }, {\n        key: \"inClass\",\n        value: function inClass(t, e) {\n          var i = t,\n            s;\n          for (; i;) {\n            if (s = l(i, \"class\")) {\n              if (-1 !== s.indexOf(e)) return !0;\n              if (-1 !== s.indexOf(\"highcharts-container\")) return !1;\n            }\n            i = i.parentElement;\n          }\n        }\n      }, {\n        key: \"normalize\",\n        value: function normalize(t, e) {\n          var i = t.touches,\n            s = i ? i.length ? i.item(0) : y(i.changedTouches, t.changedTouches)[0] : t;\n          e || (e = this.getChartPosition());\n          var r = s.pageX - e.left,\n            o = s.pageY - e.top;\n          return c(t, {\n            chartX: Math.round(r /= e.scaleX),\n            chartY: Math.round(o /= e.scaleY)\n          });\n        }\n      }, {\n        key: \"onContainerClick\",\n        value: function onContainerClick(t) {\n          var e = this.chart,\n            i = e.hoverPoint,\n            s = this.normalize(t),\n            r = e.plotLeft,\n            o = e.plotTop;\n          !e.cancelClick && (i && this.inClass(s.target, \"highcharts-tracker\") ? (u(i.series, \"click\", c(s, {\n            point: i\n          })), e.hoverPoint && i.firePointEvent(\"click\", s)) : (c(s, this.getCoordinates(s)), e.isInsidePlot(s.chartX - r, s.chartY - o, {\n            visiblePlotOnly: !0\n          }) && u(e, \"click\", s)));\n        }\n      }, {\n        key: \"onContainerMouseDown\",\n        value: function onContainerMouseDown(t) {\n          var _t$preventDefault, _t51;\n          var i = (1 & (t.buttons || t.button)) == 1;\n          t = this.normalize(t), e.isFirefox && 0 !== t.button && this.onContainerMouseMove(t), (void 0 === t.button || i) && (this.zoomOption(t), i && (_t$preventDefault = (_t51 = t).preventDefault) !== null && _t$preventDefault !== void 0 && _t$preventDefault.call(_t51), this.dragStart(t));\n        }\n      }, {\n        key: \"onContainerMouseLeave\",\n        value: function onContainerMouseLeave(t) {\n          var _ref6 = o[y(S.hoverChartIndex, -1)] || {},\n            e = _ref6.pointer;\n          t = this.normalize(t), this.onContainerMouseMove(t), e && !this.inClass(t.relatedTarget, \"highcharts-tooltip\") && (e.reset(), e.chartPosition = void 0);\n        }\n      }, {\n        key: \"onContainerMouseEnter\",\n        value: function onContainerMouseEnter() {\n          delete this.chartPosition;\n        }\n      }, {\n        key: \"onContainerMouseMove\",\n        value: function onContainerMouseMove(t) {\n          var e = this.chart,\n            i = e.tooltip,\n            s = this.normalize(t);\n          this.setHoverChartIndex(t), (\"mousedown\" === e.mouseIsDown || this.touchSelect(s)) && this.drag(s), !e.openMenu && (this.inClass(s.target, \"highcharts-tracker\") || e.isInsidePlot(s.chartX - e.plotLeft, s.chartY - e.plotTop, {\n            visiblePlotOnly: !0\n          })) && !(i && i.shouldStickOnContact(s)) && (this.inClass(s.target, \"highcharts-no-tooltip\") ? this.reset(!1, 0) : this.runPointActions(s));\n        }\n      }, {\n        key: \"onDocumentTouchEnd\",\n        value: function onDocumentTouchEnd(t) {\n          this.onDocumentMouseUp(t);\n        }\n      }, {\n        key: \"onContainerTouchMove\",\n        value: function onContainerTouchMove(t) {\n          this.touchSelect(t) ? this.onContainerMouseMove(t) : this.touch(t);\n        }\n      }, {\n        key: \"onContainerTouchStart\",\n        value: function onContainerTouchStart(t) {\n          this.touchSelect(t) ? this.onContainerMouseDown(t) : (this.zoomOption(t), this.touch(t, !0));\n        }\n      }, {\n        key: \"onDocumentMouseMove\",\n        value: function onDocumentMouseMove(t) {\n          var e = this.chart,\n            i = e.tooltip,\n            s = this.chartPosition,\n            r = this.normalize(t, s);\n          !s || e.isInsidePlot(r.chartX - e.plotLeft, r.chartY - e.plotTop, {\n            visiblePlotOnly: !0\n          }) || i && i.shouldStickOnContact(r) || r.target !== e.container.ownerDocument && this.inClass(r.target, \"highcharts-tracker\") || this.reset();\n        }\n      }, {\n        key: \"onDocumentMouseUp\",\n        value: function onDocumentMouseUp(t) {\n          var _o$y;\n          (_o$y = o[y(S.hoverChartIndex, -1)]) === null || _o$y === void 0 || (_o$y = _o$y.pointer) === null || _o$y === void 0 || _o$y.drop(t);\n        }\n      }, {\n        key: \"pinch\",\n        value: function pinch(t) {\n          var _this12 = this;\n          var e = this,\n            i = e.chart,\n            s = e.hasZoom,\n            r = e.lastTouches,\n            o = [].map.call(t.touches || [], function (t) {\n              return e.normalize(t);\n            }),\n            n = o.length,\n            a = 1 === n && (e.inClass(t.target, \"highcharts-tracker\") && i.runTrackerClick || e.runChartClick),\n            h = i.tooltip,\n            l = 1 === n && y(h === null || h === void 0 ? void 0 : h.options.followTouchMove, !0);\n          n > 1 ? e.initiated = !0 : l && (e.initiated = !1), s && e.initiated && !a && !1 !== t.cancelable && t.preventDefault(), \"touchstart\" === t.type ? (e.pinchDown = o, e.res = !0, i.mouseDownX = t.chartX) : l ? this.runPointActions(e.normalize(t)) : r && (u(i, \"touchpan\", {\n            originalEvent: t,\n            touches: o\n          }, function () {\n            var e = function e(t) {\n              var e = t[0],\n                i = t[1] || e;\n              return {\n                x: e.chartX,\n                y: e.chartY,\n                width: i.chartX - e.chartX,\n                height: i.chartY - e.chartY\n              };\n            };\n            i.transform({\n              axes: i.axes.filter(function (t) {\n                return t.zoomEnabled && (_this12.zoomHor && t.horiz || _this12.zoomVert && !t.horiz);\n              }),\n              to: e(o),\n              from: e(r),\n              trigger: t.type\n            });\n          }), e.res && (e.res = !1, this.reset(!1, 0))), e.lastTouches = o;\n        }\n      }, {\n        key: \"reset\",\n        value: function reset(t, e) {\n          var i = this.chart,\n            s = i.hoverSeries,\n            r = i.hoverPoint,\n            o = i.hoverPoints,\n            n = i.tooltip,\n            a = n && n.shared ? o : r;\n          t && a && v(a).forEach(function (e) {\n            e.series.isCartesian && void 0 === e.plotX && (t = !1);\n          }), t ? n && a && v(a).length && (n.refresh(a), n.shared && o ? o.forEach(function (t) {\n            t.setState(t.state, !0), t.series.isCartesian && (t.series.xAxis.crosshair && t.series.xAxis.drawCrosshair(null, t), t.series.yAxis.crosshair && t.series.yAxis.drawCrosshair(null, t));\n          }) : r && (r.setState(r.state, !0), i.axes.forEach(function (t) {\n            t.crosshair && r.series[t.coll] === t && t.drawCrosshair(null, r);\n          }))) : (r && r.onMouseOut(), o && o.forEach(function (t) {\n            t.setState();\n          }), s && s.onMouseOut(), n && n.hide(e), this.unDocMouseMove && (this.unDocMouseMove = this.unDocMouseMove()), i.axes.forEach(function (t) {\n            t.hideCrosshair();\n          }), i.hoverPoints = i.hoverPoint = void 0);\n        }\n      }, {\n        key: \"runPointActions\",\n        value: function runPointActions(t, e, i) {\n          var s = this.chart,\n            r = s.series,\n            n = s.tooltip && s.tooltip.options.enabled ? s.tooltip : void 0,\n            a = !!n && n.shared,\n            l = e || s.hoverPoint,\n            d = l && l.series || s.hoverSeries,\n            c = (!t || \"touchmove\" !== t.type) && (!!e || d && d.directTouch && this.isDirectTouch),\n            u = this.getHoverData(l, d, r, c, a, t);\n          l = u.hoverPoint, d = u.hoverSeries;\n          var g = u.hoverPoints,\n            f = d && d.tooltipOptions.followPointer && !d.tooltipOptions.split,\n            m = a && d && !d.noSharedTooltip;\n          if (l && (i || l !== s.hoverPoint || n && n.isHidden)) {\n            if ((s.hoverPoints || []).forEach(function (t) {\n              -1 === g.indexOf(t) && t.setState();\n            }), s.hoverSeries !== d && d.onMouseOver(), this.applyInactiveState(g), (g || []).forEach(function (t) {\n              t.setState(\"hover\");\n            }), s.hoverPoint && s.hoverPoint.firePointEvent(\"mouseOut\"), !l.series) return;\n            s.hoverPoints = g, s.hoverPoint = l, l.firePointEvent(\"mouseOver\", void 0, function () {\n              n && l && n.refresh(m ? g : l, t);\n            });\n          } else if (f && n && !n.isHidden) {\n            var _e33 = n.getAnchor([{}], t);\n            s.isInsidePlot(_e33[0], _e33[1], {\n              visiblePlotOnly: !0\n            }) && n.updatePosition({\n              plotX: _e33[0],\n              plotY: _e33[1]\n            });\n          }\n          this.unDocMouseMove || (this.unDocMouseMove = h(s.container.ownerDocument, \"mousemove\", function (t) {\n            var _o20, _S$hoverChartIndex;\n            return (_o20 = o[(_S$hoverChartIndex = S.hoverChartIndex) !== null && _S$hoverChartIndex !== void 0 ? _S$hoverChartIndex : -1]) === null || _o20 === void 0 || (_o20 = _o20.pointer) === null || _o20 === void 0 ? void 0 : _o20.onDocumentMouseMove(t);\n          }), this.eventsToUnbind.push(this.unDocMouseMove)), s.axes.forEach(function (e) {\n            var i;\n            var r = y((e.crosshair || {}).snap, !0);\n            !r || (i = s.hoverPoint) && i.series[e.coll] === e || (i = p(g, function (t) {\n              return t.series && t.series[e.coll] === e;\n            })), i || !r ? e.drawCrosshair(t, i) : e.hideCrosshair();\n          });\n        }\n      }, {\n        key: \"setDOMEvents\",\n        value: function setDOMEvents() {\n          var _this13 = this;\n          var t = this.chart.container,\n            e = t.ownerDocument;\n          t.onmousedown = this.onContainerMouseDown.bind(this), t.onmousemove = this.onContainerMouseMove.bind(this), t.onclick = this.onContainerClick.bind(this), this.eventsToUnbind.push(h(t, \"mouseenter\", this.onContainerMouseEnter.bind(this)), h(t, \"mouseleave\", this.onContainerMouseLeave.bind(this))), S.unbindDocumentMouseUp || (S.unbindDocumentMouseUp = []), S.unbindDocumentMouseUp.push(h(e, \"mouseup\", this.onDocumentMouseUp.bind(this)));\n          var i = this.chart.renderTo.parentElement;\n          for (; i && \"BODY\" !== i.tagName;) this.eventsToUnbind.push(h(i, \"scroll\", function () {\n            delete _this13.chartPosition;\n          })), i = i.parentElement;\n          this.eventsToUnbind.push(h(t, \"touchstart\", this.onContainerTouchStart.bind(this), {\n            passive: !1\n          }), h(t, \"touchmove\", this.onContainerTouchMove.bind(this), {\n            passive: !1\n          })), S.unbindDocumentTouchEnd || (S.unbindDocumentTouchEnd = h(e, \"touchend\", this.onDocumentTouchEnd.bind(this), {\n            passive: !1\n          })), this.setPointerCapture(), h(this.chart, \"redraw\", this.setPointerCapture.bind(this));\n        }\n      }, {\n        key: \"setPointerCapture\",\n        value: function setPointerCapture() {\n          var _e$options$tooltip, _e$options$chart$styl;\n          if (!a) return;\n          var t = this.pointerCaptureEventsToUnbind,\n            e = this.chart,\n            i = e.container,\n            s = y((_e$options$tooltip = e.options.tooltip) === null || _e$options$tooltip === void 0 ? void 0 : _e$options$tooltip.followTouchMove, !0) && e.series.some(function (t) {\n              return t.options.findNearestPointBy.indexOf(\"y\") > -1;\n            });\n          !this.hasPointerCapture && s ? (t.push(h(i, \"pointerdown\", function (t) {\n            var _t$target, _t$target2;\n            ((_t$target = t.target) === null || _t$target === void 0 ? void 0 : _t$target.hasPointerCapture(t.pointerId)) && ((_t$target2 = t.target) === null || _t$target2 === void 0 ? void 0 : _t$target2.releasePointerCapture(t.pointerId));\n          }), h(i, \"pointermove\", function (t) {\n            var _e$pointer;\n            (_e$pointer = e.pointer) === null || _e$pointer === void 0 || (_e$pointer = _e$pointer.getPointFromEvent(t)) === null || _e$pointer === void 0 || _e$pointer.onMouseOver(t);\n          })), e.styledMode || d(i, {\n            \"touch-action\": \"none\"\n          }), i.className += \" highcharts-no-touch-action\", this.hasPointerCapture = !0) : this.hasPointerCapture && !s && (t.forEach(function (t) {\n            return t();\n          }), t.length = 0, e.styledMode || d(i, {\n            \"touch-action\": y((_e$options$chart$styl = e.options.chart.style) === null || _e$options$chart$styl === void 0 ? void 0 : _e$options$chart$styl[\"touch-action\"], \"manipulation\")\n          }), i.className = i.className.replace(\" highcharts-no-touch-action\", \"\"), this.hasPointerCapture = !1);\n        }\n      }, {\n        key: \"setHoverChartIndex\",\n        value: function setHoverChartIndex(t) {\n          var i = this.chart,\n            s = e.charts[y(S.hoverChartIndex, -1)];\n          if (s && s !== i) {\n            var _t52, _s$pointer;\n            var _e34 = {\n              relatedTarget: i.container\n            };\n            t && !((_t52 = t) !== null && _t52 !== void 0 && _t52.relatedTarget) && (t = _objectSpread(_objectSpread({}, _e34), t)), (_s$pointer = s.pointer) === null || _s$pointer === void 0 ? void 0 : _s$pointer.onContainerMouseLeave(t || _e34);\n          }\n          s && s.mouseIsDown || (S.hoverChartIndex = i.index);\n        }\n      }, {\n        key: \"touch\",\n        value: function touch(t, e) {\n          var i;\n          var s = this.chart,\n            _this$pinchDown = this.pinchDown,\n            r = _this$pinchDown === void 0 ? [] : _this$pinchDown;\n          this.setHoverChartIndex(), 1 === (t = this.normalize(t)).touches.length ? s.isInsidePlot(t.chartX - s.plotLeft, t.chartY - s.plotTop, {\n            visiblePlotOnly: !0\n          }) && !s.openMenu ? (e && this.runPointActions(t), \"touchmove\" === t.type && (i = !!r[0] && Math.pow(r[0].chartX - t.chartX, 2) + Math.pow(r[0].chartY - t.chartY, 2) >= 16), y(i, !0) && this.pinch(t)) : e && this.reset() : 2 === t.touches.length && this.pinch(t);\n        }\n      }, {\n        key: \"touchSelect\",\n        value: function touchSelect(t) {\n          return !!(this.chart.zooming.singleTouch && t.touches && 1 === t.touches.length);\n        }\n      }, {\n        key: \"zoomOption\",\n        value: function zoomOption(t) {\n          var e = this.chart,\n            i = e.inverted,\n            s = e.zooming.type || \"\",\n            r,\n            o;\n          /touch/.test(t.type) && (s = y(e.zooming.pinchType, s)), this.zoomX = r = /x/.test(s), this.zoomY = o = /y/.test(s), this.zoomHor = r && !i || o && i, this.zoomVert = o && !i || r && i, this.hasZoom = r || o;\n        }\n      }]);\n    }();\n    return (s = S || (S = {})).compose = function (t) {\n      b(n, \"Core.Pointer\") && h(t, \"beforeRender\", function () {\n        this.pointer = new s(this, this.options);\n      });\n    }, S;\n  }), i(e, \"Core/Legend/LegendSymbol.js\", [e[\"Core/Utilities.js\"]], function (t) {\n    var e;\n    var i = t.extend,\n      s = t.merge,\n      r = t.pick;\n    return function (t) {\n      function e(t, e, o) {\n        var n = this.legendItem = this.legendItem || {},\n          a = this.chart,\n          h = this.options,\n          _t$baseline = t.baseline,\n          l = _t$baseline === void 0 ? 0 : _t$baseline,\n          d = t.symbolWidth,\n          c = t.symbolHeight,\n          p = this.symbol || \"circle\",\n          u = c / 2,\n          g = a.renderer,\n          f = n.group,\n          m = l - Math.round(c * (o ? .4 : .3)),\n          x = {},\n          y,\n          b = h.marker,\n          v = 0;\n        if (a.styledMode || (x[\"stroke-width\"] = Math.min(h.lineWidth || 0, 24), h.dashStyle ? x.dashstyle = h.dashStyle : \"square\" === h.linecap || (x[\"stroke-linecap\"] = \"round\")), n.line = g.path().addClass(\"highcharts-graph\").attr(x).add(f), o && (n.area = g.path().addClass(\"highcharts-area\").add(f)), x[\"stroke-linecap\"] && (v = Math.min(n.line.strokeWidth(), d) / 2), d) {\n          var _n$area;\n          var _t53 = [[\"M\", v, m], [\"L\", d - v, m]];\n          n.line.attr({\n            d: _t53\n          }), (_n$area = n.area) === null || _n$area === void 0 ? void 0 : _n$area.attr({\n            d: [].concat(_t53, [[\"L\", d - v, l], [\"L\", v, l]])\n          });\n        }\n        if (b && !1 !== b.enabled && d) {\n          var _t54 = Math.min(r(b.radius, u), u);\n          0 === p.indexOf(\"url\") && (b = s(b, {\n            width: c,\n            height: c\n          }), _t54 = 0), n.symbol = y = g.symbol(p, d / 2 - _t54, m - _t54, 2 * _t54, 2 * _t54, i({\n            context: \"legend\"\n          }, b)).addClass(\"highcharts-point\").add(f), y.isMarker = !0;\n        }\n      }\n      t.areaMarker = function (t, i) {\n        e.call(this, t, i, !0);\n      }, t.lineMarker = e, t.rectangle = function (t, e) {\n        var i = e.legendItem || {},\n          s = t.options,\n          o = t.symbolHeight,\n          n = s.squareSymbol,\n          a = n ? o : t.symbolWidth;\n        i.symbol = this.chart.renderer.rect(n ? (t.symbolWidth - o) / 2 : 0, t.baseline - o + 1, a, o, r(t.options.symbolRadius, o / 2)).addClass(\"highcharts-point\").attr({\n          zIndex: 3\n        }).add(i.group);\n      };\n    }(e || (e = {})), e;\n  }), i(e, \"Core/Series/SeriesDefaults.js\", [], function () {\n    return {\n      lineWidth: 2,\n      allowPointSelect: !1,\n      crisp: !0,\n      showCheckbox: !1,\n      animation: {\n        duration: 1e3\n      },\n      enableMouseTracking: !0,\n      events: {},\n      marker: {\n        enabledThreshold: 2,\n        lineColor: \"#ffffff\",\n        lineWidth: 0,\n        radius: 4,\n        states: {\n          normal: {\n            animation: !0\n          },\n          hover: {\n            animation: {\n              duration: 150\n            },\n            enabled: !0,\n            radiusPlus: 2,\n            lineWidthPlus: 1\n          },\n          select: {\n            fillColor: \"#cccccc\",\n            lineColor: \"#000000\",\n            lineWidth: 2\n          }\n        }\n      },\n      point: {\n        events: {}\n      },\n      dataLabels: {\n        animation: {},\n        align: \"center\",\n        borderWidth: 0,\n        defer: !0,\n        formatter: function formatter() {\n          var t = this.series.chart.numberFormatter;\n          return \"number\" != typeof this.y ? \"\" : t(this.y, -1);\n        },\n        padding: 5,\n        style: {\n          fontSize: \"0.7em\",\n          fontWeight: \"bold\",\n          color: \"contrast\",\n          textOutline: \"1px contrast\"\n        },\n        verticalAlign: \"bottom\",\n        x: 0,\n        y: 0\n      },\n      cropThreshold: 300,\n      opacity: 1,\n      pointRange: 0,\n      softThreshold: !0,\n      states: {\n        normal: {\n          animation: !0\n        },\n        hover: {\n          animation: {\n            duration: 150\n          },\n          lineWidthPlus: 1,\n          marker: {},\n          halo: {\n            size: 10,\n            opacity: .25\n          }\n        },\n        select: {\n          animation: {\n            duration: 0\n          }\n        },\n        inactive: {\n          animation: {\n            duration: 150\n          },\n          opacity: .2\n        }\n      },\n      stickyTracking: !0,\n      turboThreshold: 1e3,\n      findNearestPointBy: \"x\"\n    };\n  }), i(e, \"Core/Series/SeriesRegistry.js\", [e[\"Core/Globals.js\"], e[\"Core/Defaults.js\"], e[\"Core/Series/Point.js\"], e[\"Core/Utilities.js\"]], function (t, e, i, s) {\n    var r;\n    var o = e.defaultOptions,\n      n = s.extend,\n      a = s.extendClass,\n      h = s.merge;\n    return function (e) {\n      function s(t, s) {\n        var r = o.plotOptions || {},\n          n = s.defaultOptions,\n          a = s.prototype;\n        return a.type = t, a.pointClass || (a.pointClass = i), !e.seriesTypes[t] && (n && (r[t] = n), e.seriesTypes[t] = s, !0);\n      }\n      e.seriesTypes = t.seriesTypes, e.registerSeriesType = s, e.seriesType = function (t, r, l, d, c) {\n        var p = o.plotOptions || {};\n        if (r = r || \"\", p[t] = h(p[r], l), delete e.seriesTypes[t], s(t, a(e.seriesTypes[r] || function () {}, d)), e.seriesTypes[t].prototype.type = t, c) {\n          var _s31 = /*#__PURE__*/function (_i29) {\n            function _s31() {\n              _classCallCheck(this, _s31);\n              return _callSuper(this, _s31, arguments);\n            }\n            _inherits(_s31, _i29);\n            return _createClass(_s31);\n          }(i);\n          n(_s31.prototype, c), e.seriesTypes[t].prototype.pointClass = _s31;\n        }\n        return e.seriesTypes[t];\n      };\n    }(r || (r = {})), r;\n  }), i(e, \"Core/Series/Series.js\", [e[\"Core/Animation/AnimationUtilities.js\"], e[\"Core/Defaults.js\"], e[\"Core/Foundation.js\"], e[\"Core/Globals.js\"], e[\"Core/Legend/LegendSymbol.js\"], e[\"Core/Series/Point.js\"], e[\"Core/Series/SeriesDefaults.js\"], e[\"Core/Series/SeriesRegistry.js\"], e[\"Core/Renderer/SVG/SVGElement.js\"], e[\"Core/Utilities.js\"]], function (t, e, i, s, r, o, n, a, h, l) {\n    var d = t.animObject,\n      c = t.setAnimation,\n      p = e.defaultOptions,\n      u = i.registerEventOptions,\n      g = s.svg,\n      f = s.win,\n      m = a.seriesTypes,\n      x = l.arrayMax,\n      y = l.arrayMin,\n      b = l.clamp,\n      v = l.correctFloat,\n      S = l.crisp,\n      C = l.defined,\n      k = l.destroyObjectProperties,\n      M = l.diffObjects,\n      w = l.erase,\n      A = l.error,\n      T = l.extend,\n      P = l.find,\n      L = l.fireEvent,\n      O = l.getClosestDistance,\n      D = l.getNestedProperty,\n      E = l.insertItem,\n      I = l.isArray,\n      j = l.isNumber,\n      B = l.isString,\n      R = l.merge,\n      z = l.objectEach,\n      N = l.pick,\n      W = l.removeEvent,\n      G = l.splat,\n      H = l.syncTimeout;\n    var X = /*#__PURE__*/function () {\n      function X() {\n        _classCallCheck(this, X);\n        this.zoneAxis = \"y\";\n      }\n      return _createClass(X, [{\n        key: \"init\",\n        value: function init(t, e) {\n          var i;\n          L(this, \"init\", {\n            options: e\n          });\n          var s = this,\n            r = t.series;\n          this.eventsToUnbind = [], s.chart = t, s.options = s.setOptions(e);\n          var o = s.options,\n            n = !1 !== o.visible;\n          s.linkedSeries = [], s.bindAxes(), T(s, {\n            name: o.name,\n            state: \"\",\n            visible: n,\n            selected: !0 === o.selected\n          }), u(this, o);\n          var a = o.events;\n          (a && a.click || o.point && o.point.events && o.point.events.click || o.allowPointSelect) && (t.runTrackerClick = !0), s.getColor(), s.getSymbol(), s.parallelArrays.forEach(function (t) {\n            s[t + \"Data\"] || (s[t + \"Data\"] = []);\n          }), s.isCartesian && (t.hasCartesianSeries = !0), r.length && (i = r[r.length - 1]), s._i = N(i && i._i, -1) + 1, s.opacity = s.options.opacity, t.orderItems(\"series\", E(this, r)), o.dataSorting && o.dataSorting.enabled ? s.setDataSortingOptions() : s.points || s.data || s.setData(o.data, !1), L(this, \"afterInit\");\n        }\n      }, {\n        key: \"is\",\n        value: function is(t) {\n          return m[t] && this instanceof m[t];\n        }\n      }, {\n        key: \"bindAxes\",\n        value: function bindAxes() {\n          var t;\n          var e = this,\n            i = e.options,\n            s = e.chart;\n          L(this, \"bindAxes\", null, function () {\n            (e.axisTypes || []).forEach(function (r) {\n              (s[r] || []).forEach(function (s) {\n                t = s.options, (N(i[r], 0) === s.index || void 0 !== i[r] && i[r] === t.id) && (E(e, s.series), e[r] = s, s.isDirty = !0);\n              }), e[r] || e.optionalAxis === r || A(18, !0, s);\n            });\n          }), L(this, \"afterBindAxes\");\n        }\n      }, {\n        key: \"updateParallelArrays\",\n        value: function updateParallelArrays(t, e, i) {\n          var s = t.series,\n            r = j(e) ? function (i) {\n              var r = \"y\" === i && s.toYData ? s.toYData(t) : t[i];\n              s[i + \"Data\"][e] = r;\n            } : function (t) {\n              Array.prototype[e].apply(s[t + \"Data\"], i);\n            };\n          s.parallelArrays.forEach(r);\n        }\n      }, {\n        key: \"hasData\",\n        value: function hasData() {\n          return this.visible && void 0 !== this.dataMax && void 0 !== this.dataMin || this.visible && this.yData && this.yData.length > 0;\n        }\n      }, {\n        key: \"hasMarkerChanged\",\n        value: function hasMarkerChanged(t, e) {\n          var i = t.marker,\n            s = e.marker || {};\n          return i && (s.enabled && !i.enabled || s.symbol !== i.symbol || s.height !== i.height || s.width !== i.width);\n        }\n      }, {\n        key: \"autoIncrement\",\n        value: function autoIncrement(t) {\n          var e = this.options,\n            i = e.pointIntervalUnit,\n            s = e.relativeXValue,\n            r = this.chart.time,\n            o = this.xIncrement,\n            n,\n            a;\n          return (o = N(o, e.pointStart, 0), this.pointInterval = a = N(this.pointInterval, e.pointInterval, 1), s && j(t) && (a *= t), i && (n = new r.Date(o), \"day\" === i ? r.set(\"Date\", n, r.get(\"Date\", n) + a) : \"month\" === i ? r.set(\"Month\", n, r.get(\"Month\", n) + a) : \"year\" === i && r.set(\"FullYear\", n, r.get(\"FullYear\", n) + a), a = n.getTime() - o), s && j(t)) ? o + a : (this.xIncrement = o + a, o);\n        }\n      }, {\n        key: \"setDataSortingOptions\",\n        value: function setDataSortingOptions() {\n          var t = this.options;\n          T(this, {\n            requireSorting: !1,\n            sorted: !1,\n            enabledDataSorting: !0,\n            allowDG: !1\n          }), C(t.pointRange) || (t.pointRange = 1);\n        }\n      }, {\n        key: \"setOptions\",\n        value: function setOptions(t) {\n          var _p$plotOptions$series, _l$series;\n          var e;\n          var i = this.chart,\n            s = i.options.plotOptions,\n            r = i.userOptions || {},\n            o = R(t),\n            n = i.styledMode,\n            a = {\n              plotOptions: s,\n              userOptions: o\n            };\n          L(this, \"setOptions\", a);\n          var h = a.plotOptions[this.type],\n            l = r.plotOptions || {},\n            d = l.series || {},\n            c = p.plotOptions[this.type] || {},\n            u = l[this.type] || {};\n          this.userOptions = a.userOptions;\n          var g = R(h, s.series, u, o);\n          this.tooltipOptions = R(p.tooltip, (_p$plotOptions$series = p.plotOptions.series) === null || _p$plotOptions$series === void 0 ? void 0 : _p$plotOptions$series.tooltip, c === null || c === void 0 ? void 0 : c.tooltip, i.userOptions.tooltip, (_l$series = l.series) === null || _l$series === void 0 ? void 0 : _l$series.tooltip, u.tooltip, o.tooltip), this.stickyTracking = N(o.stickyTracking, u.stickyTracking, d.stickyTracking, !!this.tooltipOptions.shared && !this.noSharedTooltip || g.stickyTracking), null === h.marker && delete g.marker, this.zoneAxis = g.zoneAxis || \"y\";\n          var f = this.zones = (g.zones || []).map(function (t) {\n            return _objectSpread({}, t);\n          });\n          return (g.negativeColor || g.negativeFillColor) && !g.zones && (e = {\n            value: g[this.zoneAxis + \"Threshold\"] || g.threshold || 0,\n            className: \"highcharts-negative\"\n          }, n || (e.color = g.negativeColor, e.fillColor = g.negativeFillColor), f.push(e)), f.length && C(f[f.length - 1].value) && f.push(n ? {} : {\n            color: this.color,\n            fillColor: this.fillColor\n          }), L(this, \"afterSetOptions\", {\n            options: g\n          }), g;\n        }\n      }, {\n        key: \"getName\",\n        value: function getName() {\n          return N(this.options.name, \"Series \" + (this.index + 1));\n        }\n      }, {\n        key: \"getCyclic\",\n        value: function getCyclic(t, e, i) {\n          var s, r;\n          var o = this.chart,\n            n = \"\".concat(t, \"Index\"),\n            a = \"\".concat(t, \"Counter\"),\n            h = (i === null || i === void 0 ? void 0 : i.length) || o.options.chart.colorCount;\n          !e && (C(r = N(\"color\" === t ? this.options.colorIndex : void 0, this[n])) ? s = r : (o.series.length || (o[a] = 0), s = o[a] % h, o[a] += 1), i && (e = i[s])), void 0 !== s && (this[n] = s), this[t] = e;\n        }\n      }, {\n        key: \"getColor\",\n        value: function getColor() {\n          this.chart.styledMode ? this.getCyclic(\"color\") : this.options.colorByPoint ? this.color = \"#cccccc\" : this.getCyclic(\"color\", this.options.color || p.plotOptions[this.type].color, this.chart.options.colors);\n        }\n      }, {\n        key: \"getPointsCollection\",\n        value: function getPointsCollection() {\n          return (this.hasGroupedData ? this.points : this.data) || [];\n        }\n      }, {\n        key: \"getSymbol\",\n        value: function getSymbol() {\n          var t = this.options.marker;\n          this.getCyclic(\"symbol\", t.symbol, this.chart.options.symbols);\n        }\n      }, {\n        key: \"findPointIndex\",\n        value: function findPointIndex(t, e) {\n          var i, s, r;\n          var n = t.id,\n            a = t.x,\n            h = this.points,\n            l = this.options.dataSorting;\n          if (n) {\n            var _t55 = this.chart.get(n);\n            _t55 instanceof o && (i = _t55);\n          } else if (this.linkedParent || this.enabledDataSorting || this.options.relativeXValue) {\n            var _e35 = function _e35(e) {\n              return !e.touched && e.index === t.index;\n            };\n            if (l && l.matchByName ? _e35 = function _e35(e) {\n              return !e.touched && e.name === t.name;\n            } : this.options.relativeXValue && (_e35 = function _e35(e) {\n              return !e.touched && e.options.x === t.x;\n            }), !(i = P(h, _e35))) return;\n          }\n          return i && void 0 !== (r = i && i.index) && (s = !0), void 0 === r && j(a) && (r = this.xData.indexOf(a, e)), -1 !== r && void 0 !== r && this.cropped && (r = r >= this.cropStart ? r - this.cropStart : r), !s && j(r) && h[r] && h[r].touched && (r = void 0), r;\n        }\n      }, {\n        key: \"updateData\",\n        value: function updateData(t, e) {\n          var i = this.options,\n            s = i.dataSorting,\n            r = this.points,\n            o = [],\n            n = this.requireSorting,\n            a = t.length === r.length,\n            h,\n            l,\n            d,\n            c,\n            p = !0;\n          if (this.xIncrement = null, t.forEach(function (t, e) {\n            var l;\n            var d = C(t) && this.pointClass.prototype.optionsToObject.call({\n                series: this\n              }, t) || {},\n              p = d.x;\n            d.id || j(p) ? (-1 === (l = this.findPointIndex(d, c)) || void 0 === l ? o.push(t) : r[l] && t !== i.data[l] ? (r[l].update(t, !1, null, !1), r[l].touched = !0, n && (c = l + 1)) : r[l] && (r[l].touched = !0), (!a || e !== l || s && s.enabled || this.hasDerivedData) && (h = !0)) : o.push(t);\n          }, this), h) for (l = r.length; l--;) (d = r[l]) && !d.touched && d.remove && d.remove(!1, e);else !a || s && s.enabled ? p = !1 : (t.forEach(function (t, e) {\n            t === r[e].y || r[e].destroyed || r[e].update(t, !1, null, !1);\n          }), o.length = 0);\n          return r.forEach(function (t) {\n            t && (t.touched = !1);\n          }), !!p && (o.forEach(function (t) {\n            this.addPoint(t, !1, null, null, !1);\n          }, this), null === this.xIncrement && this.xData && this.xData.length && (this.xIncrement = x(this.xData), this.autoIncrement()), !0);\n        }\n      }, {\n        key: \"setData\",\n        value: function setData(t) {\n          var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !0;\n          var i = arguments.length > 2 ? arguments[2] : undefined;\n          var s = arguments.length > 3 ? arguments[3] : undefined;\n          var r = this,\n            o = r.points,\n            n = o && o.length || 0,\n            a = r.options,\n            h = r.chart,\n            l = a.dataSorting,\n            d = r.xAxis,\n            c = a.turboThreshold,\n            p = this.xData,\n            u = this.yData,\n            g = r.pointArrayMap,\n            f = g && g.length,\n            m = a.keys,\n            x,\n            y,\n            b,\n            v = 0,\n            S = 1,\n            C;\n          h.options.chart.allowMutatingData || (a.data && delete r.options.data, r.userOptions.data && delete r.userOptions.data, C = R(!0, t));\n          var k = (t = C || t || []).length;\n          if (l && l.enabled && (t = this.sortData(t)), h.options.chart.allowMutatingData && !1 !== s && k && n && !r.cropped && !r.hasGroupedData && r.visible && !r.boosted && (b = this.updateData(t, i)), !b) {\n            r.xIncrement = null, r.colorCounter = 0, this.parallelArrays.forEach(function (t) {\n              r[t + \"Data\"].length = 0;\n            });\n            var _e36 = c && k > c;\n            if (_e36) {\n              var _i30 = r.getFirstValidPoint(t),\n                _s32 = r.getFirstValidPoint(t, k - 1, -1),\n                _o21 = function _o21(t) {\n                  return !!(I(t) && (m || j(t[0])));\n                };\n              if (j(_i30) && j(_s32)) for (x = 0; x < k; x++) p[x] = this.autoIncrement(), u[x] = t[x];else if (_o21(_i30) && _o21(_s32)) {\n                if (f) {\n                  if (_i30.length === f) for (x = 0; x < k; x++) p[x] = this.autoIncrement(), u[x] = t[x];else for (x = 0; x < k; x++) y = t[x], p[x] = y[0], u[x] = y.slice(1, f + 1);\n                } else if (m && (v = m.indexOf(\"x\"), S = m.indexOf(\"y\"), v = v >= 0 ? v : 0, S = S >= 0 ? S : 1), 1 === _i30.length && (S = 0), v === S) for (x = 0; x < k; x++) p[x] = this.autoIncrement(), u[x] = t[x][S];else for (x = 0; x < k; x++) y = t[x], p[x] = y[v], u[x] = y[S];\n              } else _e36 = !1;\n            }\n            if (!_e36) for (x = 0; x < k; x++) y = {\n              series: r\n            }, r.pointClass.prototype.applyOptions.apply(y, [t[x]]), r.updateParallelArrays(y, x);\n            for (u && B(u[0]) && A(14, !0, h), r.data = [], r.options.data = r.userOptions.data = t, x = n; x--;) {\n              var _o$x;\n              (_o$x = o[x]) === null || _o$x === void 0 || _o$x.destroy();\n            }\n            d && (d.minRange = d.userMinRange), r.isDirty = h.isDirtyBox = !0, r.isDirtyData = !!o, i = !1;\n          }\n          \"point\" === a.legendType && (this.processData(), this.generatePoints()), e && h.redraw(i);\n        }\n      }, {\n        key: \"sortData\",\n        value: function sortData(t) {\n          var e = this,\n            i = e.options.dataSorting.sortKey || \"y\",\n            s = function s(t, e) {\n              return C(e) && t.pointClass.prototype.optionsToObject.call({\n                series: t\n              }, e) || {};\n            };\n          return t.forEach(function (i, r) {\n            t[r] = s(e, i), t[r].index = r;\n          }, this), t.concat().sort(function (t, e) {\n            var s = D(i, t),\n              r = D(i, e);\n            return r < s ? -1 : r > s ? 1 : 0;\n          }).forEach(function (t, e) {\n            t.x = e;\n          }, this), e.linkedSeries && e.linkedSeries.forEach(function (e) {\n            var i = e.options,\n              r = i.data;\n            i.dataSorting && i.dataSorting.enabled || !r || (r.forEach(function (i, o) {\n              r[o] = s(e, i), t[o] && (r[o].x = t[o].x, r[o].index = o);\n            }), e.setData(r, !1));\n          }), t;\n        }\n      }, {\n        key: \"getProcessedData\",\n        value: function getProcessedData(t) {\n          var e = this,\n            i = e.xAxis,\n            s = e.options.cropThreshold,\n            r = i === null || i === void 0 ? void 0 : i.logarithmic,\n            o = e.isCartesian,\n            n,\n            a,\n            h = 0,\n            l,\n            d,\n            c,\n            p = e.xData,\n            u = e.yData,\n            g = !1,\n            f = p.length;\n          i && (d = (l = i.getExtremes()).min, c = l.max, g = !!(i.categories && !i.names.length)), o && e.sorted && !t && (!s || f > s || e.forceCrop) && (p[f - 1] < d || p[0] > c ? (p = [], u = []) : e.yData && (p[0] < d || p[f - 1] > c) && (p = (n = this.cropData(e.xData, e.yData, d, c)).xData, u = n.yData, h = n.start, a = !0));\n          var m = O([r ? p.map(r.log2lin) : p], function () {\n            return e.requireSorting && !g && A(15, !1, e.chart);\n          });\n          return {\n            xData: p,\n            yData: u,\n            cropped: a,\n            cropStart: h,\n            closestPointRange: m\n          };\n        }\n      }, {\n        key: \"processData\",\n        value: function processData(t) {\n          var e = this.xAxis;\n          if (this.isCartesian && !this.isDirty && !e.isDirty && !this.yAxis.isDirty && !t) return !1;\n          var i = this.getProcessedData();\n          this.cropped = i.cropped, this.cropStart = i.cropStart, this.processedXData = i.xData, this.processedYData = i.yData, this.closestPointRange = this.basePointRange = i.closestPointRange, L(this, \"afterProcessData\");\n        }\n      }, {\n        key: \"cropData\",\n        value: function cropData(t, e, i, s) {\n          var r = t.length,\n            o,\n            n,\n            a = 0,\n            h = r;\n          for (o = 0; o < r; o++) if (t[o] >= i) {\n            a = Math.max(0, o - 1);\n            break;\n          }\n          for (n = o; n < r; n++) if (t[n] > s) {\n            h = n + 1;\n            break;\n          }\n          return {\n            xData: t.slice(a, h),\n            yData: e.slice(a, h),\n            start: a,\n            end: h\n          };\n        }\n      }, {\n        key: \"generatePoints\",\n        value: function generatePoints() {\n          var t = this.options,\n            e = this.processedData || t.data,\n            i = this.processedXData,\n            s = this.processedYData,\n            r = this.pointClass,\n            o = i.length,\n            n = this.cropStart || 0,\n            a = this.hasGroupedData,\n            h = t.keys,\n            l = [],\n            d = t.dataGrouping && t.dataGrouping.groupAll ? n : 0,\n            c,\n            p,\n            u,\n            g,\n            f = this.data;\n          if (!f && !a) {\n            var _t56 = [];\n            _t56.length = e.length, f = this.data = _t56;\n          }\n          for (h && a && (this.options.keys = !1), g = 0; g < o; g++) p = n + g, a ? ((u = new r(this, [i[g]].concat(G(s[g])))).dataGroup = this.groupMap[d + g], u.dataGroup.options && (u.options = u.dataGroup.options, T(u, u.dataGroup.options), delete u.dataLabels)) : (u = f[p]) || void 0 === e[p] || (f[p] = u = new r(this, e[p], i[g])), u && (u.index = a ? d + g : p, l[g] = u);\n          if (this.options.keys = h, f && (o !== (c = f.length) || a)) for (g = 0; g < c; g++) g !== n || a || (g += o), f[g] && (f[g].destroyElements(), f[g].plotX = void 0);\n          this.data = f, this.points = l, L(this, \"afterGeneratePoints\");\n        }\n      }, {\n        key: \"getXExtremes\",\n        value: function getXExtremes(t) {\n          return {\n            min: y(t),\n            max: x(t)\n          };\n        }\n      }, {\n        key: \"getExtremes\",\n        value: function getExtremes(t, e) {\n          var i = this.xAxis,\n            s = this.yAxis,\n            r = [],\n            o = this.requireSorting && !this.is(\"column\") ? 1 : 0,\n            n = !!s && s.positiveValuesOnly,\n            a = e || this.getExtremesFromAll || this.options.getExtremesFromAll,\n            h = this.processedXData,\n            l = this.processedYData,\n            d,\n            c,\n            p,\n            u,\n            g,\n            f,\n            m,\n            b = 0,\n            v = 0,\n            S = 0;\n          if (this.cropped && a) {\n            var _t57 = this.getProcessedData(!0);\n            h = _t57.xData, l = _t57.yData;\n          }\n          var C = (t = t || this.stackedYData || l || []).length,\n            k = h || this.xData;\n          for (i && (b = (d = i.getExtremes()).min, v = d.max), f = 0; f < C; f++) if (u = k[f], c = (j(g = t[f]) || I(g)) && ((j(g) ? g > 0 : g.length) || !n), p = e || this.getExtremesFromAll || this.options.getExtremesFromAll || this.cropped || !i || (k[f + o] || u) >= b && (k[f - o] || u) <= v, c && p) {\n            if (m = g.length) for (; m--;) j(g[m]) && (r[S++] = g[m]);else r[S++] = g;\n          }\n          var M = {\n            activeYData: r,\n            dataMin: y(r),\n            dataMax: x(r)\n          };\n          return L(this, \"afterGetExtremes\", {\n            dataExtremes: M\n          }), M;\n        }\n      }, {\n        key: \"applyExtremes\",\n        value: function applyExtremes() {\n          var t = this.getExtremes();\n          return this.dataMin = t.dataMin, this.dataMax = t.dataMax, t;\n        }\n      }, {\n        key: \"getFirstValidPoint\",\n        value: function getFirstValidPoint(t) {\n          var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n          var i = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n          var s = t.length,\n            r = e;\n          for (; r >= 0 && r < s;) {\n            if (C(t[r])) return t[r];\n            r += i;\n          }\n        }\n      }, {\n        key: \"translate\",\n        value: function translate() {\n          this.processedXData || this.processData(), this.generatePoints();\n          var t = this.options,\n            e = t.stacking,\n            i = this.xAxis,\n            s = i.categories,\n            r = this.enabledDataSorting,\n            o = this.yAxis,\n            n = this.points,\n            a = n.length,\n            h = this.pointPlacementToXValue(),\n            l = !!h,\n            d = t.threshold,\n            c = t.startFromThreshold ? d : 0,\n            p,\n            u,\n            g,\n            f,\n            m = Number.MAX_VALUE;\n          function x(t) {\n            return b(t, -1e5, 1e5);\n          }\n          for (p = 0; p < a; p++) {\n            var _o$stacking;\n            var _t58 = void 0;\n            var _a13 = n[p],\n              _y = _a13.x,\n              _b = void 0,\n              _S3 = void 0,\n              _k2 = _a13.y,\n              _M = _a13.low,\n              _w = e && ((_o$stacking = o.stacking) === null || _o$stacking === void 0 ? void 0 : _o$stacking.stacks[(this.negStacks && _k2 < (c ? 0 : d) ? \"-\" : \"\") + this.stackKey]);\n            u = i.translate(_y, !1, !1, !1, !0, h), _a13.plotX = j(u) ? v(x(u)) : void 0, e && this.visible && _w && _w[_y] && (f = this.getStackIndicator(f, _y, this.index), !_a13.isNull && f.key && (_S3 = (_b = _w[_y]).points[f.key]), _b && I(_S3) && (_M = _S3[0], _k2 = _S3[1], _M === c && f.key === _w[_y].base && (_M = N(j(d) ? d : o.min)), o.positiveValuesOnly && C(_M) && _M <= 0 && (_M = void 0), _a13.total = _a13.stackTotal = N(_b.total), _a13.percentage = C(_a13.y) && _b.total ? _a13.y / _b.total * 100 : void 0, _a13.stackY = _k2, this.irregularWidths || _b.setOffset(this.pointXOffset || 0, this.barW || 0, void 0, void 0, void 0, this.xAxis))), _a13.yBottom = C(_M) ? x(o.translate(_M, !1, !0, !1, !0)) : void 0, this.dataModify && (_k2 = this.dataModify.modifyValue(_k2, p)), j(_k2) && void 0 !== _a13.plotX && (_t58 = j(_t58 = o.translate(_k2, !1, !0, !1, !0)) ? x(_t58) : void 0), _a13.plotY = _t58, _a13.isInside = this.isPointInside(_a13), _a13.clientX = l ? v(i.translate(_y, !1, !1, !1, !0, h)) : u, _a13.negative = (_a13.y || 0) < (d || 0), _a13.category = N(s && s[_a13.x], _a13.x), _a13.isNull || !1 === _a13.visible || (void 0 !== g && (m = Math.min(m, Math.abs(u - g))), g = u), _a13.zone = this.zones.length ? _a13.getZone() : void 0, !_a13.graphic && this.group && r && (_a13.isNew = !0);\n          }\n          this.closestPointRangePx = m, L(this, \"afterTranslate\");\n        }\n      }, {\n        key: \"getValidPoints\",\n        value: function getValidPoints(t, e, i) {\n          var s = this.chart;\n          return (t || this.points || []).filter(function (t) {\n            var r = t.plotX,\n              o = t.plotY;\n            return !!((i || !t.isNull && j(o)) && (!e || s.isInsidePlot(r, o, {\n              inverted: s.inverted\n            }))) && !1 !== t.visible;\n          });\n        }\n      }, {\n        key: \"getClipBox\",\n        value: function getClipBox() {\n          var _ref7;\n          var t = this.chart,\n            e = this.xAxis,\n            i = this.yAxis,\n            _R = R(t.clipBox),\n            s = _R.x,\n            r = _R.y,\n            o = _R.width,\n            n = _R.height;\n          return e && e.len !== t.plotSizeX && (o = e.len), i && i.len !== t.plotSizeY && (n = i.len), t.inverted && !this.invertible && (_ref7 = [n, o], o = _ref7[0], n = _ref7[1], _ref7), {\n            x: s,\n            y: r,\n            width: o,\n            height: n\n          };\n        }\n      }, {\n        key: \"getSharedClipKey\",\n        value: function getSharedClipKey() {\n          return this.sharedClipKey = (this.options.xAxis || 0) + \",\" + (this.options.yAxis || 0), this.sharedClipKey;\n        }\n      }, {\n        key: \"setClip\",\n        value: function setClip() {\n          var t = this.chart,\n            e = this.group,\n            i = this.markerGroup,\n            s = t.sharedClips,\n            r = t.renderer,\n            o = this.getClipBox(),\n            n = this.getSharedClipKey(),\n            a = s[n];\n          a ? a.animate(o) : s[n] = a = r.clipRect(o), e && e.clip(!1 === this.options.clip ? void 0 : a), i && i.clip();\n        }\n      }, {\n        key: \"animate\",\n        value: function animate(t) {\n          var e = this.chart,\n            i = this.group,\n            s = this.markerGroup,\n            r = e.inverted,\n            o = d(this.options.animation),\n            n = [this.getSharedClipKey(), o.duration, o.easing, o.defer].join(\",\"),\n            a = e.sharedClips[n],\n            h = e.sharedClips[n + \"m\"];\n          if (t && i) {\n            var _t59 = this.getClipBox();\n            if (a) a.attr(\"height\", _t59.height);else {\n              _t59.width = 0, r && (_t59.x = e.plotHeight), a = e.renderer.clipRect(_t59), e.sharedClips[n] = a;\n              var _i31 = {\n                x: -99,\n                y: -99,\n                width: r ? e.plotWidth + 199 : 99,\n                height: r ? 99 : e.plotHeight + 199\n              };\n              h = e.renderer.clipRect(_i31), e.sharedClips[n + \"m\"] = h;\n            }\n            i.clip(a), s === null || s === void 0 ? void 0 : s.clip(h);\n          } else if (a && !a.hasClass(\"highcharts-animating\")) {\n            var _t60 = this.getClipBox(),\n              _i32 = o.step;\n            (s !== null && s !== void 0 && s.element.childNodes.length || e.series.length > 1) && (o.step = function (t, e) {\n              var _h7;\n              _i32 && _i32.apply(e, arguments), \"width\" === e.prop && ((_h7 = h) === null || _h7 === void 0 ? void 0 : _h7.element) && h.attr(r ? \"height\" : \"width\", t + 99);\n            }), a.addClass(\"highcharts-animating\").animate(_t60, o);\n          }\n        }\n      }, {\n        key: \"afterAnimate\",\n        value: function afterAnimate() {\n          var _this14 = this;\n          this.setClip(), z(this.chart.sharedClips, function (t, e, i) {\n            t && !_this14.chart.container.querySelector(\"[clip-path=\\\"url(#\".concat(t.id, \")\\\"]\")) && (t.destroy(), delete i[e]);\n          }), this.finishedAnimating = !0, L(this, \"afterAnimate\");\n        }\n      }, {\n        key: \"drawPoints\",\n        value: function drawPoints() {\n          var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.points;\n          var e, i, s, r, o, n, a;\n          var h = this.chart,\n            l = h.styledMode,\n            d = this.colorAxis,\n            c = this.options,\n            p = c.marker,\n            u = this[this.specialGroup || \"markerGroup\"],\n            g = this.xAxis,\n            f = N(p.enabled, !g || !!g.isRadial || null, this.closestPointRangePx >= p.enabledThreshold * p.radius);\n          if (!1 !== p.enabled || this._hasPointMarkers) for (e = 0; e < t.length; e++) if (r = (s = (i = t[e]).graphic) ? \"animate\" : \"attr\", o = i.marker || {}, n = !!i.marker, (f && void 0 === o.enabled || o.enabled) && !i.isNull && !1 !== i.visible) {\n            var _t61 = N(o.symbol, this.symbol, \"rect\");\n            a = this.markerAttribs(i, i.selected && \"select\"), this.enabledDataSorting && (i.startXPos = g.reversed ? -(a.width || 0) : g.width);\n            var _e37 = !1 !== i.isInside;\n            if (!s && _e37 && ((a.width || 0) > 0 || i.hasImage) && (i.graphic = s = h.renderer.symbol(_t61, a.x, a.y, a.width, a.height, n ? o : p).add(u), this.enabledDataSorting && h.hasRendered && (s.attr({\n              x: i.startXPos\n            }), r = \"animate\")), s && \"animate\" === r && s[_e37 ? \"show\" : \"hide\"](_e37).animate(a), s) {\n              var _t62 = this.pointAttribs(i, l || !i.selected ? void 0 : \"select\");\n              l ? d && s.css({\n                fill: _t62.fill\n              }) : s[r](_t62);\n            }\n            s && s.addClass(i.getClassName(), !0);\n          } else s && (i.graphic = s.destroy());\n        }\n      }, {\n        key: \"markerAttribs\",\n        value: function markerAttribs(t, e) {\n          var i = this.options,\n            s = i.marker,\n            r = t.marker || {},\n            o = r.symbol || s.symbol,\n            n = {},\n            a,\n            h,\n            l = N(r.radius, s && s.radius);\n          e && (a = s.states[e], l = N((h = r.states && r.states[e]) && h.radius, a && a.radius, l && l + (a && a.radiusPlus || 0))), t.hasImage = o && 0 === o.indexOf(\"url\"), t.hasImage && (l = 0);\n          var d = t.pos();\n          return j(l) && d && (i.crisp && (d[0] = S(d[0], t.hasImage ? 0 : \"rect\" === o ? (s === null || s === void 0 ? void 0 : s.lineWidth) || 0 : 1)), n.x = d[0] - l, n.y = d[1] - l), l && (n.width = n.height = 2 * l), n;\n        }\n      }, {\n        key: \"pointAttribs\",\n        value: function pointAttribs(t, e) {\n          var i = this.options.marker,\n            s = t && t.options,\n            r = s && s.marker || {},\n            o = s && s.color,\n            n = t && t.color,\n            a = t && t.zone && t.zone.color,\n            h,\n            l,\n            d = this.color,\n            c,\n            p,\n            u = N(r.lineWidth, i.lineWidth),\n            g = 1;\n          return d = o || a || n || d, c = r.fillColor || i.fillColor || d, p = r.lineColor || i.lineColor || d, e = e || \"normal\", h = i.states[e] || {}, u = N((l = r.states && r.states[e] || {}).lineWidth, h.lineWidth, u + N(l.lineWidthPlus, h.lineWidthPlus, 0)), c = l.fillColor || h.fillColor || c, {\n            stroke: p = l.lineColor || h.lineColor || p,\n            \"stroke-width\": u,\n            fill: c,\n            opacity: g = N(l.opacity, h.opacity, g)\n          };\n        }\n      }, {\n        key: \"destroy\",\n        value: function destroy(t) {\n          var e, i, s;\n          var r = this,\n            o = r.chart,\n            n = /AppleWebKit\\/533/.test(f.navigator.userAgent),\n            a = r.data || [];\n          for (L(r, \"destroy\", {\n            keepEventsForUpdate: t\n          }), this.removeEvents(t), (r.axisTypes || []).forEach(function (t) {\n            (s = r[t]) && s.series && (w(s.series, r), s.isDirty = s.forceRedraw = !0);\n          }), r.legendItem && r.chart.legend.destroyItem(r), e = a.length; e--;) (i = a[e]) && i.destroy && i.destroy();\n          var _iterator6 = _createForOfIteratorHelper(r.zones),\n            _step6;\n          try {\n            for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n              var _t63 = _step6.value;\n              k(_t63, void 0, !0);\n            }\n          } catch (err) {\n            _iterator6.e(err);\n          } finally {\n            _iterator6.f();\n          }\n          l.clearTimeout(r.animationTimeout), z(r, function (t, e) {\n            t instanceof h && !t.survive && t[n && \"group\" === e ? \"hide\" : \"destroy\"]();\n          }), o.hoverSeries === r && (o.hoverSeries = void 0), w(o.series, r), o.orderItems(\"series\"), z(r, function (e, i) {\n            t && \"hcEvents\" === i || delete r[i];\n          });\n        }\n      }, {\n        key: \"applyZones\",\n        value: function applyZones() {\n          var t = this.area,\n            e = this.chart,\n            i = this.graph,\n            s = this.zones,\n            r = this.points,\n            o = this.xAxis,\n            n = this.yAxis,\n            a = this.zoneAxis,\n            h = e.inverted,\n            l = e.renderer,\n            d = this[\"\".concat(a, \"Axis\")],\n            _ref8 = d || {},\n            c = _ref8.isXAxis,\n            _ref8$len = _ref8.len,\n            p = _ref8$len === void 0 ? 0 : _ref8$len,\n            u = ((i === null || i === void 0 ? void 0 : i.strokeWidth()) || 0) / 2 + 1,\n            g = function g(t) {\n              var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n              var i = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n              h && (i = p - i);\n              var _t$translated = t.translated,\n                s = _t$translated === void 0 ? 0 : _t$translated,\n                r = t.lineClip,\n                o = i - s;\n              r === null || r === void 0 || r.push([\"L\", e, Math.abs(o) < u ? i - u * (o <= 0 ? -1 : 1) : s]);\n            };\n          if (s.length && (i || t) && d && j(d.min)) {\n            var _e38 = d.getExtremes().max,\n              _u2 = function _u2(t) {\n                t.forEach(function (e, i) {\n                  (\"M\" === e[0] || \"L\" === e[0]) && (t[i] = [e[0], c ? p - e[1] : e[1], c ? e[2] : p - e[2]]);\n                });\n              };\n            if (s.forEach(function (t) {\n              t.lineClip = [], t.translated = b(d.toPixels(N(t.value, _e38), !0) || 0, 0, p);\n            }), i && !this.showLine && i.hide(), t && t.hide(), \"y\" === a && r.length < o.len) {\n              var _iterator7 = _createForOfIteratorHelper(r),\n                _step7;\n              try {\n                for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n                  var _t64 = _step7.value;\n                  var _e39 = _t64.plotX,\n                    _i33 = _t64.plotY,\n                    _r15 = _t64.zone,\n                    _o22 = _r15 && s[s.indexOf(_r15) - 1];\n                  _r15 && g(_r15, _e39, _i33), _o22 && g(_o22, _e39, _i33);\n                }\n              } catch (err) {\n                _iterator7.e(err);\n              } finally {\n                _iterator7.f();\n              }\n            }\n            var _f = [],\n              _m3 = d.toPixels(d.getExtremes().min, !0);\n            s.forEach(function (e) {\n              var _d6, _e$graph, _e$area;\n              var s = e.lineClip || [],\n                r = Math.round(e.translated || 0);\n              o.reversed && s.reverse();\n              var a = e.clip,\n                d = e.simpleClip,\n                p = 0,\n                g = 0,\n                x = o.len,\n                y = n.len;\n              c ? (p = r, x = _m3) : (g = r, y = _m3);\n              var b = [[\"M\", p, g], [\"L\", x, g], [\"L\", x, y], [\"L\", p, y], [\"Z\"]],\n                v = [b[0]].concat(_toConsumableArray(s), [b[1], b[2]], _toConsumableArray(_f), [b[3], b[4]]);\n              _f = s.reverse(), _m3 = r, h && (_u2(v), t && _u2(b)), a ? (a.animate({\n                d: v\n              }), (_d6 = d) === null || _d6 === void 0 ? void 0 : _d6.animate({\n                d: b\n              })) : (a = e.clip = l.path(v), t && (d = e.simpleClip = l.path(b))), i && (_e$graph = e.graph) !== null && _e$graph !== void 0 && _e$graph.clip(a), t && ((_e$area = e.area) === null || _e$area === void 0 ? void 0 : _e$area.clip(d));\n            });\n          } else this.visible && (i && i.show(), t && t.show());\n        }\n      }, {\n        key: \"plotGroup\",\n        value: function plotGroup(t, e, i, s, r) {\n          var o = this[t],\n            n = !o,\n            a = {\n              visibility: i,\n              zIndex: s || .1\n            };\n          return C(this.opacity) && !this.chart.styledMode && \"inactive\" !== this.state && (a.opacity = this.opacity), o || (this[t] = o = this.chart.renderer.g().add(r)), o.addClass(\"highcharts-\" + e + \" highcharts-series-\" + this.index + \" highcharts-\" + this.type + \"-series \" + (C(this.colorIndex) ? \"highcharts-color-\" + this.colorIndex + \" \" : \"\") + (this.options.className || \"\") + (o.hasClass(\"highcharts-tracker\") ? \" highcharts-tracker\" : \"\"), !0), o.attr(a)[n ? \"attr\" : \"animate\"](this.getPlotBox(e)), o;\n        }\n      }, {\n        key: \"getPlotBox\",\n        value: function getPlotBox(t) {\n          var e = this.xAxis,\n            i = this.yAxis,\n            s = this.chart,\n            r = s.inverted && !s.polar && e && this.invertible && \"series\" === t;\n          return s.inverted && (e = i, i = this.xAxis), {\n            translateX: e ? e.left : s.plotLeft,\n            translateY: i ? i.top : s.plotTop,\n            rotation: r ? 90 : 0,\n            rotationOriginX: r ? (e.len - i.len) / 2 : 0,\n            rotationOriginY: r ? (e.len + i.len) / 2 : 0,\n            scaleX: r ? -1 : 1,\n            scaleY: 1\n          };\n        }\n      }, {\n        key: \"removeEvents\",\n        value: function removeEvents(t) {\n          var e = this.eventsToUnbind;\n          t || W(this), e.length && (e.forEach(function (t) {\n            t();\n          }), e.length = 0);\n        }\n      }, {\n        key: \"render\",\n        value: function render() {\n          var _t$animate, _t$drawDataLabels, _t$redrawPoints, _t$drawTracker, _t$animate2;\n          var t = this,\n            e = t.chart,\n            i = t.options,\n            s = t.hasRendered,\n            r = d(i.animation),\n            o = t.visible ? \"inherit\" : \"hidden\",\n            n = i.zIndex,\n            a = e.seriesGroup,\n            h = t.finishedAnimating ? 0 : r.duration;\n          L(this, \"render\"), t.plotGroup(\"group\", \"series\", o, n, a), t.markerGroup = t.plotGroup(\"markerGroup\", \"markers\", o, n, a), !1 !== i.clip && t.setClip(), h && (_t$animate = t.animate) !== null && _t$animate !== void 0 && _t$animate.call(t, !0), t.drawGraph && (t.drawGraph(), t.applyZones()), t.visible && t.drawPoints(), (_t$drawDataLabels = t.drawDataLabels) !== null && _t$drawDataLabels !== void 0 && _t$drawDataLabels.call(t), (_t$redrawPoints = t.redrawPoints) !== null && _t$redrawPoints !== void 0 && _t$redrawPoints.call(t), i.enableMouseTracking && (_t$drawTracker = t.drawTracker) !== null && _t$drawTracker !== void 0 && _t$drawTracker.call(t), h && (_t$animate2 = t.animate) !== null && _t$animate2 !== void 0 && _t$animate2.call(t), s || (h && r.defer && (h += r.defer), t.animationTimeout = H(function () {\n            t.afterAnimate();\n          }, h || 0)), t.isDirty = !1, t.hasRendered = !0, L(t, \"afterRender\");\n        }\n      }, {\n        key: \"redraw\",\n        value: function redraw() {\n          var t = this.isDirty || this.isDirtyData;\n          this.translate(), this.render(), t && delete this.kdTree;\n        }\n      }, {\n        key: \"reserveSpace\",\n        value: function reserveSpace() {\n          return this.visible || !this.chart.options.chart.ignoreHiddenSeries;\n        }\n      }, {\n        key: \"searchPoint\",\n        value: function searchPoint(t, e) {\n          var i = this.xAxis,\n            s = this.yAxis,\n            r = this.chart.inverted;\n          return this.searchKDTree({\n            clientX: r ? i.len - t.chartY + i.pos : t.chartX - i.pos,\n            plotY: r ? s.len - t.chartX + s.pos : t.chartY - s.pos\n          }, e, t);\n        }\n      }, {\n        key: \"buildKDTree\",\n        value: function buildKDTree(t) {\n          this.buildingKdTree = !0;\n          var e = this,\n            i = e.options.findNearestPointBy.indexOf(\"y\") > -1 ? 2 : 1;\n          delete e.kdTree, H(function () {\n            e.kdTree = function t(i, s, r) {\n              var o, n;\n              var a = i === null || i === void 0 ? void 0 : i.length;\n              if (a) return o = e.kdAxisArray[s % r], i.sort(function (t, e) {\n                return (t[o] || 0) - (e[o] || 0);\n              }), {\n                point: i[n = Math.floor(a / 2)],\n                left: t(i.slice(0, n), s + 1, r),\n                right: t(i.slice(n + 1), s + 1, r)\n              };\n            }(e.getValidPoints(void 0, !e.directTouch), i, i), e.buildingKdTree = !1;\n          }, e.options.kdNow || (t === null || t === void 0 ? void 0 : t.type) === \"touchstart\" ? 0 : 1);\n        }\n      }, {\n        key: \"searchKDTree\",\n        value: function searchKDTree(t, e, i) {\n          var s = this,\n            _this$kdAxisArray = _slicedToArray(this.kdAxisArray, 2),\n            r = _this$kdAxisArray[0],\n            o = _this$kdAxisArray[1],\n            n = e ? \"distX\" : \"dist\",\n            a = (s.options.findNearestPointBy || \"\").indexOf(\"y\") > -1 ? 2 : 1,\n            h = !!s.isBubble;\n          if (this.kdTree || this.buildingKdTree || this.buildKDTree(i), this.kdTree) return function t(e, i, a, l, _d$marker) {\n            var d = i.point,\n              c = s.kdAxisArray[a % l],\n              p,\n              u,\n              g = d;\n            !function (t, e, _e$marker) {\n              var i = t[r],\n                s = e[r],\n                n = C(i) && C(s) ? i - s : null,\n                a = t[o],\n                l = e[o],\n                d = C(a) && C(l) ? a - l : 0,\n                c = h && ((_e$marker = e.marker) === null || _e$marker === void 0 ? void 0 : _e$marker.radius) || 0;\n              e.dist = Math.sqrt((n && n * n || 0) + d * d) - c, e.distX = C(n) ? Math.abs(n) - c : Number.MAX_VALUE;\n            }(e, d);\n            var f = (e[c] || 0) - (d[c] || 0) + (h && ((_d$marker = d.marker) === null || _d$marker === void 0 ? void 0 : _d$marker.radius) || 0),\n              m = f < 0 ? \"left\" : \"right\",\n              x = f < 0 ? \"right\" : \"left\";\n            return i[m] && (g = (p = t(e, i[m], a + 1, l))[n] < g[n] ? p : d), i[x] && Math.sqrt(f * f) < g[n] && (g = (u = t(e, i[x], a + 1, l))[n] < g[n] ? u : g), g;\n          }(t, this.kdTree, a, a);\n        }\n      }, {\n        key: \"pointPlacementToXValue\",\n        value: function pointPlacementToXValue() {\n          var t = this.options,\n            e = this.xAxis,\n            i = t.pointPlacement;\n          return \"between\" === i && (i = e.reversed ? -.5 : .5), j(i) ? i * (t.pointRange || e.pointRange) : 0;\n        }\n      }, {\n        key: \"isPointInside\",\n        value: function isPointInside(t) {\n          var e = this.chart,\n            i = this.xAxis,\n            s = this.yAxis,\n            _t$plotX2 = t.plotX,\n            r = _t$plotX2 === void 0 ? -1 : _t$plotX2,\n            _t$plotY2 = t.plotY,\n            o = _t$plotY2 === void 0 ? -1 : _t$plotY2;\n          return o >= 0 && o <= (s ? s.len : e.plotHeight) && r >= 0 && r <= (i ? i.len : e.plotWidth);\n        }\n      }, {\n        key: \"drawTracker\",\n        value: function drawTracker() {\n          var _r$options$tooltip;\n          var t = this,\n            e = t.options,\n            i = e.trackByArea,\n            s = [].concat((i ? t.areaPath : t.graphPath) || []),\n            r = t.chart,\n            o = r.pointer,\n            n = r.renderer,\n            a = ((_r$options$tooltip = r.options.tooltip) === null || _r$options$tooltip === void 0 ? void 0 : _r$options$tooltip.snap) || 0,\n            h = function h() {\n              e.enableMouseTracking && r.hoverSeries !== t && t.onMouseOver();\n            },\n            l = \"rgba(192,192,192,\" + (g ? 1e-4 : .002) + \")\",\n            d = t.tracker;\n          d ? d.attr({\n            d: s\n          }) : t.graph && (t.tracker = d = n.path(s).attr({\n            visibility: t.visible ? \"inherit\" : \"hidden\",\n            zIndex: 2\n          }).addClass(i ? \"highcharts-tracker-area\" : \"highcharts-tracker-line\").add(t.group), r.styledMode || d.attr({\n            \"stroke-linecap\": \"round\",\n            \"stroke-linejoin\": \"round\",\n            stroke: l,\n            fill: i ? l : \"none\",\n            \"stroke-width\": t.graph.strokeWidth() + (i ? 0 : 2 * a)\n          }), [t.tracker, t.markerGroup, t.dataLabelsGroup].forEach(function (t) {\n            t && (t.addClass(\"highcharts-tracker\").on(\"mouseover\", h).on(\"mouseout\", function (t) {\n              o === null || o === void 0 || o.onTrackerMouseOut(t);\n            }), e.cursor && !r.styledMode && t.css({\n              cursor: e.cursor\n            }), t.on(\"touchstart\", h));\n          })), L(this, \"afterDrawTracker\");\n        }\n      }, {\n        key: \"addPoint\",\n        value: function addPoint(t, e, i, s, r) {\n          var o, n;\n          var a = this.options,\n            h = this.data,\n            l = this.chart,\n            d = this.xAxis,\n            c = d && d.hasNames && d.names,\n            p = a.data,\n            u = this.xData;\n          e = N(e, !0);\n          var g = {\n            series: this\n          };\n          this.pointClass.prototype.applyOptions.apply(g, [t]);\n          var f = g.x;\n          if (n = u.length, this.requireSorting && f < u[n - 1]) for (o = !0; n && u[n - 1] > f;) n--;\n          this.updateParallelArrays(g, \"splice\", [n, 0, 0]), this.updateParallelArrays(g, n), c && g.name && (c[f] = g.name), p.splice(n, 0, t), (o || this.processedData) && (this.data.splice(n, 0, null), this.processData()), \"point\" === a.legendType && this.generatePoints(), i && (h[0] && h[0].remove ? h[0].remove(!1) : (h.shift(), this.updateParallelArrays(g, \"shift\"), p.shift())), !1 !== r && L(this, \"addPoint\", {\n            point: g\n          }), this.isDirty = !0, this.isDirtyData = !0, e && l.redraw(s);\n        }\n      }, {\n        key: \"removePoint\",\n        value: function removePoint(t, e, i) {\n          var s = this,\n            r = s.data,\n            o = r[t],\n            n = s.points,\n            a = s.chart,\n            h = function h() {\n              n && n.length === r.length && n.splice(t, 1), r.splice(t, 1), s.options.data.splice(t, 1), s.updateParallelArrays(o || {\n                series: s\n              }, \"splice\", [t, 1]), o && o.destroy(), s.isDirty = !0, s.isDirtyData = !0, e && a.redraw();\n            };\n          c(i, a), e = N(e, !0), o ? o.firePointEvent(\"remove\", null, h) : h();\n        }\n      }, {\n        key: \"remove\",\n        value: function remove(t, e, i, s) {\n          var r = this,\n            o = r.chart;\n          function n() {\n            r.destroy(s), o.isDirtyLegend = o.isDirtyBox = !0, o.linkSeries(s), N(t, !0) && o.redraw(e);\n          }\n          !1 !== i ? L(r, \"remove\", null, n) : n();\n        }\n      }, {\n        key: \"update\",\n        value: function update(t, e) {\n          var _ref9, _n$series$pointStart, _n$series, _i$xData;\n          L(this, \"update\", {\n            options: t = M(t, this.userOptions)\n          });\n          var i = this,\n            s = i.chart,\n            r = i.userOptions,\n            o = i.initialType || i.type,\n            n = s.options.plotOptions,\n            a = m[o].prototype,\n            h = i.finishedAnimating && {\n              animation: !1\n            },\n            l = {},\n            d,\n            c,\n            p = [\"colorIndex\", \"eventOptions\", \"navigatorSeries\", \"symbolIndex\", \"baseSeries\"],\n            u = t.type || r.type || s.options.chart.type,\n            g = !(this.hasDerivedData || u && u !== this.type || void 0 !== t.pointStart || void 0 !== t.pointInterval || void 0 !== t.relativeXValue || t.joinBy || t.mapData || [\"dataGrouping\", \"pointStart\", \"pointInterval\", \"pointIntervalUnit\", \"keys\"].some(function (t) {\n              return i.hasOptionChanged(t);\n            }));\n          u = u || o, g && (p.push(\"data\", \"isDirtyData\", \"isDirtyCanvas\", \"points\", \"processedData\", \"processedXData\", \"processedYData\", \"xIncrement\", \"cropped\", \"_hasPointMarkers\", \"hasDataLabels\", \"nodes\", \"layout\", \"level\", \"mapMap\", \"mapData\", \"minY\", \"maxY\", \"minX\", \"maxX\", \"transformGroups\"), !1 !== t.visible && p.push(\"area\", \"graph\"), i.parallelArrays.forEach(function (t) {\n            p.push(t + \"Data\");\n          }), t.data && (t.dataSorting && T(i.options.dataSorting, t.dataSorting), this.setData(t.data, !1))), t = R(r, {\n            index: void 0 === r.index ? i.index : r.index,\n            pointStart: (_ref9 = (_n$series$pointStart = n === null || n === void 0 || (_n$series = n.series) === null || _n$series === void 0 ? void 0 : _n$series.pointStart) !== null && _n$series$pointStart !== void 0 ? _n$series$pointStart : r.pointStart) !== null && _ref9 !== void 0 ? _ref9 : (_i$xData = i.xData) === null || _i$xData === void 0 ? void 0 : _i$xData[0]\n          }, !g && {\n            data: i.options.data\n          }, t, h), g && t.data && (t.data = i.options.data), (p = [\"group\", \"markerGroup\", \"dataLabelsGroup\", \"transformGroup\"].concat(p)).forEach(function (t) {\n            p[t] = i[t], delete i[t];\n          });\n          var f = !1;\n          if (m[u]) {\n            if (f = u !== i.type, i.remove(!1, !1, !1, !0), f) {\n              if (s.propFromSeries(), Object.setPrototypeOf) Object.setPrototypeOf(i, m[u].prototype);else {\n                var _t65 = Object.hasOwnProperty.call(i, \"hcEvents\") && i.hcEvents;\n                for (c in a) i[c] = void 0;\n                T(i, m[u].prototype), _t65 ? i.hcEvents = _t65 : delete i.hcEvents;\n              }\n            }\n          } else A(17, !0, s, {\n            missingModuleFor: u\n          });\n          if (p.forEach(function (t) {\n            i[t] = p[t];\n          }), i.init(s, t), g && this.points) {\n            var _i$hasDataLabels;\n            var _iterator8 = _createForOfIteratorHelper((!1 === (d = i.options).visible ? (l.graphic = 1, l.dataLabel = 1) : (this.hasMarkerChanged(d, r) && (l.graphic = 1), ((_i$hasDataLabels = i.hasDataLabels) === null || _i$hasDataLabels === void 0 ? void 0 : _i$hasDataLabels.call(i)) || (l.dataLabel = 1)), this.points)),\n              _step8;\n            try {\n              for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n                var _t66 = _step8.value;\n                _t66 && _t66.series && (_t66.resolveColor(), Object.keys(l).length && _t66.destroyElements(l), !1 === d.showInLegend && _t66.legendItem && s.legend.destroyItem(_t66));\n              }\n            } catch (err) {\n              _iterator8.e(err);\n            } finally {\n              _iterator8.f();\n            }\n          }\n          i.initialType = o, s.linkSeries(), s.setSortedData(), f && i.linkedSeries.length && (i.isDirtyData = !0), L(this, \"afterUpdate\"), N(e, !0) && s.redraw(!!g && void 0);\n        }\n      }, {\n        key: \"setName\",\n        value: function setName(t) {\n          this.name = this.options.name = this.userOptions.name = t, this.chart.isDirtyLegend = !0;\n        }\n      }, {\n        key: \"hasOptionChanged\",\n        value: function hasOptionChanged(t) {\n          var _s$this$type, _s$series;\n          var e = this.chart,\n            i = this.options[t],\n            s = e.options.plotOptions,\n            r = this.userOptions[t],\n            o = N(s === null || s === void 0 || (_s$this$type = s[this.type]) === null || _s$this$type === void 0 ? void 0 : _s$this$type[t], s === null || s === void 0 || (_s$series = s.series) === null || _s$series === void 0 ? void 0 : _s$series[t]);\n          return r && !C(o) ? i !== r : i !== N(o, i);\n        }\n      }, {\n        key: \"onMouseOver\",\n        value: function onMouseOver() {\n          var t = this.chart,\n            e = t.hoverSeries,\n            i = t.pointer;\n          i !== null && i !== void 0 && i.setHoverChartIndex(), e && e !== this && e.onMouseOut(), this.options.events.mouseOver && L(this, \"mouseOver\"), this.setState(\"hover\"), t.hoverSeries = this;\n        }\n      }, {\n        key: \"onMouseOut\",\n        value: function onMouseOut() {\n          var t = this.options,\n            e = this.chart,\n            i = e.tooltip,\n            s = e.hoverPoint;\n          e.hoverSeries = null, s && s.onMouseOut(), this && t.events.mouseOut && L(this, \"mouseOut\"), i && !this.stickyTracking && (!i.shared || this.noSharedTooltip) && i.hide(), e.series.forEach(function (t) {\n            t.setState(\"\", !0);\n          });\n        }\n      }, {\n        key: \"setState\",\n        value: function setState(t, e) {\n          var i = this,\n            s = i.options,\n            r = i.graph,\n            o = s.inactiveOtherPoints,\n            n = s.states,\n            a = N(n[t || \"normal\"] && n[t || \"normal\"].animation, i.chart.options.chart.animation),\n            h = s.lineWidth,\n            l = s.opacity;\n          if (t = t || \"\", i.state !== t && ([i.group, i.markerGroup, i.dataLabelsGroup].forEach(function (e) {\n            e && (i.state && e.removeClass(\"highcharts-series-\" + i.state), t && e.addClass(\"highcharts-series-\" + t));\n          }), i.state = t, !i.chart.styledMode)) {\n            if (n[t] && !1 === n[t].enabled) return;\n            if (t && (h = n[t].lineWidth || h + (n[t].lineWidthPlus || 0), l = N(n[t].opacity, l)), r && !r.dashstyle && j(h)) for (var _i34 = 0, _arr = [r].concat(_toConsumableArray(this.zones.map(function (t) {\n                return t.graph;\n              }))); _i34 < _arr.length; _i34++) {\n              var _t67 = _arr[_i34];\n              _t67 === null || _t67 === void 0 || _t67.animate({\n                \"stroke-width\": h\n              }, a);\n            }\n            o || [i.group, i.markerGroup, i.dataLabelsGroup, i.labelBySeries].forEach(function (t) {\n              t && t.animate({\n                opacity: l\n              }, a);\n            });\n          }\n          e && o && i.points && i.setAllPointsToState(t || void 0);\n        }\n      }, {\n        key: \"setAllPointsToState\",\n        value: function setAllPointsToState(t) {\n          this.points.forEach(function (e) {\n            e.setState && e.setState(t);\n          });\n        }\n      }, {\n        key: \"setVisible\",\n        value: function setVisible(t, e) {\n          var _s$hoverPoint;\n          var i = this,\n            s = i.chart,\n            r = s.options.chart.ignoreHiddenSeries,\n            o = i.visible;\n          i.visible = t = i.options.visible = i.userOptions.visible = void 0 === t ? !o : t;\n          var n = t ? \"show\" : \"hide\";\n          [\"group\", \"dataLabelsGroup\", \"markerGroup\", \"tracker\", \"tt\"].forEach(function (t) {\n            var _i$t;\n            (_i$t = i[t]) === null || _i$t === void 0 || _i$t[n]();\n          }), (s.hoverSeries === i || ((_s$hoverPoint = s.hoverPoint) === null || _s$hoverPoint === void 0 ? void 0 : _s$hoverPoint.series) === i) && i.onMouseOut(), i.legendItem && s.legend.colorizeItem(i, t), i.isDirty = !0, i.options.stacking && s.series.forEach(function (t) {\n            t.options.stacking && t.visible && (t.isDirty = !0);\n          }), i.linkedSeries.forEach(function (e) {\n            e.setVisible(t, !1);\n          }), r && (s.isDirtyBox = !0), L(i, n), !1 !== e && s.redraw();\n        }\n      }, {\n        key: \"show\",\n        value: function show() {\n          this.setVisible(!0);\n        }\n      }, {\n        key: \"hide\",\n        value: function hide() {\n          this.setVisible(!1);\n        }\n      }, {\n        key: \"select\",\n        value: function select(t) {\n          this.selected = t = this.options.selected = void 0 === t ? !this.selected : t, this.checkbox && (this.checkbox.checked = t), L(this, t ? \"select\" : \"unselect\");\n        }\n      }, {\n        key: \"shouldShowTooltip\",\n        value: function shouldShowTooltip(t, e) {\n          var i = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n          return i.series = this, i.visiblePlotOnly = !0, this.chart.isInsidePlot(t, e, i);\n        }\n      }, {\n        key: \"drawLegendSymbol\",\n        value: function drawLegendSymbol(t, e) {\n          var _r16;\n          (_r16 = r[this.options.legendSymbol || \"rectangle\"]) === null || _r16 === void 0 || _r16.call(this, t, e);\n        }\n      }]);\n    }();\n    return X.defaultOptions = n, X.types = a.seriesTypes, X.registerType = a.registerSeriesType, T(X.prototype, {\n      axisTypes: [\"xAxis\", \"yAxis\"],\n      coll: \"series\",\n      colorCounter: 0,\n      directTouch: !1,\n      invertible: !0,\n      isCartesian: !0,\n      kdAxisArray: [\"clientX\", \"plotY\"],\n      parallelArrays: [\"x\", \"y\"],\n      pointClass: o,\n      requireSorting: !0,\n      sorted: !0\n    }), a.series = X, X;\n  }), i(e, \"Core/Legend/Legend.js\", [e[\"Core/Animation/AnimationUtilities.js\"], e[\"Core/Foundation.js\"], e[\"Core/Globals.js\"], e[\"Core/Series/Series.js\"], e[\"Core/Series/Point.js\"], e[\"Core/Renderer/RendererUtilities.js\"], e[\"Core/Templating.js\"], e[\"Core/Utilities.js\"]], function (t, e, i, s, r, o, n, a) {\n    var h;\n    var l = t.animObject,\n      d = t.setAnimation,\n      c = e.registerEventOptions,\n      p = i.composed,\n      u = i.marginNames,\n      g = o.distribute,\n      f = n.format,\n      m = a.addEvent,\n      x = a.createElement,\n      y = a.css,\n      b = a.defined,\n      v = a.discardElement,\n      S = a.find,\n      C = a.fireEvent,\n      k = a.isNumber,\n      M = a.merge,\n      w = a.pick,\n      A = a.pushUnique,\n      T = a.relativeLength,\n      P = a.stableSort,\n      L = a.syncTimeout;\n    var O = /*#__PURE__*/function () {\n      function O(t, e) {\n        var _this15 = this;\n        _classCallCheck(this, O);\n        this.allItems = [], this.initialItemY = 0, this.itemHeight = 0, this.itemMarginBottom = 0, this.itemMarginTop = 0, this.itemX = 0, this.itemY = 0, this.lastItemY = 0, this.lastLineHeight = 0, this.legendHeight = 0, this.legendWidth = 0, this.maxItemWidth = 0, this.maxLegendWidth = 0, this.offsetWidth = 0, this.padding = 0, this.pages = [], this.symbolHeight = 0, this.symbolWidth = 0, this.titleHeight = 0, this.totalItemWidth = 0, this.widthOption = 0, this.chart = t, this.setOptions(e), e.enabled && (this.render(), c(this, e), m(this.chart, \"endResize\", function () {\n          this.legend.positionCheckboxes();\n        })), m(this.chart, \"render\", function () {\n          _this15.options.enabled && _this15.proximate && (_this15.proximatePositions(), _this15.positionItems());\n        });\n      }\n      return _createClass(O, [{\n        key: \"setOptions\",\n        value: function setOptions(t) {\n          var e = w(t.padding, 8);\n          this.options = t, this.chart.styledMode || (this.itemStyle = t.itemStyle, this.itemHiddenStyle = M(this.itemStyle, t.itemHiddenStyle)), this.itemMarginTop = t.itemMarginTop, this.itemMarginBottom = t.itemMarginBottom, this.padding = e, this.initialItemY = e - 5, this.symbolWidth = w(t.symbolWidth, 16), this.pages = [], this.proximate = \"proximate\" === t.layout && !this.chart.inverted, this.baseline = void 0;\n        }\n      }, {\n        key: \"update\",\n        value: function update(t, e) {\n          var i = this.chart;\n          this.setOptions(M(!0, this.options, t)), \"events\" in this.options && c(this, this.options), this.destroy(), i.isDirtyLegend = i.isDirtyBox = !0, w(e, !0) && i.redraw(), C(this, \"afterUpdate\", {\n            redraw: e\n          });\n        }\n      }, {\n        key: \"colorizeItem\",\n        value: function colorizeItem(t, e) {\n          var _ref10 = t.legendItem || {},\n            i = _ref10.area,\n            s = _ref10.group,\n            r = _ref10.label,\n            o = _ref10.line,\n            n = _ref10.symbol;\n          if (s !== null && s !== void 0 && s[e ? \"removeClass\" : \"addClass\"](\"highcharts-legend-item-hidden\"), !this.chart.styledMode) {\n            var _this$itemHiddenStyle = this.itemHiddenStyle,\n              _s33 = _this$itemHiddenStyle === void 0 ? {} : _this$itemHiddenStyle,\n              _a14 = _s33.color,\n              _t$options = t.options,\n              _h8 = _t$options.fillColor,\n              _l6 = _t$options.fillOpacity,\n              _d7 = _t$options.lineColor,\n              _c7 = _t$options.marker,\n              _p6 = function _p6(t) {\n                return !e && (t.fill && (t.fill = _a14), t.stroke && (t.stroke = _a14)), t;\n              };\n            r !== null && r !== void 0 && r.css(M(e ? this.itemStyle : _s33)), o !== null && o !== void 0 && o.attr(_p6({\n              stroke: _d7 || t.color\n            })), n && n.attr(_p6(_c7 && n.isMarker ? t.pointAttribs() : {\n              fill: t.color\n            })), i === null || i === void 0 ? void 0 : i.attr(_p6({\n              fill: _h8 || t.color,\n              \"fill-opacity\": _h8 ? 1 : _l6 !== null && _l6 !== void 0 ? _l6 : .75\n            }));\n          }\n          C(this, \"afterColorizeItem\", {\n            item: t,\n            visible: e\n          });\n        }\n      }, {\n        key: \"positionItems\",\n        value: function positionItems() {\n          this.allItems.forEach(this.positionItem, this), this.chart.isResizing || this.positionCheckboxes();\n        }\n      }, {\n        key: \"positionItem\",\n        value: function positionItem(t) {\n          var _this16 = this;\n          var _ref11 = t.legendItem || {},\n            e = _ref11.group,\n            _ref11$x = _ref11.x,\n            i = _ref11$x === void 0 ? 0 : _ref11$x,\n            _ref11$y = _ref11.y,\n            s = _ref11$y === void 0 ? 0 : _ref11$y,\n            r = this.options,\n            o = r.symbolPadding,\n            n = !r.rtl,\n            a = t.checkbox;\n          if (e && e.element) {\n            var _r17 = {\n              translateX: n ? i : this.legendWidth - i - 2 * o - 4,\n              translateY: s\n            };\n            e[b(e.translateY) ? \"animate\" : \"attr\"](_r17, void 0, function () {\n              C(_this16, \"afterPositionItem\", {\n                item: t\n              });\n            });\n          }\n          a && (a.x = i, a.y = s);\n        }\n      }, {\n        key: \"destroyItem\",\n        value: function destroyItem(t) {\n          var e = t.checkbox,\n            i = t.legendItem || {};\n          for (var _i35 = 0, _arr2 = [\"group\", \"label\", \"line\", \"symbol\"]; _i35 < _arr2.length; _i35++) {\n            var _t68 = _arr2[_i35];\n            i[_t68] && (i[_t68] = i[_t68].destroy());\n          }\n          e && v(e), t.legendItem = void 0;\n        }\n      }, {\n        key: \"destroy\",\n        value: function destroy() {\n          var _iterator9 = _createForOfIteratorHelper(this.getAllItems()),\n            _step9;\n          try {\n            for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n              var _t70 = _step9.value;\n              this.destroyItem(_t70);\n            }\n          } catch (err) {\n            _iterator9.e(err);\n          } finally {\n            _iterator9.f();\n          }\n          for (var _i36 = 0, _arr3 = [\"clipRect\", \"up\", \"down\", \"pager\", \"nav\", \"box\", \"title\", \"group\"]; _i36 < _arr3.length; _i36++) {\n            var _t69 = _arr3[_i36];\n            this[_t69] && (this[_t69] = this[_t69].destroy());\n          }\n          this.display = null;\n        }\n      }, {\n        key: \"positionCheckboxes\",\n        value: function positionCheckboxes() {\n          var t;\n          var e = this.group && this.group.alignAttr,\n            i = this.clipHeight || this.legendHeight,\n            s = this.titleHeight;\n          e && (t = e.translateY, this.allItems.forEach(function (r) {\n            var o;\n            var n = r.checkbox;\n            n && (o = t + s + n.y + (this.scrollOffset || 0) + 3, y(n, {\n              left: e.translateX + r.checkboxOffset + n.x - 20 + \"px\",\n              top: o + \"px\",\n              display: this.proximate || o > t - 6 && o < t + i - 6 ? \"\" : \"none\"\n            }));\n          }, this));\n        }\n      }, {\n        key: \"renderTitle\",\n        value: function renderTitle() {\n          var t = this.options,\n            e = this.padding,\n            i = t.title,\n            s,\n            r = 0;\n          i.text && (this.title || (this.title = this.chart.renderer.label(i.text, e - 3, e - 4, void 0, void 0, void 0, t.useHTML, void 0, \"legend-title\").attr({\n            zIndex: 1\n          }), this.chart.styledMode || this.title.css(i.style), this.title.add(this.group)), i.width || this.title.css({\n            width: this.maxLegendWidth + \"px\"\n          }), r = (s = this.title.getBBox()).height, this.offsetWidth = s.width, this.contentGroup.attr({\n            translateY: r\n          })), this.titleHeight = r;\n        }\n      }, {\n        key: \"setText\",\n        value: function setText(t) {\n          var e = this.options;\n          t.legendItem.label.attr({\n            text: e.labelFormat ? f(e.labelFormat, t, this.chart) : e.labelFormatter.call(t)\n          });\n        }\n      }, {\n        key: \"renderItem\",\n        value: function renderItem(t) {\n          var e = t.legendItem = t.legendItem || {},\n            i = this.chart,\n            s = i.renderer,\n            r = this.options,\n            o = \"horizontal\" === r.layout,\n            n = this.symbolWidth,\n            a = r.symbolPadding || 0,\n            h = this.itemStyle,\n            l = this.itemHiddenStyle,\n            d = o ? w(r.itemDistance, 20) : 0,\n            c = !r.rtl,\n            p = !t.series,\n            u = !p && t.series.drawLegendSymbol ? t.series : t,\n            g = u.options,\n            f = !!this.createCheckboxForItem && g && g.showCheckbox,\n            m = r.useHTML,\n            x = t.options.className,\n            y = e.label,\n            b = n + a + d + (f ? 20 : 0);\n          !y && (e.group = s.g(\"legend-item\").addClass(\"highcharts-\" + u.type + \"-series highcharts-color-\" + t.colorIndex + (x ? \" \" + x : \"\") + (p ? \" highcharts-series-\" + t.index : \"\")).attr({\n            zIndex: 1\n          }).add(this.scrollGroup), e.label = y = s.text(\"\", c ? n + a : -a, this.baseline || 0, m), i.styledMode || y.css(M(t.visible ? h : l)), y.attr({\n            align: c ? \"left\" : \"right\",\n            zIndex: 2\n          }).add(e.group), !this.baseline && (this.fontMetrics = s.fontMetrics(y), this.baseline = this.fontMetrics.f + 3 + this.itemMarginTop, y.attr(\"y\", this.baseline), this.symbolHeight = w(r.symbolHeight, this.fontMetrics.f), r.squareSymbol && (this.symbolWidth = w(r.symbolWidth, Math.max(this.symbolHeight, 16)), b = this.symbolWidth + a + d + (f ? 20 : 0), c && y.attr(\"x\", this.symbolWidth + a))), u.drawLegendSymbol(this, t), this.setItemEvents && this.setItemEvents(t, y, m)), f && !t.checkbox && this.createCheckboxForItem && this.createCheckboxForItem(t), this.colorizeItem(t, t.visible), (i.styledMode || !h.width) && y.css({\n            width: (r.itemWidth || this.widthOption || i.spacingBox.width) - b + \"px\"\n          }), this.setText(t);\n          var v = y.getBBox(),\n            S = this.fontMetrics && this.fontMetrics.h || 0;\n          t.itemWidth = t.checkboxOffset = r.itemWidth || e.labelWidth || v.width + b, this.maxItemWidth = Math.max(this.maxItemWidth, t.itemWidth), this.totalItemWidth += t.itemWidth, this.itemHeight = t.itemHeight = Math.round(e.labelHeight || (v.height > 1.5 * S ? v.height : S));\n        }\n      }, {\n        key: \"layoutItem\",\n        value: function layoutItem(t) {\n          var e = this.options,\n            i = this.padding,\n            s = \"horizontal\" === e.layout,\n            r = t.itemHeight,\n            o = this.itemMarginBottom,\n            n = this.itemMarginTop,\n            a = s ? w(e.itemDistance, 20) : 0,\n            h = this.maxLegendWidth,\n            l = e.alignColumns && this.totalItemWidth > h ? this.maxItemWidth : t.itemWidth,\n            d = t.legendItem || {};\n          s && this.itemX - i + l > h && (this.itemX = i, this.lastLineHeight && (this.itemY += n + this.lastLineHeight + o), this.lastLineHeight = 0), this.lastItemY = n + this.itemY + o, this.lastLineHeight = Math.max(r, this.lastLineHeight), d.x = this.itemX, d.y = this.itemY, s ? this.itemX += l : (this.itemY += n + r + o, this.lastLineHeight = r), this.offsetWidth = this.widthOption || Math.max((s ? this.itemX - i - (t.checkbox ? 0 : a) : l) + i, this.offsetWidth);\n        }\n      }, {\n        key: \"getAllItems\",\n        value: function getAllItems() {\n          var t = [];\n          return this.chart.series.forEach(function (e) {\n            var i = e && e.options;\n            e && w(i.showInLegend, !b(i.linkedTo) && void 0, !0) && (t = t.concat((e.legendItem || {}).labels || (\"point\" === i.legendType ? e.data : e)));\n          }), C(this, \"afterGetAllItems\", {\n            allItems: t\n          }), t;\n        }\n      }, {\n        key: \"getAlignment\",\n        value: function getAlignment() {\n          var t = this.options;\n          return this.proximate ? t.align.charAt(0) + \"tv\" : t.floating ? \"\" : t.align.charAt(0) + t.verticalAlign.charAt(0) + t.layout.charAt(0);\n        }\n      }, {\n        key: \"adjustMargins\",\n        value: function adjustMargins(t, e) {\n          var i = this.chart,\n            s = this.options,\n            r = this.getAlignment();\n          r && [/(lth|ct|rth)/, /(rtv|rm|rbv)/, /(rbh|cb|lbh)/, /(lbv|lm|ltv)/].forEach(function (o, n) {\n            o.test(r) && !b(t[n]) && (i[u[n]] = Math.max(i[u[n]], i.legend[(n + 1) % 2 ? \"legendHeight\" : \"legendWidth\"] + [1, -1, -1, 1][n] * s[n % 2 ? \"x\" : \"y\"] + w(s.margin, 12) + e[n] + (i.titleOffset[n] || 0)));\n          });\n        }\n      }, {\n        key: \"proximatePositions\",\n        value: function proximatePositions() {\n          var t;\n          var e = this.chart,\n            i = [],\n            s = \"left\" === this.options.align;\n          var _iterator10 = _createForOfIteratorHelper((this.allItems.forEach(function (t) {\n              var r,\n                o,\n                n = s,\n                a,\n                h;\n              t.yAxis && (t.xAxis.options.reversed && (n = !n), t.points && (r = S(n ? t.points : t.points.slice(0).reverse(), function (t) {\n                return k(t.plotY);\n              })), o = this.itemMarginTop + t.legendItem.label.getBBox().height + this.itemMarginBottom, h = t.yAxis.top - e.plotTop, a = t.visible ? (r ? r.plotY : t.yAxis.height) + (h - .3 * o) : h + t.yAxis.height, i.push({\n                target: a,\n                size: o,\n                item: t\n              }));\n            }, this), g(i, e.plotHeight))),\n            _step10;\n          try {\n            for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {\n              var _r18 = _step10.value;\n              t = _r18.item.legendItem || {}, k(_r18.pos) && (t.y = e.plotTop - e.spacing[0] + _r18.pos);\n            }\n          } catch (err) {\n            _iterator10.e(err);\n          } finally {\n            _iterator10.f();\n          }\n        }\n      }, {\n        key: \"render\",\n        value: function render() {\n          var t = this.chart,\n            e = t.renderer,\n            i = this.options,\n            s = this.padding,\n            r = this.getAllItems(),\n            o,\n            n,\n            a,\n            h = this.group,\n            l,\n            d = this.box;\n          this.itemX = s, this.itemY = this.initialItemY, this.offsetWidth = 0, this.lastItemY = 0, this.widthOption = T(i.width, t.spacingBox.width - s), l = t.spacingBox.width - 2 * s - i.x, [\"rm\", \"lm\"].indexOf(this.getAlignment().substring(0, 2)) > -1 && (l /= 2), this.maxLegendWidth = this.widthOption || l, h || (this.group = h = e.g(\"legend\").addClass(i.className || \"\").attr({\n            zIndex: 7\n          }).add(), this.contentGroup = e.g().attr({\n            zIndex: 1\n          }).add(h), this.scrollGroup = e.g().add(this.contentGroup)), this.renderTitle(), P(r, function (t, e) {\n            return (t.options && t.options.legendIndex || 0) - (e.options && e.options.legendIndex || 0);\n          }), i.reversed && r.reverse(), this.allItems = r, this.display = o = !!r.length, this.lastLineHeight = 0, this.maxItemWidth = 0, this.totalItemWidth = 0, this.itemHeight = 0, r.forEach(this.renderItem, this), r.forEach(this.layoutItem, this), n = (this.widthOption || this.offsetWidth) + s, a = this.lastItemY + this.lastLineHeight + this.titleHeight, a = this.handleOverflow(a) + s, d || (this.box = d = e.rect().addClass(\"highcharts-legend-box\").attr({\n            r: i.borderRadius\n          }).add(h)), t.styledMode || d.attr({\n            stroke: i.borderColor,\n            \"stroke-width\": i.borderWidth || 0,\n            fill: i.backgroundColor || \"none\"\n          }).shadow(i.shadow), n > 0 && a > 0 && d[d.placed ? \"animate\" : \"attr\"](d.crisp.call({}, {\n            x: 0,\n            y: 0,\n            width: n,\n            height: a\n          }, d.strokeWidth())), h[o ? \"show\" : \"hide\"](), t.styledMode && \"none\" === h.getStyle(\"display\") && (n = a = 0), this.legendWidth = n, this.legendHeight = a, o && this.align(), this.proximate || this.positionItems(), C(this, \"afterRender\");\n        }\n      }, {\n        key: \"align\",\n        value: function align() {\n          var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.chart.spacingBox;\n          var e = this.chart,\n            i = this.options,\n            s = t.y;\n          /(lth|ct|rth)/.test(this.getAlignment()) && e.titleOffset[0] > 0 ? s += e.titleOffset[0] : /(lbh|cb|rbh)/.test(this.getAlignment()) && e.titleOffset[2] > 0 && (s -= e.titleOffset[2]), s !== t.y && (t = M(t, {\n            y: s\n          })), e.hasRendered || (this.group.placed = !1), this.group.align(M(i, {\n            width: this.legendWidth,\n            height: this.legendHeight,\n            verticalAlign: this.proximate ? \"top\" : i.verticalAlign\n          }), !0, t);\n        }\n      }, {\n        key: \"handleOverflow\",\n        value: function handleOverflow(t) {\n          var e = this,\n            i = this.chart,\n            s = i.renderer,\n            r = this.options,\n            o = r.y,\n            n = \"top\" === r.verticalAlign,\n            a = this.padding,\n            h = r.maxHeight,\n            l = r.navigation,\n            d = w(l.animation, !0),\n            c = l.arrowSize || 12,\n            p = this.pages,\n            u = this.allItems,\n            g = function g(t) {\n              \"number\" == typeof t ? S.attr({\n                height: t\n              }) : S && (e.clipRect = S.destroy(), e.contentGroup.clip()), e.contentGroup.div && (e.contentGroup.div.style.clip = t ? \"rect(\" + a + \"px,9999px,\" + (a + t) + \"px,0)\" : \"auto\");\n            },\n            f = function f(t) {\n              return e[t] = s.circle(0, 0, 1.3 * c).translate(c / 2, c / 2).add(v), i.styledMode || e[t].attr(\"fill\", \"rgba(0,0,0,0.0001)\"), e[t];\n            },\n            m,\n            x,\n            y,\n            b = i.spacingBox.height + (n ? -o : o) - a,\n            v = this.nav,\n            S = this.clipRect;\n          return \"horizontal\" !== r.layout || \"middle\" === r.verticalAlign || r.floating || (b /= 2), h && (b = Math.min(b, h)), p.length = 0, t && b > 0 && t > b && !1 !== l.enabled ? (this.clipHeight = m = Math.max(b - 20 - this.titleHeight - a, 0), this.currentPage = w(this.currentPage, 1), this.fullHeight = t, u.forEach(function (t, e) {\n            var i = (y = t.legendItem || {}).y || 0,\n              s = Math.round(y.label.getBBox().height),\n              r = p.length;\n            (!r || i - p[r - 1] > m && (x || i) !== p[r - 1]) && (p.push(x || i), r++), y.pageIx = r - 1, x && ((u[e - 1].legendItem || {}).pageIx = r - 1), e === u.length - 1 && i + s - p[r - 1] > m && i > p[r - 1] && (p.push(i), y.pageIx = r), i !== x && (x = i);\n          }), S || (S = e.clipRect = s.clipRect(0, a - 2, 9999, 0), e.contentGroup.clip(S)), g(m), v || (this.nav = v = s.g().attr({\n            zIndex: 1\n          }).add(this.group), this.up = s.symbol(\"triangle\", 0, 0, c, c).add(v), f(\"upTracker\").on(\"click\", function () {\n            e.scroll(-1, d);\n          }), this.pager = s.text(\"\", 15, 10).addClass(\"highcharts-legend-navigation\"), !i.styledMode && l.style && this.pager.css(l.style), this.pager.add(v), this.down = s.symbol(\"triangle-down\", 0, 0, c, c).add(v), f(\"downTracker\").on(\"click\", function () {\n            e.scroll(1, d);\n          })), e.scroll(0), t = b) : v && (g(), this.nav = v.destroy(), this.scrollGroup.attr({\n            translateY: 1\n          }), this.clipHeight = 0), t;\n        }\n      }, {\n        key: \"scroll\",\n        value: function scroll(t, e) {\n          var _this17 = this;\n          var i = this.chart,\n            s = this.pages,\n            r = s.length,\n            o = this.clipHeight,\n            n = this.options.navigation,\n            a = this.pager,\n            h = this.padding,\n            c = this.currentPage + t;\n          c > r && (c = r), c > 0 && (void 0 !== e && d(e, i), this.nav.attr({\n            translateX: h,\n            translateY: o + this.padding + 7 + this.titleHeight,\n            visibility: \"inherit\"\n          }), [this.up, this.upTracker].forEach(function (t) {\n            t.attr({\n              \"class\": 1 === c ? \"highcharts-legend-nav-inactive\" : \"highcharts-legend-nav-active\"\n            });\n          }), a.attr({\n            text: c + \"/\" + r\n          }), [this.down, this.downTracker].forEach(function (t) {\n            t.attr({\n              x: 18 + this.pager.getBBox().width,\n              \"class\": c === r ? \"highcharts-legend-nav-inactive\" : \"highcharts-legend-nav-active\"\n            });\n          }, this), i.styledMode || (this.up.attr({\n            fill: 1 === c ? n.inactiveColor : n.activeColor\n          }), this.upTracker.css({\n            cursor: 1 === c ? \"default\" : \"pointer\"\n          }), this.down.attr({\n            fill: c === r ? n.inactiveColor : n.activeColor\n          }), this.downTracker.css({\n            cursor: c === r ? \"default\" : \"pointer\"\n          })), this.scrollOffset = -s[c - 1] + this.initialItemY, this.scrollGroup.animate({\n            translateY: this.scrollOffset\n          }), this.currentPage = c, this.positionCheckboxes(), L(function () {\n            C(_this17, \"afterScroll\", {\n              currentPage: c\n            });\n          }, l(w(e, i.renderer.globalAnimation, !0)).duration));\n        }\n      }, {\n        key: \"setItemEvents\",\n        value: function setItemEvents(t, e, i) {\n          var o = this,\n            n = t.legendItem || {},\n            a = o.chart.renderer.boxWrapper,\n            h = t instanceof r,\n            l = t instanceof s,\n            d = \"highcharts-legend-\" + (h ? \"point\" : \"series\") + \"-active\",\n            c = o.chart.styledMode,\n            p = i ? [e, n.symbol] : [n.group],\n            u = function u(e) {\n              o.allItems.forEach(function (i) {\n                t !== i && [i].concat(i.linkedSeries || []).forEach(function (t) {\n                  t.setState(e, !h);\n                });\n              });\n            };\n          for (var _i37 = 0, _p7 = p; _i37 < _p7.length; _i37++) {\n            var _i38 = _p7[_i37];\n            _i38 && _i38.on(\"mouseover\", function () {\n              t.visible && u(\"inactive\"), t.setState(\"hover\"), t.visible && a.addClass(d), c || e.css(o.options.itemHoverStyle);\n            }).on(\"mouseout\", function () {\n              o.chart.styledMode || e.css(M(t.visible ? o.itemStyle : o.itemHiddenStyle)), u(\"\"), a.removeClass(d), t.setState();\n            }).on(\"click\", function (e) {\n              var i = function i() {\n                t.setVisible && t.setVisible(), u(t.visible ? \"inactive\" : \"\");\n              };\n              a.removeClass(d), C(o, \"itemClick\", {\n                browserEvent: e,\n                legendItem: t\n              }, i), h ? t.firePointEvent(\"legendItemClick\", {\n                browserEvent: e\n              }) : l && C(t, \"legendItemClick\", {\n                browserEvent: e\n              });\n            });\n          }\n        }\n      }, {\n        key: \"createCheckboxForItem\",\n        value: function createCheckboxForItem(t) {\n          t.checkbox = x(\"input\", {\n            type: \"checkbox\",\n            className: \"highcharts-legend-checkbox\",\n            checked: t.selected,\n            defaultChecked: t.selected\n          }, this.options.itemCheckboxStyle, this.chart.container), m(t.checkbox, \"click\", function (e) {\n            var i = e.target;\n            C(t.series || t, \"checkboxClick\", {\n              checked: i.checked,\n              item: t\n            }, function () {\n              t.select();\n            });\n          });\n        }\n      }]);\n    }();\n    return (h = O || (O = {})).compose = function (t) {\n      A(p, \"Core.Legend\") && m(t, \"beforeMargins\", function () {\n        this.legend = new h(this, this.options.legend);\n      });\n    }, O;\n  }), i(e, \"Core/Chart/Chart.js\", [e[\"Core/Animation/AnimationUtilities.js\"], e[\"Core/Axis/Axis.js\"], e[\"Core/Defaults.js\"], e[\"Core/Templating.js\"], e[\"Core/Foundation.js\"], e[\"Core/Globals.js\"], e[\"Core/Renderer/RendererRegistry.js\"], e[\"Core/Series/Series.js\"], e[\"Core/Series/SeriesRegistry.js\"], e[\"Core/Renderer/SVG/SVGRenderer.js\"], e[\"Core/Time.js\"], e[\"Core/Utilities.js\"], e[\"Core/Renderer/HTML/AST.js\"], e[\"Core/Axis/Tick.js\"]], function (t, e, i, s, r, o, n, a, h, l, d, c, p, u) {\n    var g = t.animate,\n      f = t.animObject,\n      m = t.setAnimation,\n      x = i.defaultOptions,\n      y = i.defaultTime,\n      b = s.numberFormat,\n      v = r.registerEventOptions,\n      S = o.charts,\n      C = o.doc,\n      k = o.marginNames,\n      M = o.svg,\n      w = o.win,\n      A = h.seriesTypes,\n      T = c.addEvent,\n      P = c.attr,\n      L = c.createElement,\n      O = c.css,\n      D = c.defined,\n      E = c.diffObjects,\n      I = c.discardElement,\n      j = c.erase,\n      B = c.error,\n      R = c.extend,\n      z = c.find,\n      N = c.fireEvent,\n      W = c.getStyle,\n      G = c.isArray,\n      H = c.isNumber,\n      X = c.isObject,\n      F = c.isString,\n      Y = c.merge,\n      U = c.objectEach,\n      V = c.pick,\n      $ = c.pInt,\n      Z = c.relativeLength,\n      _ = c.removeEvent,\n      q = c.splat,\n      K = c.syncTimeout,\n      J = c.uniqueKey;\n    var Q = /*#__PURE__*/function () {\n      function Q(t, e, i) {\n        _classCallCheck(this, Q);\n        this.sharedClips = {};\n        var s = Array.prototype.slice.call(arguments);\n        (F(t) || t.nodeName) && (this.renderTo = s.shift()), this.init(s[0], s[1]);\n      }\n      return _createClass(Q, [{\n        key: \"setZoomOptions\",\n        value: function setZoomOptions() {\n          var t = this.options.chart,\n            e = t.zooming;\n          this.zooming = _objectSpread(_objectSpread({}, e), {}, {\n            type: V(t.zoomType, e.type),\n            key: V(t.zoomKey, e.key),\n            pinchType: V(t.pinchType, e.pinchType),\n            singleTouch: V(t.zoomBySingleTouch, e.singleTouch, !1),\n            resetButton: Y(e.resetButton, t.resetZoomButton)\n          });\n        }\n      }, {\n        key: \"init\",\n        value: function init(t, e) {\n          N(this, \"init\", {\n            args: arguments\n          }, function () {\n            var i = Y(x, t),\n              s = i.chart;\n            this.userOptions = R({}, t), this.margin = [], this.spacing = [], this.labelCollectors = [], this.callback = e, this.isResizing = 0, this.options = i, this.axes = [], this.series = [], this.time = t.time && Object.keys(t.time).length ? new d(t.time) : o.time, this.numberFormatter = s.numberFormatter || b, this.styledMode = s.styledMode, this.hasCartesianSeries = s.showAxes, this.index = S.length, S.push(this), o.chartCount++, v(this, s), this.xAxis = [], this.yAxis = [], this.pointCount = this.colorCounter = this.symbolCounter = 0, this.setZoomOptions(), N(this, \"afterInit\"), this.firstRender();\n          });\n        }\n      }, {\n        key: \"initSeries\",\n        value: function initSeries(t) {\n          var e = this.options.chart,\n            i = t.type || e.type,\n            s = A[i];\n          s || B(17, !0, this, {\n            missingModuleFor: i\n          });\n          var r = new s();\n          return \"function\" == typeof r.init && r.init(this, t), r;\n        }\n      }, {\n        key: \"setSortedData\",\n        value: function setSortedData() {\n          this.getSeriesOrderByLinks().forEach(function (t) {\n            t.points || t.data || !t.enabledDataSorting || t.setData(t.options.data, !1);\n          });\n        }\n      }, {\n        key: \"getSeriesOrderByLinks\",\n        value: function getSeriesOrderByLinks() {\n          return this.series.concat().sort(function (t, e) {\n            return t.linkedSeries.length || e.linkedSeries.length ? e.linkedSeries.length - t.linkedSeries.length : 0;\n          });\n        }\n      }, {\n        key: \"orderItems\",\n        value: function orderItems(t) {\n          var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n          var i = this[t],\n            s = this.options[t] = q(this.options[t]).slice(),\n            r = this.userOptions[t] = this.userOptions[t] ? q(this.userOptions[t]).slice() : [];\n          if (this.hasRendered && (s.splice(e), r.splice(e)), i) for (var _t71 = e, _o23 = i.length; _t71 < _o23; ++_t71) {\n            var _e40 = i[_t71];\n            _e40 && (_e40.index = _t71, _e40 instanceof a && (_e40.name = _e40.getName()), _e40.options.isInternal || (s[_t71] = _e40.options, r[_t71] = _e40.userOptions));\n          }\n        }\n      }, {\n        key: \"isInsidePlot\",\n        value: function isInsidePlot(t, e) {\n          var _this$scrollablePlotA;\n          var i = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n          var s = this.inverted,\n            r = this.plotBox,\n            o = this.plotLeft,\n            n = this.plotTop,\n            a = this.scrollablePlotBox,\n            _ref12 = i.visiblePlotOnly && ((_this$scrollablePlotA = this.scrollablePlotArea) === null || _this$scrollablePlotA === void 0 ? void 0 : _this$scrollablePlotA.scrollingContainer) || {},\n            _ref12$scrollLeft = _ref12.scrollLeft,\n            h = _ref12$scrollLeft === void 0 ? 0 : _ref12$scrollLeft,\n            _ref12$scrollTop = _ref12.scrollTop,\n            l = _ref12$scrollTop === void 0 ? 0 : _ref12$scrollTop,\n            d = i.series,\n            c = i.visiblePlotOnly && a || r,\n            p = i.inverted ? e : t,\n            u = i.inverted ? t : e,\n            g = {\n              x: p,\n              y: u,\n              isInsidePlot: !0,\n              options: i\n            };\n          if (!i.ignoreX) {\n            var _t72 = d && (s && !this.polar ? d.yAxis : d.xAxis) || {\n                pos: o,\n                len: 1 / 0\n              },\n              _e41 = i.paneCoordinates ? _t72.pos + p : o + p;\n            _e41 >= Math.max(h + o, _t72.pos) && _e41 <= Math.min(h + o + c.width, _t72.pos + _t72.len) || (g.isInsidePlot = !1);\n          }\n          if (!i.ignoreY && g.isInsidePlot) {\n            var _t73 = !s && i.axis && !i.axis.isXAxis && i.axis || d && (s ? d.xAxis : d.yAxis) || {\n                pos: n,\n                len: 1 / 0\n              },\n              _e42 = i.paneCoordinates ? _t73.pos + u : n + u;\n            _e42 >= Math.max(l + n, _t73.pos) && _e42 <= Math.min(l + n + c.height, _t73.pos + _t73.len) || (g.isInsidePlot = !1);\n          }\n          return N(this, \"afterIsInsidePlot\", g), g.isInsidePlot;\n        }\n      }, {\n        key: \"redraw\",\n        value: function redraw(t) {\n          N(this, \"beforeRedraw\");\n          var e = this.hasCartesianSeries ? this.axes : this.colorAxis || [],\n            i = this.series,\n            s = this.pointer,\n            r = this.legend,\n            o = this.userOptions.legend,\n            n = this.renderer,\n            a = n.isHidden(),\n            h = [],\n            l,\n            d,\n            c,\n            p = this.isDirtyBox,\n            u = this.isDirtyLegend,\n            g;\n          for (n.rootFontSize = n.boxWrapper.getStyle(\"font-size\"), this.setResponsive && this.setResponsive(!1), m(!!this.hasRendered && t, this), a && this.temporaryDisplay(), this.layOutTitles(!1), c = i.length; c--;) if (((g = i[c]).options.stacking || g.options.centerInCategory) && (d = !0, g.isDirty)) {\n            l = !0;\n            break;\n          }\n          if (l) for (c = i.length; c--;) (g = i[c]).options.stacking && (g.isDirty = !0);\n          i.forEach(function (t) {\n            t.isDirty && (\"point\" === t.options.legendType ? (\"function\" == typeof t.updateTotals && t.updateTotals(), u = !0) : o && (o.labelFormatter || o.labelFormat) && (u = !0)), t.isDirtyData && N(t, \"updatedData\");\n          }), u && r && r.options.enabled && (r.render(), this.isDirtyLegend = !1), d && this.getStacks(), e.forEach(function (t) {\n            t.updateNames(), t.setScale();\n          }), this.getMargins(), e.forEach(function (t) {\n            t.isDirty && (p = !0);\n          }), e.forEach(function (t) {\n            var e = t.min + \",\" + t.max;\n            t.extKey !== e && (t.extKey = e, h.push(function () {\n              N(t, \"afterSetExtremes\", R(t.eventArgs, t.getExtremes())), delete t.eventArgs;\n            })), (p || d) && t.redraw();\n          }), p && this.drawChartBox(), N(this, \"predraw\"), i.forEach(function (t) {\n            (p || t.isDirty) && t.visible && t.redraw(), t.isDirtyData = !1;\n          }), s && s.reset(!0), n.draw(), N(this, \"redraw\"), N(this, \"render\"), a && this.temporaryDisplay(!0), h.forEach(function (t) {\n            t.call();\n          });\n        }\n      }, {\n        key: \"get\",\n        value: function get(t) {\n          var e = this.series;\n          function i(e) {\n            return e.id === t || e.options && e.options.id === t;\n          }\n          var s = z(this.axes, i) || z(this.series, i);\n          for (var _t74 = 0; !s && _t74 < e.length; _t74++) s = z(e[_t74].points || [], i);\n          return s;\n        }\n      }, {\n        key: \"getAxes\",\n        value: function getAxes() {\n          var t = this.userOptions;\n          for (var _i39 = 0, _arr4 = (N(this, \"getAxes\"), [\"xAxis\", \"yAxis\"]); _i39 < _arr4.length; _i39++) {\n            var _i40 = _arr4[_i39];\n            var _iterator11 = _createForOfIteratorHelper(t[_i40] = q(t[_i40] || {})),\n              _step11;\n            try {\n              for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {\n                var _s34 = _step11.value;\n                new e(this, _s34, _i40);\n              }\n            } catch (err) {\n              _iterator11.e(err);\n            } finally {\n              _iterator11.f();\n            }\n          }\n          N(this, \"afterGetAxes\");\n        }\n      }, {\n        key: \"getSelectedPoints\",\n        value: function getSelectedPoints() {\n          return this.series.reduce(function (t, e) {\n            return e.getPointsCollection().forEach(function (e) {\n              V(e.selectedStaging, e.selected) && t.push(e);\n            }), t;\n          }, []);\n        }\n      }, {\n        key: \"getSelectedSeries\",\n        value: function getSelectedSeries() {\n          return this.series.filter(function (t) {\n            return t.selected;\n          });\n        }\n      }, {\n        key: \"setTitle\",\n        value: function setTitle(t, e, i) {\n          this.applyDescription(\"title\", t), this.applyDescription(\"subtitle\", e), this.applyDescription(\"caption\", void 0), this.layOutTitles(i);\n        }\n      }, {\n        key: \"applyDescription\",\n        value: function applyDescription(t, e) {\n          var i = this,\n            s = this.options[t] = Y(this.options[t], e),\n            r = this[t];\n          r && e && (this[t] = r = r.destroy()), s && !r && ((r = this.renderer.text(s.text, 0, 0, s.useHTML).attr({\n            align: s.align,\n            \"class\": \"highcharts-\" + t,\n            zIndex: s.zIndex || 4\n          }).add()).update = function (e, s) {\n            i.applyDescription(t, e), i.layOutTitles(s);\n          }, this.styledMode || r.css(R(\"title\" === t ? {\n            fontSize: this.options.isStock ? \"1em\" : \"1.2em\"\n          } : {}, s.style)), this[t] = r);\n        }\n      }, {\n        key: \"layOutTitles\",\n        value: function layOutTitles() {\n          var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : !0;\n          var e = [0, 0, 0],\n            i = this.renderer,\n            s = this.spacingBox;\n          [\"title\", \"subtitle\", \"caption\"].forEach(function (t) {\n            var r = this[t],\n              o = this.options[t],\n              n = o.verticalAlign || \"top\",\n              a = \"title\" === t ? \"top\" === n ? -3 : 0 : \"top\" === n ? e[0] + 2 : 0;\n            if (r) {\n              r.css({\n                width: (o.width || s.width + (o.widthAdjust || 0)) + \"px\"\n              });\n              var _t75 = i.fontMetrics(r).b,\n                _h9 = Math.round(r.getBBox(o.useHTML).height);\n              r.align(R({\n                y: \"bottom\" === n ? _t75 : a + _t75,\n                height: _h9\n              }, o), !1, \"spacingBox\"), o.floating || (\"top\" === n ? e[0] = Math.ceil(e[0] + _h9) : \"bottom\" === n && (e[2] = Math.ceil(e[2] + _h9)));\n            }\n          }, this), e[0] && \"top\" === (this.options.title.verticalAlign || \"top\") && (e[0] += this.options.title.margin), e[2] && \"bottom\" === this.options.caption.verticalAlign && (e[2] += this.options.caption.margin);\n          var r = !this.titleOffset || this.titleOffset.join(\",\") !== e.join(\",\");\n          this.titleOffset = e, N(this, \"afterLayOutTitles\"), !this.isDirtyBox && r && (this.isDirtyBox = this.isDirtyLegend = r, this.hasRendered && t && this.isDirtyBox && this.redraw());\n        }\n      }, {\n        key: \"getContainerBox\",\n        value: function getContainerBox() {\n          return {\n            width: W(this.renderTo, \"width\", !0) || 0,\n            height: W(this.renderTo, \"height\", !0) || 0\n          };\n        }\n      }, {\n        key: \"getChartSize\",\n        value: function getChartSize() {\n          var t = this.options.chart,\n            e = t.width,\n            i = t.height,\n            s = this.getContainerBox();\n          this.chartWidth = Math.max(0, e || s.width || 600), this.chartHeight = Math.max(0, Z(i, this.chartWidth) || (s.height > 1 ? s.height : 400)), this.containerBox = s;\n        }\n      }, {\n        key: \"temporaryDisplay\",\n        value: function temporaryDisplay(t) {\n          var e = this.renderTo,\n            i;\n          if (t) for (; e && e.style;) e.hcOrigStyle && (O(e, e.hcOrigStyle), delete e.hcOrigStyle), e.hcOrigDetached && (C.body.removeChild(e), e.hcOrigDetached = !1), e = e.parentNode;else for (; e && e.style && (C.body.contains(e) || e.parentNode || (e.hcOrigDetached = !0, C.body.appendChild(e)), (\"none\" === W(e, \"display\", !1) || e.hcOricDetached) && (e.hcOrigStyle = {\n            display: e.style.display,\n            height: e.style.height,\n            overflow: e.style.overflow\n          }, i = {\n            display: \"block\",\n            overflow: \"hidden\"\n          }, e !== this.renderTo && (i.height = 0), O(e, i), e.offsetWidth || e.style.setProperty(\"display\", \"block\", \"important\")), (e = e.parentNode) !== C.body););\n        }\n      }, {\n        key: \"setClassName\",\n        value: function setClassName(t) {\n          this.container.className = \"highcharts-container \" + (t || \"\");\n        }\n      }, {\n        key: \"getContainer\",\n        value: function getContainer() {\n          var _e$style;\n          var t = this.options,\n            e = t.chart,\n            i = \"data-highcharts-chart\",\n            s = J(),\n            r,\n            o = this.renderTo;\n          o || (this.renderTo = o = e.renderTo), F(o) && (this.renderTo = o = C.getElementById(o)), o || B(13, !0, this);\n          var a = $(P(o, i));\n          H(a) && S[a] && S[a].hasRendered && S[a].destroy(), P(o, i, this.index), o.innerHTML = p.emptyHTML, e.skipClone || o.offsetWidth || this.temporaryDisplay(), this.getChartSize();\n          var h = this.chartHeight,\n            d = this.chartWidth;\n          O(o, {\n            overflow: \"hidden\"\n          }), this.styledMode || (r = R({\n            position: \"relative\",\n            overflow: \"hidden\",\n            width: d + \"px\",\n            height: h + \"px\",\n            textAlign: \"left\",\n            lineHeight: \"normal\",\n            zIndex: 0,\n            \"-webkit-tap-highlight-color\": \"rgba(0,0,0,0)\",\n            userSelect: \"none\",\n            \"touch-action\": \"manipulation\",\n            outline: \"none\"\n          }, e.style || {}));\n          var c = L(\"div\", {\n            id: s\n          }, r, o);\n          this.container = c, this.getChartSize(), d === this.chartWidth || (d = this.chartWidth, this.styledMode || O(c, {\n            width: V((_e$style = e.style) === null || _e$style === void 0 ? void 0 : _e$style.width, d + \"px\")\n          })), this.containerBox = this.getContainerBox(), this._cursor = c.style.cursor;\n          var u = e.renderer || !M ? n.getRendererType(e.renderer) : l;\n          if (this.renderer = new u(c, d, h, void 0, e.forExport, t.exporting && t.exporting.allowHTML, this.styledMode), m(void 0, this), this.setClassName(e.className), this.styledMode) for (var _e43 in t.defs) this.renderer.definition(t.defs[_e43]);else this.renderer.setStyle(e.style);\n          this.renderer.chartIndex = this.index, N(this, \"afterGetContainer\");\n        }\n      }, {\n        key: \"getMargins\",\n        value: function getMargins(t) {\n          var e = this.spacing,\n            i = this.margin,\n            s = this.titleOffset;\n          this.resetMargins(), s[0] && !D(i[0]) && (this.plotTop = Math.max(this.plotTop, s[0] + e[0])), s[2] && !D(i[2]) && (this.marginBottom = Math.max(this.marginBottom, s[2] + e[2])), this.legend && this.legend.display && this.legend.adjustMargins(i, e), N(this, \"getMargins\"), t || this.getAxisMargins();\n        }\n      }, {\n        key: \"getAxisMargins\",\n        value: function getAxisMargins() {\n          var t = this,\n            e = t.axisOffset = [0, 0, 0, 0],\n            i = t.colorAxis,\n            s = t.margin,\n            r = function r(t) {\n              t.forEach(function (t) {\n                t.visible && t.getOffset();\n              });\n            };\n          t.hasCartesianSeries ? r(t.axes) : i && i.length && r(i), k.forEach(function (i, r) {\n            D(s[r]) || (t[i] += e[r]);\n          }), t.setChartSize();\n        }\n      }, {\n        key: \"getOptions\",\n        value: function getOptions() {\n          return E(this.userOptions, x);\n        }\n      }, {\n        key: \"reflow\",\n        value: function reflow(t) {\n          var _e$pointer2;\n          var e = this,\n            i = e.containerBox,\n            s = e.getContainerBox();\n          (_e$pointer2 = e.pointer) === null || _e$pointer2 === void 0 || delete _e$pointer2.chartPosition, !e.isPrinting && !e.isResizing && i && s.width && ((s.width !== i.width || s.height !== i.height) && (c.clearTimeout(e.reflowTimeout), e.reflowTimeout = K(function () {\n            e.container && e.setSize(void 0, void 0, !1);\n          }, t ? 100 : 0)), e.containerBox = s);\n        }\n      }, {\n        key: \"setReflow\",\n        value: function setReflow() {\n          var t = this,\n            e = function e(_e44) {\n              var _t$options2;\n              ((_t$options2 = t.options) === null || _t$options2 === void 0 ? void 0 : _t$options2.chart.reflow) && t.hasLoaded && t.reflow(_e44);\n            };\n          if (\"function\" == typeof ResizeObserver) new ResizeObserver(e).observe(t.renderTo);else {\n            var _t76 = T(w, \"resize\", e);\n            T(this, \"destroy\", _t76);\n          }\n        }\n      }, {\n        key: \"setSize\",\n        value: function setSize(t, e, i) {\n          var s = this,\n            r = s.renderer;\n          s.isResizing += 1, m(i, s);\n          var o = r.globalAnimation;\n          s.oldChartHeight = s.chartHeight, s.oldChartWidth = s.chartWidth, void 0 !== t && (s.options.chart.width = t), void 0 !== e && (s.options.chart.height = e), s.getChartSize();\n          var n = s.chartWidth,\n            a = s.chartHeight,\n            _s$scrollablePixelsX = s.scrollablePixelsX,\n            h = _s$scrollablePixelsX === void 0 ? 0 : _s$scrollablePixelsX,\n            _s$scrollablePixelsY = s.scrollablePixelsY,\n            l = _s$scrollablePixelsY === void 0 ? 0 : _s$scrollablePixelsY;\n          (s.isDirtyBox || n !== s.oldChartWidth || a !== s.oldChartHeight) && (s.styledMode || (o ? g : O)(s.container, {\n            width: \"\".concat(n + h, \"px\"),\n            height: \"\".concat(a + l, \"px\")\n          }, o), s.setChartSize(!0), r.setSize(n, a, o), s.axes.forEach(function (t) {\n            t.isDirty = !0, t.setScale();\n          }), s.isDirtyLegend = !0, s.isDirtyBox = !0, s.layOutTitles(), s.getMargins(), s.redraw(o), s.oldChartHeight = void 0, N(s, \"resize\"), setTimeout(function () {\n            s && N(s, \"endResize\");\n          }, f(o).duration)), s.isResizing -= 1;\n        }\n      }, {\n        key: \"setChartSize\",\n        value: function setChartSize(t) {\n          var e, i, s, r;\n          var o = this.chartHeight,\n            n = this.chartWidth,\n            a = this.inverted,\n            h = this.spacing,\n            l = this.renderer,\n            d = this.clipOffset,\n            c = Math[a ? \"floor\" : \"round\"];\n          this.plotLeft = e = Math.round(this.plotLeft), this.plotTop = i = Math.round(this.plotTop), this.plotWidth = s = Math.max(0, Math.round(n - e - this.marginRight)), this.plotHeight = r = Math.max(0, Math.round(o - i - this.marginBottom)), this.plotSizeX = a ? r : s, this.plotSizeY = a ? s : r, this.spacingBox = l.spacingBox = {\n            x: h[3],\n            y: h[0],\n            width: n - h[3] - h[1],\n            height: o - h[0] - h[2]\n          }, this.plotBox = l.plotBox = {\n            x: e,\n            y: i,\n            width: s,\n            height: r\n          }, d && (this.clipBox = {\n            x: c(d[3]),\n            y: c(d[0]),\n            width: c(this.plotSizeX - d[1] - d[3]),\n            height: c(this.plotSizeY - d[0] - d[2])\n          }), t || (this.axes.forEach(function (t) {\n            t.setAxisSize(), t.setAxisTranslation();\n          }), l.alignElements()), N(this, \"afterSetChartSize\", {\n            skipAxes: t\n          });\n        }\n      }, {\n        key: \"resetMargins\",\n        value: function resetMargins() {\n          N(this, \"resetMargins\");\n          var t = this,\n            e = t.options.chart,\n            i = e.plotBorderWidth || 0,\n            s = i / 2;\n          [\"margin\", \"spacing\"].forEach(function (i) {\n            var s = e[i],\n              r = X(s) ? s : [s, s, s, s];\n            [\"Top\", \"Right\", \"Bottom\", \"Left\"].forEach(function (s, o) {\n              t[i][o] = V(e[i + s], r[o]);\n            });\n          }), k.forEach(function (e, i) {\n            t[e] = V(t.margin[i], t.spacing[i]);\n          }), t.axisOffset = [0, 0, 0, 0], t.clipOffset = [s, s, s, s], t.plotBorderWidth = i;\n        }\n      }, {\n        key: \"drawChartBox\",\n        value: function drawChartBox() {\n          var t = this.options.chart,\n            e = this.renderer,\n            i = this.chartWidth,\n            s = this.chartHeight,\n            r = this.styledMode,\n            o = this.plotBGImage,\n            n = t.backgroundColor,\n            a = t.plotBackgroundColor,\n            h = t.plotBackgroundImage,\n            l = this.plotLeft,\n            d = this.plotTop,\n            c = this.plotWidth,\n            p = this.plotHeight,\n            u = this.plotBox,\n            g = this.clipRect,\n            f = this.clipBox,\n            m = this.chartBackground,\n            x = this.plotBackground,\n            y = this.plotBorder,\n            b,\n            v,\n            S,\n            C = \"animate\";\n          m || (this.chartBackground = m = e.rect().addClass(\"highcharts-background\").add(), C = \"attr\"), r ? b = v = m.strokeWidth() : (v = (b = t.borderWidth || 0) + (t.shadow ? 8 : 0), S = {\n            fill: n || \"none\"\n          }, (b || m[\"stroke-width\"]) && (S.stroke = t.borderColor, S[\"stroke-width\"] = b), m.attr(S).shadow(t.shadow)), m[C]({\n            x: v / 2,\n            y: v / 2,\n            width: i - v - b % 2,\n            height: s - v - b % 2,\n            r: t.borderRadius\n          }), C = \"animate\", x || (C = \"attr\", this.plotBackground = x = e.rect().addClass(\"highcharts-plot-background\").add()), x[C](u), !r && (x.attr({\n            fill: a || \"none\"\n          }).shadow(t.plotShadow), h && (o ? (h !== o.attr(\"href\") && o.attr(\"href\", h), o.animate(u)) : this.plotBGImage = e.image(h, l, d, c, p).add())), g ? g.animate({\n            width: f.width,\n            height: f.height\n          }) : this.clipRect = e.clipRect(f), C = \"animate\", y || (C = \"attr\", this.plotBorder = y = e.rect().addClass(\"highcharts-plot-border\").attr({\n            zIndex: 1\n          }).add()), r || y.attr({\n            stroke: t.plotBorderColor,\n            \"stroke-width\": t.plotBorderWidth || 0,\n            fill: \"none\"\n          }), y[C](y.crisp({\n            x: l,\n            y: d,\n            width: c,\n            height: p\n          }, -y.strokeWidth())), this.isDirtyBox = !1, N(this, \"afterDrawChartBox\");\n        }\n      }, {\n        key: \"propFromSeries\",\n        value: function propFromSeries() {\n          var t, e, i;\n          var s = this,\n            r = s.options.chart,\n            o = s.options.series;\n          [\"inverted\", \"angular\", \"polar\"].forEach(function (n) {\n            for (e = A[r.type], i = r[n] || e && e.prototype[n], t = o && o.length; !i && t--;) (e = A[o[t].type]) && e.prototype[n] && (i = !0);\n            s[n] = i;\n          });\n        }\n      }, {\n        key: \"linkSeries\",\n        value: function linkSeries(t) {\n          var e = this,\n            i = e.series;\n          i.forEach(function (t) {\n            t.linkedSeries.length = 0;\n          }), i.forEach(function (t) {\n            var i = t.options.linkedTo;\n            if (F(i)) {\n              var _s35;\n              (_s35 = \":previous\" === i ? e.series[t.index - 1] : e.get(i)) && _s35.linkedParent !== t && (_s35.linkedSeries.push(t), t.linkedParent = _s35, _s35.enabledDataSorting && t.setDataSortingOptions(), t.visible = V(t.options.visible, _s35.options.visible, t.visible));\n            }\n          }), N(this, \"afterLinkSeries\", {\n            isUpdating: t\n          });\n        }\n      }, {\n        key: \"renderSeries\",\n        value: function renderSeries() {\n          this.series.forEach(function (t) {\n            t.translate(), t.render();\n          });\n        }\n      }, {\n        key: \"render\",\n        value: function render() {\n          var _this$getStacks;\n          var t = this.axes,\n            e = this.colorAxis,\n            i = this.renderer,\n            s = this.options.chart.axisLayoutRuns || 2,\n            r = function r(t) {\n              t.forEach(function (t) {\n                t.visible && t.render();\n              });\n            },\n            o = 0,\n            n = !0,\n            a,\n            h = 0;\n          var _iterator12 = _createForOfIteratorHelper((this.setTitle(), N(this, \"beforeMargins\"), (_this$getStacks = this.getStacks) !== null && _this$getStacks !== void 0 && _this$getStacks.call(this), this.getMargins(!0), this.setChartSize(), t)),\n            _step12;\n          try {\n            for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {\n              var _e47 = _step12.value;\n              var _t77 = _e47.options,\n                _i42 = _t77.labels;\n              if (this.hasCartesianSeries && _e47.horiz && _e47.visible && _i42.enabled && _e47.series.length && \"colorAxis\" !== _e47.coll && !this.polar) {\n                o = _t77.tickLength, _e47.createGroups();\n                var _s36 = new u(_e47, 0, \"\", !0),\n                  _r19 = _s36.createLabel(\"x\", _i42);\n                if (_s36.destroy(), _r19 && V(_i42.reserveSpace, !H(_t77.crossing)) && (o = _r19.getBBox().height + _i42.distance + Math.max(_t77.offset || 0, 0)), o) {\n                  _r19 === null || _r19 === void 0 || _r19.destroy();\n                  break;\n                }\n              }\n            }\n          } catch (err) {\n            _iterator12.e(err);\n          } finally {\n            _iterator12.f();\n          }\n          for (this.plotHeight = Math.max(this.plotHeight - o, 0); (n || a || s > 1) && h < s;) {\n            var _e45 = this.plotWidth,\n              _i41 = this.plotHeight;\n            var _iterator13 = _createForOfIteratorHelper(t),\n              _step13;\n            try {\n              for (_iterator13.s(); !(_step13 = _iterator13.n()).done;) {\n                var _e46 = _step13.value;\n                0 === h ? _e46.setScale() : (_e46.horiz && n || !_e46.horiz && a) && _e46.setTickInterval(!0);\n              }\n            } catch (err) {\n              _iterator13.e(err);\n            } finally {\n              _iterator13.f();\n            }\n            0 === h ? this.getAxisMargins() : this.getMargins(), n = _e45 / this.plotWidth > (h ? 1 : 1.1), a = _i41 / this.plotHeight > (h ? 1 : 1.05), h++;\n          }\n          this.drawChartBox(), this.hasCartesianSeries ? r(t) : e && e.length && r(e), this.seriesGroup || (this.seriesGroup = i.g(\"series-group\").attr({\n            zIndex: 3\n          }).shadow(this.options.chart.seriesGroupShadow).add()), this.renderSeries(), this.addCredits(), this.setResponsive && this.setResponsive(), this.hasRendered = !0;\n        }\n      }, {\n        key: \"addCredits\",\n        value: function addCredits(t) {\n          var e = this,\n            i = Y(!0, this.options.credits, t);\n          i.enabled && !this.credits && (this.credits = this.renderer.text(i.text + (this.mapCredits || \"\"), 0, 0).addClass(\"highcharts-credits\").on(\"click\", function () {\n            i.href && (w.location.href = i.href);\n          }).attr({\n            align: i.position.align,\n            zIndex: 8\n          }), e.styledMode || this.credits.css(i.style), this.credits.add().align(i.position), this.credits.update = function (t) {\n            e.credits = e.credits.destroy(), e.addCredits(t);\n          });\n        }\n      }, {\n        key: \"destroy\",\n        value: function destroy() {\n          var t;\n          var e = this,\n            i = e.axes,\n            s = e.series,\n            r = e.container,\n            n = r && r.parentNode;\n          for (N(e, \"destroy\"), e.renderer.forExport ? j(S, e) : S[e.index] = void 0, o.chartCount--, e.renderTo.removeAttribute(\"data-highcharts-chart\"), _(e), t = i.length; t--;) i[t] = i[t].destroy();\n          for (this.scroller && this.scroller.destroy && this.scroller.destroy(), t = s.length; t--;) s[t] = s[t].destroy();\n          [\"title\", \"subtitle\", \"chartBackground\", \"plotBackground\", \"plotBGImage\", \"plotBorder\", \"seriesGroup\", \"clipRect\", \"credits\", \"pointer\", \"rangeSelector\", \"legend\", \"resetZoomButton\", \"tooltip\", \"renderer\"].forEach(function (t) {\n            var i = e[t];\n            i && i.destroy && (e[t] = i.destroy());\n          }), r && (r.innerHTML = p.emptyHTML, _(r), n && I(r)), U(e, function (t, i) {\n            delete e[i];\n          });\n        }\n      }, {\n        key: \"firstRender\",\n        value: function firstRender() {\n          var _t$pointer;\n          var t = this,\n            e = t.options;\n          t.getContainer(), t.resetMargins(), t.setChartSize(), t.propFromSeries(), t.getAxes();\n          var i = G(e.series) ? e.series : [];\n          e.series = [], i.forEach(function (e) {\n            t.initSeries(e);\n          }), t.linkSeries(), t.setSortedData(), N(t, \"beforeRender\"), t.render(), (_t$pointer = t.pointer) !== null && _t$pointer !== void 0 && _t$pointer.getChartPosition(), t.renderer.imgCount || t.hasLoaded || t.onload(), t.temporaryDisplay(!0);\n        }\n      }, {\n        key: \"onload\",\n        value: function onload() {\n          this.callbacks.concat([this.callback]).forEach(function (t) {\n            t && void 0 !== this.index && t.apply(this, [this]);\n          }, this), N(this, \"load\"), N(this, \"render\"), D(this.index) && this.setReflow(), this.warnIfA11yModuleNotLoaded(), this.hasLoaded = !0;\n        }\n      }, {\n        key: \"warnIfA11yModuleNotLoaded\",\n        value: function warnIfA11yModuleNotLoaded() {\n          var t = this.options,\n            e = this.title;\n          !t || this.accessibility || (this.renderer.boxWrapper.attr({\n            role: \"img\",\n            \"aria-label\": (e && e.element.textContent || \"\").replace(/</g, \"&lt;\")\n          }), t.accessibility && !1 === t.accessibility.enabled || B('Highcharts warning: Consider including the \"accessibility.js\" module to make your chart more usable for people with disabilities. Set the \"accessibility.enabled\" option to false to remove this warning. See https://www.highcharts.com/docs/accessibility/accessibility-module.', !1, this));\n        }\n      }, {\n        key: \"addSeries\",\n        value: function addSeries(t, e, i) {\n          var s;\n          var r = this;\n          return t && (e = V(e, !0), N(r, \"addSeries\", {\n            options: t\n          }, function () {\n            s = r.initSeries(t), r.isDirtyLegend = !0, r.linkSeries(), s.enabledDataSorting && s.setData(t.data, !1), N(r, \"afterAddSeries\", {\n              series: s\n            }), e && r.redraw(i);\n          })), s;\n        }\n      }, {\n        key: \"addAxis\",\n        value: function addAxis(t, e, i, s) {\n          return this.createAxis(e ? \"xAxis\" : \"yAxis\", {\n            axis: t,\n            redraw: i,\n            animation: s\n          });\n        }\n      }, {\n        key: \"addColorAxis\",\n        value: function addColorAxis(t, e, i) {\n          return this.createAxis(\"colorAxis\", {\n            axis: t,\n            redraw: e,\n            animation: i\n          });\n        }\n      }, {\n        key: \"createAxis\",\n        value: function createAxis(t, i) {\n          var s = new e(this, i.axis, t);\n          return V(i.redraw, !0) && this.redraw(i.animation), s;\n        }\n      }, {\n        key: \"showLoading\",\n        value: function showLoading(t) {\n          var e = this,\n            i = e.options,\n            s = i.loading,\n            r = function r() {\n              o && O(o, {\n                left: e.plotLeft + \"px\",\n                top: e.plotTop + \"px\",\n                width: e.plotWidth + \"px\",\n                height: e.plotHeight + \"px\"\n              });\n            },\n            o = e.loadingDiv,\n            n = e.loadingSpan;\n          o || (e.loadingDiv = o = L(\"div\", {\n            className: \"highcharts-loading highcharts-loading-hidden\"\n          }, null, e.container)), n || (e.loadingSpan = n = L(\"span\", {\n            className: \"highcharts-loading-inner\"\n          }, null, o), T(e, \"redraw\", r)), o.className = \"highcharts-loading\", p.setElementHTML(n, V(t, i.lang.loading, \"\")), e.styledMode || (O(o, R(s.style, {\n            zIndex: 10\n          })), O(n, s.labelStyle), e.loadingShown || (O(o, {\n            opacity: 0,\n            display: \"\"\n          }), g(o, {\n            opacity: s.style.opacity || .5\n          }, {\n            duration: s.showDuration || 0\n          }))), e.loadingShown = !0, r();\n        }\n      }, {\n        key: \"hideLoading\",\n        value: function hideLoading() {\n          var t = this.options,\n            e = this.loadingDiv;\n          e && (e.className = \"highcharts-loading highcharts-loading-hidden\", this.styledMode || g(e, {\n            opacity: 0\n          }, {\n            duration: t.loading.hideDuration || 100,\n            complete: function complete() {\n              O(e, {\n                display: \"none\"\n              });\n            }\n          })), this.loadingShown = !1;\n        }\n      }, {\n        key: \"update\",\n        value: function update(t, e, i, s) {\n          var r, o, n;\n          var a = this,\n            h = {\n              credits: \"addCredits\",\n              title: \"setTitle\",\n              subtitle: \"setSubtitle\",\n              caption: \"setCaption\"\n            },\n            l = t.isResponsiveOptions,\n            c = [];\n          N(a, \"update\", {\n            options: t\n          }), l || a.setResponsive(!1, !0), t = E(t, a.options), a.userOptions = Y(a.userOptions, t);\n          var p = t.chart;\n          p && (Y(!0, a.options.chart, p), this.setZoomOptions(), \"className\" in p && a.setClassName(p.className), (\"inverted\" in p || \"polar\" in p || \"type\" in p) && (a.propFromSeries(), r = !0), \"alignTicks\" in p && (r = !0), \"events\" in p && v(this, p), U(p, function (t, e) {\n            -1 !== a.propsRequireUpdateSeries.indexOf(\"chart.\" + e) && (o = !0), -1 !== a.propsRequireDirtyBox.indexOf(e) && (a.isDirtyBox = !0), -1 === a.propsRequireReflow.indexOf(e) || (a.isDirtyBox = !0, l || (n = !0));\n          }), !a.styledMode && p.style && a.renderer.setStyle(a.options.chart.style || {})), !a.styledMode && t.colors && (this.options.colors = t.colors), t.time && (this.time === y && (this.time = new d(t.time)), Y(!0, a.options.time, t.time)), U(t, function (e, i) {\n            a[i] && \"function\" == typeof a[i].update ? a[i].update(e, !1) : \"function\" == typeof a[h[i]] ? a[h[i]](e) : \"colors\" !== i && -1 === a.collectionsWithUpdate.indexOf(i) && Y(!0, a.options[i], t[i]), \"chart\" !== i && -1 !== a.propsRequireUpdateSeries.indexOf(i) && (o = !0);\n          }), this.collectionsWithUpdate.forEach(function (e) {\n            t[e] && (q(t[e]).forEach(function (t, s) {\n              var r;\n              var o = D(t.id);\n              o && (r = a.get(t.id)), !r && a[e] && (r = a[e][V(t.index, s)]) && (o && D(r.options.id) || r.options.isInternal) && (r = void 0), r && r.coll === e && (r.update(t, !1), i && (r.touched = !0)), !r && i && a.collectionsWithInit[e] && (a.collectionsWithInit[e][0].apply(a, [t].concat(a.collectionsWithInit[e][1] || []).concat([!1])).touched = !0);\n            }), i && a[e].forEach(function (t) {\n              t.touched || t.options.isInternal ? delete t.touched : c.push(t);\n            }));\n          }), c.forEach(function (t) {\n            t.chart && t.remove && t.remove(!1);\n          }), r && a.axes.forEach(function (t) {\n            t.update({}, !1);\n          }), o && a.getSeriesOrderByLinks().forEach(function (t) {\n            t.chart && t.update({}, !1);\n          }, this);\n          var u = p && p.width,\n            g = p && (F(p.height) ? Z(p.height, u || a.chartWidth) : p.height);\n          n || H(u) && u !== a.chartWidth || H(g) && g !== a.chartHeight ? a.setSize(u, g, s) : V(e, !0) && a.redraw(s), N(a, \"afterUpdate\", {\n            options: t,\n            redraw: e,\n            animation: s\n          });\n        }\n      }, {\n        key: \"setSubtitle\",\n        value: function setSubtitle(t, e) {\n          this.applyDescription(\"subtitle\", t), this.layOutTitles(e);\n        }\n      }, {\n        key: \"setCaption\",\n        value: function setCaption(t, e) {\n          this.applyDescription(\"caption\", t), this.layOutTitles(e);\n        }\n      }, {\n        key: \"showResetZoom\",\n        value: function showResetZoom() {\n          var t = this,\n            e = x.lang,\n            i = t.zooming.resetButton,\n            s = i.theme,\n            r = \"chart\" === i.relativeTo || \"spacingBox\" === i.relativeTo ? null : \"plotBox\";\n          function o() {\n            t.zoomOut();\n          }\n          N(this, \"beforeShowResetZoom\", null, function () {\n            t.resetZoomButton = t.renderer.button(e.resetZoom, null, null, o, s).attr({\n              align: i.position.align,\n              title: e.resetZoomTitle\n            }).addClass(\"highcharts-reset-zoom\").add().align(i.position, !1, r);\n          }), N(this, \"afterShowResetZoom\");\n        }\n      }, {\n        key: \"zoomOut\",\n        value: function zoomOut() {\n          var _this18 = this;\n          N(this, \"selection\", {\n            resetSelection: !0\n          }, function () {\n            return _this18.transform({\n              reset: !0,\n              trigger: \"zoom\"\n            });\n          });\n        }\n      }, {\n        key: \"pan\",\n        value: function pan(t, e) {\n          var i = this,\n            s = \"object\" == _typeof(e) ? e : {\n              enabled: e,\n              type: \"x\"\n            },\n            r = s.type,\n            o = r && i[{\n              x: \"xAxis\",\n              xy: \"axes\",\n              y: \"yAxis\"\n            }[r]].filter(function (t) {\n              return t.options.panningEnabled && !t.options.isInternal;\n            }),\n            n = i.options.chart;\n          n !== null && n !== void 0 && n.panning && (n.panning = s), N(this, \"pan\", {\n            originalEvent: t\n          }, function () {\n            i.transform({\n              axes: o,\n              event: t,\n              to: {\n                x: t.chartX - (i.mouseDownX || 0),\n                y: t.chartY - (i.mouseDownY || 0)\n              },\n              trigger: \"pan\"\n            }), O(i.container, {\n              cursor: \"move\"\n            });\n          });\n        }\n      }, {\n        key: \"transform\",\n        value: function transform(t) {\n          var _this19 = this,\n            _this$options$chart$a,\n            _this$hoverPoints;\n          var _t$axes = t.axes,\n            e = _t$axes === void 0 ? this.axes : _t$axes,\n            i = t.event,\n            _t$from = t.from,\n            s = _t$from === void 0 ? {} : _t$from,\n            r = t.reset,\n            o = t.selection,\n            _t$to = t.to,\n            n = _t$to === void 0 ? {} : _t$to,\n            a = t.trigger,\n            h = this.inverted,\n            l = !1,\n            d,\n            c;\n          var _iterator14 = _createForOfIteratorHelper(((_this$hoverPoints = this.hoverPoints) !== null && _this$hoverPoints !== void 0 && _this$hoverPoints.forEach(function (t) {\n              return t.setState();\n            }), e)),\n            _step14;\n          try {\n            for (_iterator14.s(); !(_step14 = _iterator14.n()).done;) {\n              var _n$_x, _ref13, _g3$min, _g3$max;\n              var _t78 = _step14.value;\n              var _e48 = _t78.horiz,\n                _p8 = _t78.len,\n                _t78$minPointOffset = _t78.minPointOffset,\n                _u3 = _t78$minPointOffset === void 0 ? 0 : _t78$minPointOffset,\n                _g3 = _t78.options,\n                _f2 = _t78.reversed,\n                _m4 = _e48 ? \"width\" : \"height\",\n                _x4 = _e48 ? \"x\" : \"y\",\n                _y2 = V(n[_m4], _t78.len),\n                _b2 = V(s[_m4], _t78.len),\n                _v4 = 10 > Math.abs(_y2) ? 1 : _y2 / _b2,\n                _S4 = (s[_x4] || 0) + _b2 / 2 - _t78.pos,\n                _C = _S4 - (((_n$_x = n[_x4]) !== null && _n$_x !== void 0 ? _n$_x : _t78.pos) + _y2 / 2 - _t78.pos) / _v4,\n                _k3 = _f2 && !h || !_f2 && h ? -1 : 1;\n              if (!r && (_S4 < 0 || _S4 > _t78.len)) continue;\n              var _M2 = _t78.toValue(_C, !0) + (o ? 0 : _u3 * _k3),\n                _w2 = _t78.toValue(_C + _p8 / _v4, !0) - (o ? 0 : _u3 * _k3 || 0),\n                _A = _t78.allExtremes;\n              if (_M2 > _w2 && (_ref13 = [_w2, _M2], _M2 = _ref13[0], _w2 = _ref13[1], _ref13), 1 === _v4 && !r && \"yAxis\" === _t78.coll && !_A) {\n                var _iterator15 = _createForOfIteratorHelper(_t78.series),\n                  _step15;\n                try {\n                  for (_iterator15.s(); !(_step15 = _iterator15.n()).done;) {\n                    var _A2;\n                    var _e49 = _step15.value;\n                    var _t79 = _e49.getExtremes(_e49.getProcessedData(!0).yData, !0);\n                    (_A2 = _A) !== null && _A2 !== void 0 ? _A2 : _A = {\n                      dataMin: Number.MAX_VALUE,\n                      dataMax: -Number.MAX_VALUE\n                    }, H(_t79.dataMin) && H(_t79.dataMax) && (_A.dataMin = Math.min(_t79.dataMin, _A.dataMin), _A.dataMax = Math.max(_t79.dataMax, _A.dataMax));\n                  }\n                } catch (err) {\n                  _iterator15.e(err);\n                } finally {\n                  _iterator15.f();\n                }\n                _t78.allExtremes = _A;\n              }\n              var _R2 = R(_t78.getExtremes(), _A || {}),\n                _T3 = _R2.dataMin,\n                _P = _R2.dataMax,\n                _L = _R2.min,\n                _O2 = _R2.max,\n                _E = _T3 !== null && _T3 !== void 0 ? _T3 : _g3.min,\n                _I2 = _P !== null && _P !== void 0 ? _P : _g3.max,\n                _j2 = _w2 - _M2,\n                _B = _t78.categories ? 0 : Math.min(_j2, _I2 - _E),\n                _z = _E - _B * (D(_g3.min) ? 0 : _g3.minPadding),\n                _N = _I2 + _B * (D(_g3.max) ? 0 : _g3.maxPadding),\n                _W = _t78.allowZoomOutside || 1 === _v4 || \"zoom\" !== a && _v4 > 1,\n                _G = Math.min((_g3$min = _g3.min) !== null && _g3$min !== void 0 ? _g3$min : _z, _z, _W ? _L : _z),\n                _X = Math.max((_g3$max = _g3.max) !== null && _g3$max !== void 0 ? _g3$max : _N, _N, _W ? _O2 : _N);\n              (!_t78.isOrdinal || 1 !== _v4 || r) && (_M2 < _G && (_M2 = _G, _v4 >= 1 && (_w2 = _M2 + _j2)), _w2 > _X && (_w2 = _X, _v4 >= 1 && (_M2 = _w2 - _j2)), (r || _t78.series.length && (_M2 !== _L || _w2 !== _O2) && _M2 >= _G && _w2 <= _X) && (o ? o[_t78.coll].push({\n                axis: _t78,\n                min: _M2,\n                max: _w2\n              }) : (_t78.isPanning = \"zoom\" !== a, _t78.isPanning && (c = !0), _t78.setExtremes(r ? void 0 : _M2, r ? void 0 : _w2, !1, !1, {\n                move: _C,\n                trigger: a,\n                scale: _v4\n              }), !r && (_M2 > _G || _w2 < _X) && \"mousewheel\" !== a && (d = !0)), l = !0), i && (this[_e48 ? \"mouseDownX\" : \"mouseDownY\"] = i[_e48 ? \"chartX\" : \"chartY\"]));\n            }\n          } catch (err) {\n            _iterator14.e(err);\n          } finally {\n            _iterator14.f();\n          }\n          return l && (o ? N(this, \"selection\", o, function () {\n            delete t.selection, t.trigger = \"zoom\", _this19.transform(t);\n          }) : (!d || c || this.resetZoomButton ? !d && this.resetZoomButton && (this.resetZoomButton = this.resetZoomButton.destroy()) : this.showResetZoom(), this.redraw(\"zoom\" === a && ((_this$options$chart$a = this.options.chart.animation) !== null && _this$options$chart$a !== void 0 ? _this$options$chart$a : this.pointCount < 100)))), l;\n        }\n      }], [{\n        key: \"chart\",\n        value: function chart(t, e, i) {\n          return new Q(t, e, i);\n        }\n      }]);\n    }();\n    return R(Q.prototype, {\n      callbacks: [],\n      collectionsWithInit: {\n        xAxis: [Q.prototype.addAxis, [!0]],\n        yAxis: [Q.prototype.addAxis, [!1]],\n        series: [Q.prototype.addSeries]\n      },\n      collectionsWithUpdate: [\"xAxis\", \"yAxis\", \"series\"],\n      propsRequireDirtyBox: [\"backgroundColor\", \"borderColor\", \"borderWidth\", \"borderRadius\", \"plotBackgroundColor\", \"plotBackgroundImage\", \"plotBorderColor\", \"plotBorderWidth\", \"plotShadow\", \"shadow\"],\n      propsRequireReflow: [\"margin\", \"marginTop\", \"marginRight\", \"marginBottom\", \"marginLeft\", \"spacing\", \"spacingTop\", \"spacingRight\", \"spacingBottom\", \"spacingLeft\"],\n      propsRequireUpdateSeries: [\"chart.inverted\", \"chart.polar\", \"chart.ignoreHiddenSeries\", \"chart.type\", \"colors\", \"plotOptions\", \"time\", \"tooltip\"]\n    }), Q;\n  }), i(e, \"Extensions/ScrollablePlotArea.js\", [e[\"Core/Animation/AnimationUtilities.js\"], e[\"Core/Globals.js\"], e[\"Core/Renderer/RendererRegistry.js\"], e[\"Core/Utilities.js\"]], function (t, e, i, s) {\n    var r = t.stop,\n      o = e.composed,\n      n = s.addEvent,\n      a = s.createElement,\n      h = s.css,\n      l = s.defined,\n      d = s.merge,\n      c = s.pushUnique;\n    function p() {\n      var _t80;\n      var t = this.scrollablePlotArea;\n      (this.scrollablePixelsX || this.scrollablePixelsY) && !t && (this.scrollablePlotArea = t = new g(this)), (_t80 = t) === null || _t80 === void 0 ? void 0 : _t80.applyFixed();\n    }\n    function u() {\n      this.chart.scrollablePlotArea && (this.chart.scrollablePlotArea.isDirty = !0);\n    }\n    var g = /*#__PURE__*/function () {\n      function g(t) {\n        var _s$style, _o$opacity;\n        _classCallCheck(this, g);\n        var e;\n        var s = t.options.chart,\n          r = i.getRendererType(),\n          o = s.scrollablePlotArea || {},\n          l = this.moveFixedElements.bind(this),\n          d = {\n            WebkitOverflowScrolling: \"touch\",\n            overflowX: \"hidden\",\n            overflowY: \"hidden\"\n          };\n        t.scrollablePixelsX && (d.overflowX = \"auto\"), t.scrollablePixelsY && (d.overflowY = \"auto\"), this.chart = t;\n        var c = this.parentDiv = a(\"div\", {\n            className: \"highcharts-scrolling-parent\"\n          }, {\n            position: \"relative\"\n          }, t.renderTo),\n          p = this.scrollingContainer = a(\"div\", {\n            className: \"highcharts-scrolling\"\n          }, d, c),\n          u = this.innerContainer = a(\"div\", {\n            className: \"highcharts-inner-container\"\n          }, void 0, p),\n          _g4 = this.fixedDiv = a(\"div\", {\n            className: \"highcharts-fixed\"\n          }, {\n            position: \"absolute\",\n            overflow: \"hidden\",\n            pointerEvents: \"none\",\n            zIndex: (((_s$style = s.style) === null || _s$style === void 0 ? void 0 : _s$style.zIndex) || 0) + 2,\n            top: 0\n          }, void 0, !0),\n          f = this.fixedRenderer = new r(_g4, t.chartWidth, t.chartHeight, s.style);\n        this.mask = f.path().attr({\n          fill: s.backgroundColor || \"#fff\",\n          \"fill-opacity\": (_o$opacity = o.opacity) !== null && _o$opacity !== void 0 ? _o$opacity : .85,\n          zIndex: -1\n        }).addClass(\"highcharts-scrollable-mask\").add(), p.parentNode.insertBefore(_g4, p), h(t.renderTo, {\n          overflow: \"visible\"\n        }), n(t, \"afterShowResetZoom\", l), n(t, \"afterApplyDrilldown\", l), n(t, \"afterLayOutTitles\", l), n(p, \"scroll\", function () {\n          var i = t.pointer,\n            s = t.hoverPoint;\n          i && (delete i.chartPosition, s && (e = s), i.runPointActions(void 0, e, !0));\n        }), u.appendChild(t.container);\n      }\n      return _createClass(g, [{\n        key: \"applyFixed\",\n        value: function applyFixed() {\n          var _t$chartBackground;\n          var t = this.chart,\n            e = this.fixedRenderer,\n            i = this.isDirty,\n            s = this.scrollingContainer,\n            o = t.axisOffset,\n            n = t.chartWidth,\n            a = t.chartHeight,\n            d = t.container,\n            c = t.plotHeight,\n            p = t.plotLeft,\n            u = t.plotTop,\n            _g5 = t.plotWidth,\n            _t$scrollablePixelsX = t.scrollablePixelsX,\n            f = _t$scrollablePixelsX === void 0 ? 0 : _t$scrollablePixelsX,\n            _t$scrollablePixelsY = t.scrollablePixelsY,\n            m = _t$scrollablePixelsY === void 0 ? 0 : _t$scrollablePixelsY,\n            _ref14 = t.options.chart.scrollablePlotArea || {},\n            _ref14$scrollPosition = _ref14.scrollPositionX,\n            x = _ref14$scrollPosition === void 0 ? 0 : _ref14$scrollPosition,\n            _ref14$scrollPosition2 = _ref14.scrollPositionY,\n            y = _ref14$scrollPosition2 === void 0 ? 0 : _ref14$scrollPosition2,\n            b = n + f,\n            v = a + m;\n          e.setSize(n, a), (i !== null && i !== void 0 ? i : !0) && (this.isDirty = !1, this.moveFixedElements()), r(t.container), h(d, {\n            width: \"\".concat(b, \"px\"),\n            height: \"\".concat(v, \"px\")\n          }), t.renderer.boxWrapper.attr({\n            width: b,\n            height: v,\n            viewBox: [0, 0, b, v].join(\" \")\n          }), (_t$chartBackground = t.chartBackground) !== null && _t$chartBackground !== void 0 && _t$chartBackground.attr({\n            width: b,\n            height: v\n          }), h(s, {\n            width: \"\".concat(n, \"px\"),\n            height: \"\".concat(a, \"px\")\n          }), l(i) || (s.scrollLeft = f * x, s.scrollTop = m * y);\n          var S = u - o[0] - 1,\n            C = p - o[3] - 1,\n            k = u + c + o[2] + 1,\n            M = p + _g5 + o[1] + 1,\n            w = p + _g5 - f,\n            A = u + c - m,\n            T = [[\"M\", 0, 0]];\n          f ? T = [[\"M\", 0, S], [\"L\", p - 1, S], [\"L\", p - 1, k], [\"L\", 0, k], [\"Z\"], [\"M\", w, S], [\"L\", n, S], [\"L\", n, k], [\"L\", w, k], [\"Z\"]] : m && (T = [[\"M\", C, 0], [\"L\", C, u - 1], [\"L\", M, u - 1], [\"L\", M, 0], [\"Z\"], [\"M\", C, A], [\"L\", C, a], [\"L\", M, a], [\"L\", M, A], [\"Z\"]]), \"adjustHeight\" !== t.redrawTrigger && this.mask.attr({\n            d: T\n          });\n        }\n      }, {\n        key: \"moveFixedElements\",\n        value: function moveFixedElements() {\n          var t;\n          var _this$chart = this.chart,\n            e = _this$chart.container,\n            i = _this$chart.inverted,\n            s = _this$chart.scrollablePixelsX,\n            r = _this$chart.scrollablePixelsY,\n            o = this.fixedRenderer,\n            n = g.fixedSelectors;\n          var _iterator16 = _createForOfIteratorHelper((s && !i ? t = \".highcharts-yaxis\" : s && i ? t = \".highcharts-xaxis\" : r && !i ? t = \".highcharts-xaxis\" : r && i && (t = \".highcharts-yaxis\"), t && n.push(\"\".concat(t, \":not(.highcharts-radial-axis)\"), \"\".concat(t, \"-labels:not(.highcharts-radial-axis-labels)\")), n)),\n            _step16;\n          try {\n            for (_iterator16.s(); !(_step16 = _iterator16.n()).done;) {\n              var _a15 = _step16.value;\n              [].forEach.call(e.querySelectorAll(_a15), function (t) {\n                (t.namespaceURI === o.SVG_NS ? o.box : o.box.parentNode).appendChild(t), t.style.pointerEvents = \"auto\";\n              });\n            }\n          } catch (err) {\n            _iterator16.e(err);\n          } finally {\n            _iterator16.f();\n          }\n        }\n      }], [{\n        key: \"compose\",\n        value: function compose(t, e, i) {\n          var _this20 = this;\n          c(o, this.compose) && (n(t, \"afterInit\", u), n(e, \"afterSetChartSize\", function (t) {\n            return _this20.afterSetSize(t.target, t);\n          }), n(e, \"render\", p), n(i, \"show\", u));\n        }\n      }, {\n        key: \"afterSetSize\",\n        value: function afterSetSize(t, e) {\n          var i, s, r;\n          var _ref15 = t.options.chart.scrollablePlotArea || {},\n            o = _ref15.minWidth,\n            n = _ref15.minHeight,\n            a = t.clipBox,\n            h = t.plotBox,\n            c = t.inverted,\n            p = t.renderer;\n          if (!p.forExport && (o ? (t.scrollablePixelsX = i = Math.max(0, o - t.chartWidth), i && (t.scrollablePlotBox = d(t.plotBox), h.width = t.plotWidth += i, a[c ? \"height\" : \"width\"] += i, r = !0)) : n && (t.scrollablePixelsY = s = Math.max(0, n - t.chartHeight), l(s) && (t.scrollablePlotBox = d(t.plotBox), h.height = t.plotHeight += s, a[c ? \"width\" : \"height\"] += s, r = !1)), l(r) && !e.skipAxes)) {\n            var _iterator17 = _createForOfIteratorHelper(t.axes),\n              _step17;\n            try {\n              for (_iterator17.s(); !(_step17 = _iterator17.n()).done;) {\n                var _e50 = _step17.value;\n                _e50.horiz === r && (_e50.setAxisSize(), _e50.setAxisTranslation());\n              }\n            } catch (err) {\n              _iterator17.e(err);\n            } finally {\n              _iterator17.f();\n            }\n          }\n        }\n      }]);\n    }();\n    return g.fixedSelectors = [\".highcharts-breadcrumbs-group\", \".highcharts-contextbutton\", \".highcharts-caption\", \".highcharts-credits\", \".highcharts-drillup-button\", \".highcharts-legend\", \".highcharts-legend-checkbox\", \".highcharts-navigator-series\", \".highcharts-navigator-xaxis\", \".highcharts-navigator-yaxis\", \".highcharts-navigator\", \".highcharts-range-selector-group\", \".highcharts-reset-zoom\", \".highcharts-scrollbar\", \".highcharts-subtitle\", \".highcharts-title\"], g;\n  }), i(e, \"Core/Axis/Stacking/StackItem.js\", [e[\"Core/Templating.js\"], e[\"Core/Series/SeriesRegistry.js\"], e[\"Core/Utilities.js\"]], function (t, e, i) {\n    var s = t.format,\n      r = e.series,\n      o = i.destroyObjectProperties,\n      n = i.fireEvent,\n      a = i.isNumber,\n      h = i.pick;\n    return /*#__PURE__*/function () {\n      function _class3(t, e, i, s, r) {\n        _classCallCheck(this, _class3);\n        var o = t.chart.inverted,\n          n = t.reversed;\n        this.axis = t;\n        var a = this.isNegative = !!i != !!n;\n        this.options = e = e || {}, this.x = s, this.total = null, this.cumulative = null, this.points = {}, this.hasValidPoints = !1, this.stack = r, this.leftCliff = 0, this.rightCliff = 0, this.alignOptions = {\n          align: e.align || (o ? a ? \"left\" : \"right\" : \"center\"),\n          verticalAlign: e.verticalAlign || (o ? \"middle\" : a ? \"bottom\" : \"top\"),\n          y: e.y,\n          x: e.x\n        }, this.textAlign = e.textAlign || (o ? a ? \"right\" : \"left\" : \"center\");\n      }\n      return _createClass(_class3, [{\n        key: \"destroy\",\n        value: function destroy() {\n          o(this, this.axis);\n        }\n      }, {\n        key: \"render\",\n        value: function render(t) {\n          var e = this.axis.chart,\n            i = this.options,\n            r = i.format,\n            o = r ? s(r, this, e) : i.formatter.call(this);\n          if (this.label) this.label.attr({\n            text: o,\n            visibility: \"hidden\"\n          });else {\n            this.label = e.renderer.label(o, null, void 0, i.shape, void 0, void 0, i.useHTML, !1, \"stack-labels\");\n            var _s37 = {\n              r: i.borderRadius || 0,\n              text: o,\n              padding: h(i.padding, 5),\n              visibility: \"hidden\"\n            };\n            e.styledMode || (_s37.fill = i.backgroundColor, _s37.stroke = i.borderColor, _s37[\"stroke-width\"] = i.borderWidth, this.label.css(i.style || {})), this.label.attr(_s37), this.label.added || this.label.add(t);\n          }\n          this.label.labelrank = e.plotSizeY, n(this, \"afterRender\");\n        }\n      }, {\n        key: \"setOffset\",\n        value: function setOffset(t, e, i, s, o, l) {\n          var d = this.alignOptions,\n            c = this.axis,\n            p = this.label,\n            u = this.options,\n            g = this.textAlign,\n            f = c.chart,\n            m = this.getStackBox({\n              xOffset: t,\n              width: e,\n              boxBottom: i,\n              boxTop: s,\n              defaultX: o,\n              xAxis: l\n            }),\n            x = d.verticalAlign;\n          if (p && m) {\n            var _t81 = p.getBBox(void 0, 0),\n              _e51 = p.padding,\n              _i43 = \"justify\" === h(u.overflow, \"justify\"),\n              _s38;\n            d.x = u.x || 0, d.y = u.y || 0;\n            var _this$adjustStackPosi = this.adjustStackPosition({\n                labelBox: _t81,\n                verticalAlign: x,\n                textAlign: g\n              }),\n              _o24 = _this$adjustStackPosi.x,\n              _n12 = _this$adjustStackPosi.y;\n            m.x -= _o24, m.y -= _n12, p.align(d, !1, m), (_s38 = f.isInsidePlot(p.alignAttr.x + d.x + _o24, p.alignAttr.y + d.y + _n12)) || (_i43 = !1), _i43 && r.prototype.justifyDataLabel.call(c, p, d, p.alignAttr, _t81, m), p.attr({\n              x: p.alignAttr.x,\n              y: p.alignAttr.y,\n              rotation: u.rotation,\n              rotationOriginX: _t81.width * {\n                left: 0,\n                center: .5,\n                right: 1\n              }[u.textAlign || \"center\"],\n              rotationOriginY: _t81.height / 2\n            }), h(!_i43 && u.crop, !0) && (_s38 = a(p.x) && a(p.y) && f.isInsidePlot(p.x - _e51 + (p.width || 0), p.y) && f.isInsidePlot(p.x + _e51, p.y)), p[_s38 ? \"show\" : \"hide\"]();\n          }\n          n(this, \"afterSetOffset\", {\n            xOffset: t,\n            width: e\n          });\n        }\n      }, {\n        key: \"adjustStackPosition\",\n        value: function adjustStackPosition(_ref16) {\n          var t = _ref16.labelBox,\n            e = _ref16.verticalAlign,\n            i = _ref16.textAlign;\n          var s = {\n              bottom: 0,\n              middle: 1,\n              top: 2,\n              right: 1,\n              center: 0,\n              left: -1\n            },\n            r = s[e],\n            o = s[i];\n          return {\n            x: t.width / 2 + t.width / 2 * o,\n            y: t.height / 2 * r\n          };\n        }\n      }, {\n        key: \"getStackBox\",\n        value: function getStackBox(t) {\n          var e = this.axis,\n            i = e.chart,\n            s = t.boxTop,\n            r = t.defaultX,\n            o = t.xOffset,\n            n = t.width,\n            l = t.boxBottom,\n            d = e.stacking.usePercentage ? 100 : h(s, this.total, 0),\n            c = e.toPixels(d),\n            p = t.xAxis || i.xAxis[0],\n            u = h(r, p.translate(this.x)) + o,\n            g = Math.abs(c - e.toPixels(l || a(e.min) && e.logarithmic && e.logarithmic.lin2log(e.min) || 0)),\n            f = i.inverted,\n            m = this.isNegative;\n          return f ? {\n            x: (m ? c : c - g) - i.plotLeft,\n            y: p.height - u - n + p.top - i.plotTop,\n            width: g,\n            height: n\n          } : {\n            x: u + p.transB - i.plotLeft,\n            y: (m ? c - g : c) - i.plotTop,\n            width: n,\n            height: g\n          };\n        }\n      }]);\n    }();\n  }), i(e, \"Core/Axis/Stacking/StackingAxis.js\", [e[\"Core/Animation/AnimationUtilities.js\"], e[\"Core/Axis/Axis.js\"], e[\"Core/Series/SeriesRegistry.js\"], e[\"Core/Axis/Stacking/StackItem.js\"], e[\"Core/Utilities.js\"]], function (t, e, i, s, r) {\n    var o;\n    var n = t.getDeferredAnimation,\n      a = i.series.prototype,\n      h = r.addEvent,\n      l = r.correctFloat,\n      d = r.defined,\n      c = r.destroyObjectProperties,\n      p = r.fireEvent,\n      u = r.isArray,\n      g = r.isNumber,\n      f = r.objectEach,\n      m = r.pick;\n    function x() {\n      var t = this.inverted;\n      this.axes.forEach(function (t) {\n        t.stacking && t.stacking.stacks && t.hasVisibleSeries && (t.stacking.oldStacks = t.stacking.stacks);\n      }), this.series.forEach(function (e) {\n        var i = e.xAxis && e.xAxis.options || {};\n        e.options.stacking && e.reserveSpace() && (e.stackKey = [e.type, m(e.options.stack, \"\"), t ? i.top : i.left, t ? i.height : i.width].join(\",\"));\n      });\n    }\n    function y() {\n      var t = this.stacking;\n      if (t) {\n        var _t$stackTotalGroup;\n        var _e52 = t.stacks;\n        f(_e52, function (t, i) {\n          c(t), delete _e52[i];\n        }), (_t$stackTotalGroup = t.stackTotalGroup) === null || _t$stackTotalGroup === void 0 ? void 0 : _t$stackTotalGroup.destroy();\n      }\n    }\n    function b() {\n      this.stacking || (this.stacking = new w(this));\n    }\n    function v(t, e, i, s) {\n      return !d(t) || t.x !== e || s && t.stackKey !== s ? t = {\n        x: e,\n        index: 0,\n        key: s,\n        stackKey: s\n      } : t.index++, t.key = [i, e, t.index].join(\",\"), t;\n    }\n    function S() {\n      var t;\n      var e = this,\n        i = e.yAxis,\n        s = e.stackKey || \"\",\n        r = i.stacking.stacks,\n        o = e.processedXData,\n        n = e.options.stacking,\n        a = e[n + \"Stacker\"];\n      a && [s, \"-\" + s].forEach(function (i) {\n        var s = o.length,\n          n,\n          h,\n          l;\n        for (; s--;) {\n          var _r$i, _h10;\n          n = o[s], t = e.getStackIndicator(t, n, e.index, i), h = (_r$i = r[i]) === null || _r$i === void 0 ? void 0 : _r$i[n], (l = (_h10 = h) === null || _h10 === void 0 ? void 0 : _h10.points[t.key || \"\"]) && a.call(e, l, h, s);\n        }\n      });\n    }\n    function C(t, e, i) {\n      var s = e.total ? 100 / e.total : 0;\n      t[0] = l(t[0] * s), t[1] = l(t[1] * s), this.stackedYData[i] = t[1];\n    }\n    function k(t) {\n      (this.is(\"column\") || this.is(\"columnrange\")) && (this.options.centerInCategory && !this.options.stacking && this.chart.series.length > 1 ? a.setStackedPoints.call(this, t, \"group\") : t.stacking.resetStacks());\n    }\n    function M(t, e) {\n      var i, r, o, n, a, h, c, p, g;\n      var f = e || this.options.stacking;\n      if (!f || !this.reserveSpace() || ({\n        group: \"xAxis\"\n      }[f] || \"yAxis\") !== t.coll) return;\n      var x = this.processedXData,\n        y = this.processedYData,\n        b = [],\n        v = y.length,\n        S = this.options,\n        C = S.threshold || 0,\n        k = S.startFromThreshold ? C : 0,\n        M = S.stack,\n        w = e ? \"\".concat(this.type, \",\").concat(f) : this.stackKey || \"\",\n        A = \"-\" + w,\n        T = this.negStacks,\n        P = t.stacking,\n        L = P.stacks,\n        O = P.oldStacks;\n      for (P.stacksTouched += 1, c = 0; c < v; c++) {\n        var _O$a, _L$n;\n        p = x[c], g = y[c], h = (i = this.getStackIndicator(i, p, this.index)).key || \"\", L[a = (r = T && g < (k ? 0 : C)) ? A : w] || (L[a] = {}), L[a][p] || ((_O$a = O[a]) !== null && _O$a !== void 0 && _O$a[p] ? (L[a][p] = O[a][p], L[a][p].total = null) : L[a][p] = new s(t, t.options.stackLabels, !!r, p, M)), o = L[a][p], null !== g ? (o.points[h] = o.points[this.index] = [m(o.cumulative, k)], d(o.cumulative) || (o.base = h), o.touched = P.stacksTouched, i.index > 0 && !1 === this.singleStacks && (o.points[h][0] = o.points[this.index + \",\" + p + \",0\"][0])) : (delete o.points[h], delete o.points[this.index]);\n        var _e53 = o.total || 0;\n        \"percent\" === f ? (n = r ? w : A, _e53 = T && (_L$n = L[n]) !== null && _L$n !== void 0 && _L$n[p] ? (n = L[n][p]).total = Math.max(n.total || 0, _e53) + Math.abs(g) || 0 : l(_e53 + (Math.abs(g) || 0))) : \"group\" === f ? (u(g) && (g = g[0]), null !== g && _e53++) : _e53 = l(_e53 + (g || 0)), \"group\" === f ? o.cumulative = (_e53 || 1) - 1 : o.cumulative = l(m(o.cumulative, k) + (g || 0)), o.total = _e53, null !== g && (o.points[h].push(o.cumulative), b[c] = o.cumulative, o.hasValidPoints = !0);\n      }\n      \"percent\" === f && (P.usePercentage = !0), \"group\" !== f && (this.stackedYData = b), P.oldStacks = {};\n    }\n    var w = /*#__PURE__*/function () {\n      function w(t) {\n        _classCallCheck(this, w);\n        this.oldStacks = {}, this.stacks = {}, this.stacksTouched = 0, this.axis = t;\n      }\n      return _createClass(w, [{\n        key: \"buildStacks\",\n        value: function buildStacks() {\n          var t, e;\n          var i = this.axis,\n            s = i.series,\n            r = \"xAxis\" === i.coll,\n            o = i.options.reversedStacks,\n            n = s.length;\n          for (this.resetStacks(), this.usePercentage = !1, e = n; e--;) t = s[o ? e : n - e - 1], r && t.setGroupedPoints(i), t.setStackedPoints(i);\n          if (!r) for (e = 0; e < n; e++) s[e].modifyStacks();\n          p(i, \"afterBuildStacks\");\n        }\n      }, {\n        key: \"cleanStacks\",\n        value: function cleanStacks() {\n          this.oldStacks && (this.stacks = this.oldStacks, f(this.stacks, function (t) {\n            f(t, function (t) {\n              t.cumulative = t.total;\n            });\n          }));\n        }\n      }, {\n        key: \"resetStacks\",\n        value: function resetStacks() {\n          var _this21 = this;\n          f(this.stacks, function (t) {\n            f(t, function (e, i) {\n              g(e.touched) && e.touched < _this21.stacksTouched ? (e.destroy(), delete t[i]) : (e.total = null, e.cumulative = null);\n            });\n          });\n        }\n      }, {\n        key: \"renderStackTotals\",\n        value: function renderStackTotals() {\n          var _t$options$stackLabel;\n          var t = this.axis,\n            e = t.chart,\n            i = e.renderer,\n            s = this.stacks,\n            r = n(e, ((_t$options$stackLabel = t.options.stackLabels) === null || _t$options$stackLabel === void 0 ? void 0 : _t$options$stackLabel.animation) || !1),\n            o = this.stackTotalGroup = this.stackTotalGroup || i.g(\"stack-labels\").attr({\n              zIndex: 6,\n              opacity: 0\n            }).add();\n          o.translate(e.plotLeft, e.plotTop), f(s, function (t) {\n            f(t, function (t) {\n              t.render(o);\n            });\n          }), o.animate({\n            opacity: 1\n          }, r);\n        }\n      }]);\n    }();\n    return (o || (o = {})).compose = function (t, e, i) {\n      var s = e.prototype,\n        r = i.prototype;\n      s.getStacks || (h(t, \"init\", b), h(t, \"destroy\", y), s.getStacks = x, r.getStackIndicator = v, r.modifyStacks = S, r.percentStacker = C, r.setGroupedPoints = k, r.setStackedPoints = M);\n    }, o;\n  }), i(e, \"Series/Line/LineSeries.js\", [e[\"Core/Series/Series.js\"], e[\"Core/Series/SeriesRegistry.js\"], e[\"Core/Utilities.js\"]], function (t, e, i) {\n    var s = i.defined,\n      r = i.merge,\n      o = i.isObject;\n    var n = /*#__PURE__*/function (_t82) {\n      function n() {\n        _classCallCheck(this, n);\n        return _callSuper(this, n, arguments);\n      }\n      _inherits(n, _t82);\n      return _createClass(n, [{\n        key: \"drawGraph\",\n        value: function drawGraph() {\n          var _this22 = this;\n          var t = this.options,\n            e = (this.gappedPath || this.getGraphPath).call(this),\n            i = this.chart.styledMode;\n          [this].concat(_toConsumableArray(this.zones)).forEach(function (s, _n13) {\n            var a,\n              h = s.graph,\n              l = h ? \"animate\" : \"attr\",\n              d = s.dashStyle || t.dashStyle;\n            h ? (h.endX = _this22.preventGraphAnimation ? null : e.xMap, h.animate({\n              d: e\n            })) : e.length && (s.graph = h = _this22.chart.renderer.path(e).addClass(\"highcharts-graph\" + (_n13 ? \" highcharts-zone-graph-\".concat(_n13 - 1, \" \") : \" \") + (_n13 && s.className || \"\")).attr({\n              zIndex: 1\n            }).add(_this22.group)), h && !i && (a = {\n              stroke: !_n13 && t.lineColor || s.color || _this22.color || \"#cccccc\",\n              \"stroke-width\": t.lineWidth || 0,\n              fill: _this22.fillGraph && _this22.color || \"none\"\n            }, d ? a.dashstyle = d : \"square\" !== t.linecap && (a[\"stroke-linecap\"] = a[\"stroke-linejoin\"] = \"round\"), h[l](a).shadow(_n13 < 2 && t.shadow && r({\n              filterUnits: \"userSpaceOnUse\"\n            }, o(t.shadow) ? t.shadow : {}))), h && (h.startX = e.xMap, h.isArea = e.isArea);\n          });\n        }\n      }, {\n        key: \"getGraphPath\",\n        value: function getGraphPath(t, e, i) {\n          var r = this,\n            o = r.options,\n            _n14 = [],\n            a = [],\n            h,\n            l = o.step,\n            d = (t = t || r.points).reversed;\n          return d && t.reverse(), (l = {\n            right: 1,\n            center: 2\n          }[l] || l && 3) && d && (l = 4 - l), (t = this.getValidPoints(t, !1, !(o.connectNulls && !e && !i))).forEach(function (d, c) {\n            var p;\n            var u = d.plotX,\n              g = d.plotY,\n              f = t[c - 1],\n              m = d.isNull || \"number\" != typeof g;\n            (d.leftCliff || f && f.rightCliff) && !i && (h = !0), m && !s(e) && c > 0 ? h = !o.connectNulls : m && !e ? h = !0 : (0 === c || h ? p = [[\"M\", d.plotX, d.plotY]] : r.getPointSpline ? p = [r.getPointSpline(t, d, c)] : l ? (p = 1 === l ? [[\"L\", f.plotX, g]] : 2 === l ? [[\"L\", (f.plotX + u) / 2, f.plotY], [\"L\", (f.plotX + u) / 2, g]] : [[\"L\", u, f.plotY]]).push([\"L\", u, g]) : p = [[\"L\", u, g]], a.push(d.x), l && (a.push(d.x), 2 === l && a.push(d.x)), _n14.push.apply(_n14, p), h = !1);\n          }), _n14.xMap = a, r.graphPath = _n14, _n14;\n        }\n      }]);\n    }(t);\n    return n.defaultOptions = r(t.defaultOptions, {\n      legendSymbol: \"lineMarker\"\n    }), e.registerSeriesType(\"line\", n), n;\n  }), i(e, \"Series/Area/AreaSeriesDefaults.js\", [], function () {\n    return {\n      threshold: 0,\n      legendSymbol: \"areaMarker\"\n    };\n  }), i(e, \"Series/Area/AreaSeries.js\", [e[\"Series/Area/AreaSeriesDefaults.js\"], e[\"Core/Series/SeriesRegistry.js\"], e[\"Core/Utilities.js\"]], function (t, e, i) {\n    var s = e.seriesTypes.line,\n      r = i.extend,\n      o = i.merge,\n      n = i.objectEach,\n      a = i.pick;\n    var h = /*#__PURE__*/function (_s39) {\n      function h() {\n        _classCallCheck(this, h);\n        return _callSuper(this, h, arguments);\n      }\n      _inherits(h, _s39);\n      return _createClass(h, [{\n        key: \"drawGraph\",\n        value: function drawGraph() {\n          var _this23 = this;\n          this.areaPath = [], _superPropGet(h, \"drawGraph\", this, 1).apply(this);\n          var t = this.areaPath,\n            e = this.options;\n          [this].concat(_toConsumableArray(this.zones)).forEach(function (i, s) {\n            var _e$fillOpacity;\n            var r = {},\n              o = i.fillColor || e.fillColor,\n              n = i.area,\n              a = n ? \"animate\" : \"attr\";\n            n ? (n.endX = _this23.preventGraphAnimation ? null : t.xMap, n.animate({\n              d: t\n            })) : (r.zIndex = 0, (n = i.area = _this23.chart.renderer.path(t).addClass(\"highcharts-area\" + (s ? \" highcharts-zone-area-\".concat(s - 1, \" \") : \" \") + (s && i.className || \"\")).add(_this23.group)).isArea = !0), _this23.chart.styledMode || (r.fill = o || i.color || _this23.color, r[\"fill-opacity\"] = o ? 1 : (_e$fillOpacity = e.fillOpacity) !== null && _e$fillOpacity !== void 0 ? _e$fillOpacity : .75, n.css({\n              pointerEvents: _this23.stickyTracking ? \"none\" : \"auto\"\n            })), n[a](r), n.startX = t.xMap, n.shiftUnit = e.step ? 2 : 1;\n          });\n        }\n      }, {\n        key: \"getGraphPath\",\n        value: function getGraphPath(t) {\n          var e, i, r;\n          var o = s.prototype.getGraphPath,\n            n = this.options,\n            _h11 = n.stacking,\n            l = this.yAxis,\n            d = [],\n            c = [],\n            p = this.index,\n            u = l.stacking.stacks[this.stackKey],\n            g = n.threshold,\n            f = Math.round(l.getThreshold(n.threshold)),\n            m = a(n.connectNulls, \"percent\" === _h11),\n            x = function x(i, s, r) {\n              var o = t[i],\n                n = _h11 && u[o.x].points[p],\n                a = o[r + \"Null\"] || 0,\n                m = o[r + \"Cliff\"] || 0,\n                x,\n                y,\n                b = !0;\n              m || a ? (x = (a ? n[0] : n[1]) + m, y = n[0] + m, b = !!a) : !_h11 && t[s] && t[s].isNull && (x = y = g), void 0 !== x && (c.push({\n                plotX: e,\n                plotY: null === x ? f : l.getThreshold(x),\n                isNull: b,\n                isCliff: !0\n              }), d.push({\n                plotX: e,\n                plotY: null === y ? f : l.getThreshold(y),\n                doCurve: !1\n              }));\n            };\n          t = t || this.points, _h11 && (t = this.getStackPoints(t));\n          for (var _s40 = 0, _o25 = t.length; _s40 < _o25; ++_s40) _h11 || (t[_s40].leftCliff = t[_s40].rightCliff = t[_s40].leftNull = t[_s40].rightNull = void 0), i = t[_s40].isNull, e = a(t[_s40].rectPlotX, t[_s40].plotX), r = _h11 ? a(t[_s40].yBottom, f) : f, i && !m || (m || x(_s40, _s40 - 1, \"left\"), i && !_h11 && m || (c.push(t[_s40]), d.push({\n            x: _s40,\n            plotX: e,\n            plotY: r\n          })), m || x(_s40, _s40 + 1, \"right\"));\n          var y = o.call(this, c, !0, !0);\n          d.reversed = !0;\n          var b = o.call(this, d, !0, !0),\n            v = b[0];\n          v && \"M\" === v[0] && (b[0] = [\"L\", v[1], v[2]]);\n          var S = y.concat(b);\n          S.length && S.push([\"Z\"]);\n          var C = o.call(this, c, !1, m);\n          return this.chart.series.length > 1 && _h11 && c.some(function (t) {\n            return t.isCliff;\n          }) && (S.hasStackedCliffs = C.hasStackedCliffs = !0), S.xMap = y.xMap, this.areaPath = S, C;\n        }\n      }, {\n        key: \"getStackPoints\",\n        value: function getStackPoints(t) {\n          var e = this,\n            i = [],\n            s = [],\n            r = this.xAxis,\n            o = this.yAxis,\n            _h12 = o.stacking.stacks[this.stackKey],\n            l = {},\n            d = o.series,\n            c = d.length,\n            p = o.options.reversedStacks ? 1 : -1,\n            u = d.indexOf(e);\n          if (t = t || this.points, this.options.stacking) {\n            for (var _e54 = 0; _e54 < t.length; _e54++) t[_e54].leftNull = t[_e54].rightNull = void 0, l[t[_e54].x] = t[_e54];\n            n(_h12, function (t, e) {\n              null !== t.total && s.push(e);\n            }), s.sort(function (t, e) {\n              return t - e;\n            });\n            var g = d.map(function (t) {\n              return t.visible;\n            });\n            s.forEach(function (t, n) {\n              var f = 0,\n                m,\n                x;\n              if (l[t] && !l[t].isNull) i.push(l[t]), [-1, 1].forEach(function (i) {\n                var r = 1 === i ? \"rightNull\" : \"leftNull\",\n                  o = _h12[s[n + i]],\n                  a = 0;\n                if (o) {\n                  var _i44 = u;\n                  for (; _i44 >= 0 && _i44 < c;) {\n                    var _s41 = d[_i44].index;\n                    !(m = o.points[_s41]) && (_s41 === e.index ? l[t][r] = !0 : g[_i44] && (x = _h12[t].points[_s41]) && (a -= x[1] - x[0])), _i44 += p;\n                  }\n                }\n                l[t][1 === i ? \"rightCliff\" : \"leftCliff\"] = a;\n              });else {\n                var _e55 = u;\n                for (; _e55 >= 0 && _e55 < c;) {\n                  var _i45 = d[_e55].index;\n                  if (m = _h12[t].points[_i45]) {\n                    f = m[1];\n                    break;\n                  }\n                  _e55 += p;\n                }\n                f = a(f, 0), f = o.translate(f, 0, 1, 0, 1), i.push({\n                  isNull: !0,\n                  plotX: r.translate(t, 0, 0, 0, 1),\n                  x: t,\n                  plotY: f,\n                  yBottom: f\n                });\n              }\n            });\n          }\n          return i;\n        }\n      }]);\n    }(s);\n    return h.defaultOptions = o(s.defaultOptions, t), r(h.prototype, {\n      singleStacks: !1\n    }), e.registerSeriesType(\"area\", h), h;\n  }), i(e, \"Series/Spline/SplineSeries.js\", [e[\"Core/Series/SeriesRegistry.js\"], e[\"Core/Utilities.js\"]], function (t, e) {\n    var i = t.seriesTypes.line,\n      s = e.merge,\n      r = e.pick;\n    var o = /*#__PURE__*/function (_i46) {\n      function o() {\n        _classCallCheck(this, o);\n        return _callSuper(this, o, arguments);\n      }\n      _inherits(o, _i46);\n      return _createClass(o, [{\n        key: \"getPointSpline\",\n        value: function getPointSpline(t, e, i) {\n          var s, _o26, n, a;\n          var h = e.plotX || 0,\n            l = e.plotY || 0,\n            d = t[i - 1],\n            c = t[i + 1];\n          function p(t) {\n            return t && !t.isNull && !1 !== t.doCurve && !e.isCliff;\n          }\n          if (p(d) && p(c)) {\n            var _t83 = d.plotX || 0,\n              _i47 = d.plotY || 0,\n              _r20 = c.plotX || 0,\n              _p9 = c.plotY || 0,\n              _u4 = 0;\n            s = (1.5 * h + _t83) / 2.5, _o26 = (1.5 * l + _i47) / 2.5, n = (1.5 * h + _r20) / 2.5, a = (1.5 * l + _p9) / 2.5, n !== s && (_u4 = (a - _o26) * (n - h) / (n - s) + l - a), _o26 += _u4, a += _u4, _o26 > _i47 && _o26 > l ? (_o26 = Math.max(_i47, l), a = 2 * l - _o26) : _o26 < _i47 && _o26 < l && (_o26 = Math.min(_i47, l), a = 2 * l - _o26), a > _p9 && a > l ? (a = Math.max(_p9, l), _o26 = 2 * l - a) : a < _p9 && a < l && (a = Math.min(_p9, l), _o26 = 2 * l - a), e.rightContX = n, e.rightContY = a, e.controlPoints = {\n              low: [s, _o26],\n              high: [n, a]\n            };\n          }\n          var u = [\"C\", r(d.rightContX, d.plotX, 0), r(d.rightContY, d.plotY, 0), r(s, h, 0), r(_o26, l, 0), h, l];\n          return d.rightContX = d.rightContY = void 0, u;\n        }\n      }]);\n    }(i);\n    return o.defaultOptions = s(i.defaultOptions), t.registerSeriesType(\"spline\", o), o;\n  }), i(e, \"Series/AreaSpline/AreaSplineSeries.js\", [e[\"Series/Spline/SplineSeries.js\"], e[\"Core/Series/SeriesRegistry.js\"], e[\"Core/Utilities.js\"]], function (t, e, i) {\n    var _e$seriesTypes = e.seriesTypes,\n      s = _e$seriesTypes.area,\n      r = _e$seriesTypes.area.prototype,\n      o = i.extend,\n      n = i.merge;\n    var a = /*#__PURE__*/function (_t84) {\n      function a() {\n        _classCallCheck(this, a);\n        return _callSuper(this, a, arguments);\n      }\n      _inherits(a, _t84);\n      return _createClass(a);\n    }(t);\n    return a.defaultOptions = n(t.defaultOptions, s.defaultOptions), o(a.prototype, {\n      getGraphPath: r.getGraphPath,\n      getStackPoints: r.getStackPoints,\n      drawGraph: r.drawGraph\n    }), e.registerSeriesType(\"areaspline\", a), a;\n  }), i(e, \"Series/Column/ColumnSeriesDefaults.js\", [], function () {\n    return {\n      borderRadius: 3,\n      centerInCategory: !1,\n      groupPadding: .2,\n      marker: null,\n      pointPadding: .1,\n      minPointLength: 0,\n      cropThreshold: 50,\n      pointRange: null,\n      states: {\n        hover: {\n          halo: !1,\n          brightness: .1\n        },\n        select: {\n          color: \"#cccccc\",\n          borderColor: \"#000000\"\n        }\n      },\n      dataLabels: {\n        align: void 0,\n        verticalAlign: void 0,\n        y: void 0\n      },\n      startFromThreshold: !0,\n      stickyTracking: !1,\n      tooltip: {\n        distance: 6\n      },\n      threshold: 0,\n      borderColor: \"#ffffff\"\n    };\n  }), i(e, \"Series/Column/ColumnSeries.js\", [e[\"Core/Animation/AnimationUtilities.js\"], e[\"Core/Color/Color.js\"], e[\"Series/Column/ColumnSeriesDefaults.js\"], e[\"Core/Globals.js\"], e[\"Core/Series/Series.js\"], e[\"Core/Series/SeriesRegistry.js\"], e[\"Core/Utilities.js\"]], function (t, e, i, s, r, o, n) {\n    var a = t.animObject,\n      h = e.parse,\n      l = s.noop,\n      d = n.clamp,\n      c = n.crisp,\n      p = n.defined,\n      u = n.extend,\n      g = n.fireEvent,\n      f = n.isArray,\n      m = n.isNumber,\n      x = n.merge,\n      y = n.pick,\n      b = n.objectEach;\n    var v = /*#__PURE__*/function (_r21) {\n      function v() {\n        _classCallCheck(this, v);\n        return _callSuper(this, v, arguments);\n      }\n      _inherits(v, _r21);\n      return _createClass(v, [{\n        key: \"animate\",\n        value: function animate(t) {\n          var e, i;\n          var s = this,\n            r = this.yAxis,\n            o = r.pos,\n            n = r.reversed,\n            h = s.options,\n            _this$chart2 = this.chart,\n            l = _this$chart2.clipOffset,\n            c = _this$chart2.inverted,\n            p = {},\n            g = c ? \"translateX\" : \"translateY\";\n          t && l ? (p.scaleY = .001, i = d(r.toPixels(h.threshold), o, o + r.len), c ? (i += n ? -Math.floor(l[0]) : Math.ceil(l[2]), p.translateX = i - r.len) : (i += n ? Math.ceil(l[0]) : -Math.floor(l[2]), p.translateY = i), s.clipBox && s.setClip(), s.group.attr(p)) : (e = Number(s.group.attr(g)), s.group.animate({\n            scaleY: 1\n          }, u(a(s.options.animation), {\n            step: function step(t, i) {\n              s.group && (p[g] = e + i.pos * (o - e), s.group.attr(p));\n            }\n          })));\n        }\n      }, {\n        key: \"init\",\n        value: function init(t, e) {\n          _superPropGet(v, \"init\", this, 1).apply(this, arguments);\n          var i = this;\n          (t = i.chart).hasRendered && t.series.forEach(function (t) {\n            t.type === i.type && (t.isDirty = !0);\n          });\n        }\n      }, {\n        key: \"getColumnMetrics\",\n        value: function getColumnMetrics() {\n          var _i$brokenAxis, _i$ordinal;\n          var t = this,\n            e = t.options,\n            i = t.xAxis,\n            s = t.yAxis,\n            r = i.options.reversedStacks,\n            o = i.reversed && !r || !i.reversed && r,\n            n = {},\n            a,\n            h = 0;\n          !1 === e.grouping ? h = 1 : t.chart.series.forEach(function (e) {\n            var i;\n            var r = e.yAxis,\n              o = e.options;\n            e.type === t.type && e.reserveSpace() && s.len === r.len && s.pos === r.pos && (o.stacking && \"group\" !== o.stacking ? (void 0 === n[a = e.stackKey] && (n[a] = h++), i = n[a]) : !1 !== o.grouping && (i = h++), e.columnIndex = i);\n          });\n          var l = Math.min(Math.abs(i.transA) * (!((_i$brokenAxis = i.brokenAxis) !== null && _i$brokenAxis !== void 0 && _i$brokenAxis.hasBreaks) && ((_i$ordinal = i.ordinal) === null || _i$ordinal === void 0 ? void 0 : _i$ordinal.slope) || e.pointRange || i.closestPointRange || i.tickInterval || 1), i.len),\n            d = l * e.groupPadding,\n            c = (l - 2 * d) / (h || 1),\n            p = Math.min(e.maxPointWidth || i.len, y(e.pointWidth, c * (1 - 2 * e.pointPadding))),\n            u = (t.columnIndex || 0) + (o ? 1 : 0);\n          return t.columnMetrics = {\n            width: p,\n            offset: (c - p) / 2 + (d + u * c - l / 2) * (o ? -1 : 1),\n            paddedWidth: c,\n            columnCount: h\n          }, t.columnMetrics;\n        }\n      }, {\n        key: \"crispCol\",\n        value: function crispCol(t, e, i, s) {\n          var r = this.borderWidth,\n            o = this.chart.inverted;\n          return s = c(e + s, r, o) - (e = c(e, r, o)), this.options.crisp && (i = c(t + i, r) - (t = c(t, r))), {\n            x: t,\n            y: e,\n            width: i,\n            height: s\n          };\n        }\n      }, {\n        key: \"adjustForMissingColumns\",\n        value: function adjustForMissingColumns(t, e, i, s) {\n          var _this24 = this;\n          if (!i.isNull && s.columnCount > 1) {\n            var _this$xAxis$stacking;\n            var _r22 = this.xAxis.series.filter(function (t) {\n                return t.visible;\n              }).map(function (t) {\n                return t.index;\n              }),\n              _o27 = 0,\n              _n15 = 0;\n            b((_this$xAxis$stacking = this.xAxis.stacking) === null || _this$xAxis$stacking === void 0 ? void 0 : _this$xAxis$stacking.stacks, function (t) {\n              if (\"number\" == typeof i.x) {\n                var _e56 = t[i.x.toString()];\n                if (_e56 && f(_e56.points[_this24.index])) {\n                  var _t85 = Object.keys(_e56.points).filter(function (t) {\n                    return !t.match(\",\") && _e56.points[t] && _e56.points[t].length > 1;\n                  }).map(parseFloat).filter(function (t) {\n                    return -1 !== _r22.indexOf(t);\n                  }).sort(function (t, e) {\n                    return e - t;\n                  });\n                  _o27 = _t85.indexOf(_this24.index), _n15 = _t85.length;\n                }\n              }\n            }), _o27 = this.xAxis.reversed ? _n15 - 1 - _o27 : _o27;\n            var _a16 = (_n15 - 1) * s.paddedWidth + e;\n            t = (i.plotX || 0) + _a16 / 2 - e - _o27 * s.paddedWidth;\n          }\n          return t;\n        }\n      }, {\n        key: \"translate\",\n        value: function translate() {\n          var t = this,\n            e = t.chart,\n            i = t.options,\n            s = t.dense = t.closestPointRange * t.xAxis.transA < 2,\n            o = t.borderWidth = y(i.borderWidth, s ? 0 : 1),\n            n = t.xAxis,\n            a = t.yAxis,\n            h = i.threshold,\n            l = y(i.minPointLength, 5),\n            c = t.getColumnMetrics(),\n            u = c.width,\n            f = t.pointXOffset = c.offset,\n            x = t.dataMin,\n            b = t.dataMax,\n            _v5 = t.translatedThreshold = a.getThreshold(h),\n            S = t.barW = Math.max(u, 1 + 2 * o);\n          i.pointPadding && (S = Math.ceil(S)), r.prototype.translate.apply(t), t.points.forEach(function (s) {\n            var r = y(s.yBottom, _v5),\n              o = 999 + Math.abs(r),\n              g = s.plotX || 0,\n              C = d(s.plotY, -o, a.len + o),\n              k,\n              M = Math.min(C, r),\n              w = Math.max(C, r) - M,\n              A = u,\n              T = g + f,\n              P = S;\n            l && Math.abs(w) < l && (w = l, k = !a.reversed && !s.negative || a.reversed && s.negative, m(h) && m(b) && s.y === h && b <= h && (a.min || 0) < h && (x !== b || (a.max || 0) <= h) && (k = !k, s.negative = !s.negative), M = Math.abs(M - _v5) > l ? r - l : _v5 - (k ? l : 0)), p(s.options.pointWidth) && (T -= Math.round(((A = P = Math.ceil(s.options.pointWidth)) - u) / 2)), i.centerInCategory && !i.stacking && (T = t.adjustForMissingColumns(T, A, s, c)), s.barX = T, s.pointWidth = A, s.tooltipPos = e.inverted ? [d(a.len + a.pos - e.plotLeft - C, a.pos - e.plotLeft, a.len + a.pos - e.plotLeft), n.len + n.pos - e.plotTop - T - P / 2, w] : [n.left - e.plotLeft + T + P / 2, d(C + a.pos - e.plotTop, a.pos - e.plotTop, a.len + a.pos - e.plotTop), w], s.shapeType = t.pointClass.prototype.shapeType || \"roundedRect\", s.shapeArgs = t.crispCol(T, s.isNull ? _v5 : M, P, s.isNull ? 0 : w);\n          }), g(this, \"afterColumnTranslate\");\n        }\n      }, {\n        key: \"drawGraph\",\n        value: function drawGraph() {\n          this.group[this.dense ? \"addClass\" : \"removeClass\"](\"highcharts-dense-data\");\n        }\n      }, {\n        key: \"pointAttribs\",\n        value: function pointAttribs(t, e) {\n          var i = this.options,\n            s = this.pointAttrToOptions || {},\n            r = s.stroke || \"borderColor\",\n            o = s[\"stroke-width\"] || \"borderWidth\",\n            n,\n            a,\n            l,\n            d = t && t.color || this.color,\n            c = t && t[r] || i[r] || d,\n            p = t && t.options.dashStyle || i.dashStyle,\n            u = t && t[o] || i[o] || this[o] || 0,\n            g = y(t && t.opacity, i.opacity, 1);\n          t && this.zones.length && (a = t.getZone(), d = t.options.color || a && (a.color || t.nonZonedColor) || this.color, a && (c = a.borderColor || c, p = a.dashStyle || p, u = a.borderWidth || u)), e && t && (l = (n = x(i.states[e], t.options.states && t.options.states[e] || {})).brightness, d = n.color || void 0 !== l && h(d).brighten(n.brightness).get() || d, c = n[r] || c, u = n[o] || u, p = n.dashStyle || p, g = y(n.opacity, g));\n          var f = {\n            fill: d,\n            stroke: c,\n            \"stroke-width\": u,\n            opacity: g\n          };\n          return p && (f.dashstyle = p), f;\n        }\n      }, {\n        key: \"drawPoints\",\n        value: function drawPoints() {\n          var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.points;\n          var e;\n          var i = this,\n            s = this.chart,\n            r = i.options,\n            o = s.renderer,\n            n = r.animationLimit || 250;\n          t.forEach(function (t) {\n            var a = t.plotY,\n              h = t.graphic,\n              l = !!h,\n              d = h && s.pointCount < n ? \"animate\" : \"attr\";\n            m(a) && null !== t.y ? (e = t.shapeArgs, h && t.hasNewShapeType() && (h = h.destroy()), i.enabledDataSorting && (t.startXPos = i.xAxis.reversed ? -(e && e.width || 0) : i.xAxis.width), !h && (t.graphic = h = o[t.shapeType](e).add(t.group || i.group), h && i.enabledDataSorting && s.hasRendered && s.pointCount < n && (h.attr({\n              x: t.startXPos\n            }), l = !0, d = \"animate\")), h && l && h[d](x(e)), s.styledMode || h[d](i.pointAttribs(t, t.selected && \"select\")).shadow(!1 !== t.allowShadow && r.shadow), h && (h.addClass(t.getClassName(), !0), h.attr({\n              visibility: t.visible ? \"inherit\" : \"hidden\"\n            }))) : h && (t.graphic = h.destroy());\n          });\n        }\n      }, {\n        key: \"drawTracker\",\n        value: function drawTracker() {\n          var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.points;\n          var e;\n          var i = this,\n            s = i.chart,\n            r = s.pointer,\n            o = function o(t) {\n              var e = r === null || r === void 0 ? void 0 : r.getPointFromEvent(t);\n              r && e && i.options.enableMouseTracking && (r.isDirectTouch = !0, e.onMouseOver(t));\n            };\n          t.forEach(function (t) {\n            e = f(t.dataLabels) ? t.dataLabels : t.dataLabel ? [t.dataLabel] : [], t.graphic && (t.graphic.element.point = t), e.forEach(function (e) {\n              (e.div || e.element).point = t;\n            });\n          }), i._hasTracking || (i.trackerGroups.forEach(function (t) {\n            i[t] && (i[t].addClass(\"highcharts-tracker\").on(\"mouseover\", o).on(\"mouseout\", function (t) {\n              r === null || r === void 0 || r.onTrackerMouseOut(t);\n            }).on(\"touchstart\", o), !s.styledMode && i.options.cursor && i[t].css({\n              cursor: i.options.cursor\n            }));\n          }), i._hasTracking = !0), g(this, \"afterDrawTracker\");\n        }\n      }, {\n        key: \"remove\",\n        value: function remove() {\n          var t = this,\n            e = t.chart;\n          e.hasRendered && e.series.forEach(function (e) {\n            e.type === t.type && (e.isDirty = !0);\n          }), r.prototype.remove.apply(t, arguments);\n        }\n      }]);\n    }(r);\n    return v.defaultOptions = x(r.defaultOptions, i), u(v.prototype, {\n      directTouch: !0,\n      getSymbol: l,\n      negStacks: !0,\n      trackerGroups: [\"group\", \"dataLabelsGroup\"]\n    }), o.registerSeriesType(\"column\", v), v;\n  }), i(e, \"Core/Series/DataLabel.js\", [e[\"Core/Animation/AnimationUtilities.js\"], e[\"Core/Templating.js\"], e[\"Core/Utilities.js\"]], function (t, e, i) {\n    var s;\n    var r = t.getDeferredAnimation,\n      o = e.format,\n      n = i.defined,\n      a = i.extend,\n      h = i.fireEvent,\n      l = i.isArray,\n      d = i.isString,\n      c = i.merge,\n      p = i.objectEach,\n      u = i.pick,\n      g = i.pInt,\n      f = i.splat;\n    return function (t) {\n      function e() {\n        return v(this).some(function (t) {\n          return t === null || t === void 0 ? void 0 : t.enabled;\n        });\n      }\n      function i(t, e, i, s, r) {\n        var o = this.chart,\n          h = this.enabledDataSorting,\n          l = this.isCartesian && o.inverted,\n          d = t.plotX,\n          p = t.plotY,\n          g = i.rotation || 0,\n          f = n(d) && n(p) && o.isInsidePlot(d, Math.round(p), {\n            inverted: l,\n            paneCoordinates: !0,\n            series: this\n          }),\n          m = 0 === g && \"justify\" === u(i.overflow, h ? \"none\" : \"justify\"),\n          x = this.visible && !1 !== t.visible && n(d) && (t.series.forceDL || h && !m || f || u(i.inside, !!this.options.stacking) && s && o.isInsidePlot(d, l ? s.x + 1 : s.y + s.height - 1, {\n            inverted: l,\n            paneCoordinates: !0,\n            series: this\n          })),\n          y = t.pos();\n        if (x && y) {\n          var _this$yAxis;\n          var b;\n          var _n16 = e.getBBox(),\n            _d8 = e.getBBox(void 0, 0),\n            _p10 = {\n              right: 1,\n              center: .5\n            }[i.align || 0] || 0,\n            _v6 = {\n              bottom: 1,\n              middle: .5\n            }[i.verticalAlign || 0] || 0;\n          if (s = a({\n            x: y[0],\n            y: Math.round(y[1]),\n            width: 0,\n            height: 0\n          }, s || {}), \"plotEdges\" === i.alignTo && this.isCartesian && (s[l ? \"x\" : \"y\"] = 0, s[l ? \"width\" : \"height\"] = ((_this$yAxis = this.yAxis) === null || _this$yAxis === void 0 ? void 0 : _this$yAxis.len) || 0), a(i, {\n            width: _n16.width,\n            height: _n16.height\n          }), b = s, h && this.xAxis && !m && this.setDataLabelStartPos(t, e, r, f, b), e.align(c(i, {\n            width: _d8.width,\n            height: _d8.height\n          }), !1, s, !1), e.alignAttr.x += _p10 * (_d8.width - _n16.width), e.alignAttr.y += _v6 * (_d8.height - _n16.height), e[e.placed ? \"animate\" : \"attr\"]({\n            x: e.alignAttr.x + (_n16.width - _d8.width) / 2,\n            y: e.alignAttr.y + (_n16.height - _d8.height) / 2,\n            rotationOriginX: (e.width || 0) / 2,\n            rotationOriginY: (e.height || 0) / 2\n          }), m && s.height >= 0) this.justifyDataLabel(e, i, e.alignAttr, _n16, s, r);else if (u(i.crop, !0)) {\n            var _e$alignAttr = e.alignAttr,\n              _t86 = _e$alignAttr.x,\n              _i48 = _e$alignAttr.y;\n            x = o.isInsidePlot(_t86, _i48, {\n              paneCoordinates: !0,\n              series: this\n            }) && o.isInsidePlot(_t86 + _n16.width - 1, _i48 + _n16.height - 1, {\n              paneCoordinates: !0,\n              series: this\n            });\n          }\n          i.shape && !g && e[r ? \"attr\" : \"animate\"]({\n            anchorX: y[0],\n            anchorY: y[1]\n          });\n        }\n        r && h && (e.placed = !1), x || h && !m ? (e.show(), e.placed = !0) : (e.hide(), e.placed = !1);\n      }\n      function s() {\n        return this.plotGroup(\"dataLabelsGroup\", \"data-labels\", this.hasRendered ? \"inherit\" : \"hidden\", this.options.dataLabels.zIndex || 6);\n      }\n      function m(t) {\n        var e = this.hasRendered || 0,\n          i = this.initDataLabelsGroup().attr({\n            opacity: +e\n          });\n        return !e && i && (this.visible && i.show(), this.options.animation ? i.animate({\n          opacity: 1\n        }, t) : i.attr({\n          opacity: 1\n        })), i;\n      }\n      function x(t) {\n        var _i$hasDataLabels2;\n        var e;\n        t = t || this.points;\n        var i = this,\n          s = i.chart,\n          a = i.options,\n          l = s.renderer,\n          _s$options$chart = s.options.chart,\n          c = _s$options$chart.backgroundColor,\n          m = _s$options$chart.plotBackgroundColor,\n          x = l.getContrast(d(m) && m || d(c) && c || \"#000000\"),\n          y = v(i),\n          _y$ = y[0],\n          S = _y$.animation,\n          C = _y$.defer,\n          k = C ? r(s, S, i) : {\n            defer: 0,\n            duration: 0\n          };\n        h(this, \"drawDataLabels\"), (_i$hasDataLabels2 = i.hasDataLabels) !== null && _i$hasDataLabels2 !== void 0 && _i$hasDataLabels2.call(i) && (e = this.initDataLabels(k), t.forEach(function (t) {\n          var _t$options3;\n          var r = t.dataLabels || [];\n          f(b(y, t.dlOptions || ((_t$options3 = t.options) === null || _t$options3 === void 0 ? void 0 : _t$options3.dataLabels))).forEach(function (c, f) {\n            var m = c.enabled && (t.visible || t.dataLabelOnHidden) && (!t.isNull || t.dataLabelOnNull) && function (t, e) {\n                var i = e.filter;\n                if (i) {\n                  var _e57 = i.operator,\n                    _s42 = t[i.property],\n                    _r23 = i.value;\n                  return \">\" === _e57 && _s42 > _r23 || \"<\" === _e57 && _s42 < _r23 || \">=\" === _e57 && _s42 >= _r23 || \"<=\" === _e57 && _s42 <= _r23 || \"==\" === _e57 && _s42 == _r23 || \"===\" === _e57 && _s42 === _r23 || \"!=\" === _e57 && _s42 != _r23 || \"!==\" === _e57 && _s42 !== _r23;\n                }\n                return !0;\n              }(t, c),\n              y = c.backgroundColor,\n              b = c.borderColor,\n              v = c.distance,\n              _c$style = c.style,\n              S = _c$style === void 0 ? {} : _c$style,\n              C,\n              k,\n              M,\n              w,\n              A = {},\n              T = r[f],\n              P = !T,\n              L;\n            m && (k = u(c[t.formatPrefix + \"Format\"], c.format), C = t.getLabelConfig(), M = n(k) ? o(k, C, s) : (c[t.formatPrefix + \"Formatter\"] || c.formatter).call(C, c), w = c.rotation, !s.styledMode && (S.color = u(c.color, S.color, d(i.color) ? i.color : void 0, \"#000000\"), \"contrast\" === S.color ? (\"none\" !== y && (L = y), t.contrastColor = l.getContrast(\"auto\" !== L && L || t.color || i.color), S.color = L || !n(v) && c.inside || 0 > g(v || 0) || a.stacking ? t.contrastColor : x) : delete t.contrastColor, a.cursor && (S.cursor = a.cursor)), A = {\n              r: c.borderRadius || 0,\n              rotation: w,\n              padding: c.padding,\n              zIndex: 1\n            }, s.styledMode || (A.fill = \"auto\" === y ? t.color : y, A.stroke = \"auto\" === b ? t.color : b, A[\"stroke-width\"] = c.borderWidth), p(A, function (t, e) {\n              void 0 === t && delete A[e];\n            })), !T || m && n(M) && !!T.div == !!c.useHTML && (T.rotation && c.rotation || T.rotation === c.rotation) || (T = void 0, P = !0), m && n(M) && (T ? A.text = M : (T = l.label(M, 0, 0, c.shape, void 0, void 0, c.useHTML, void 0, \"data-label\")).addClass(\" highcharts-data-label-color-\" + t.colorIndex + \" \" + (c.className || \"\") + (c.useHTML ? \" highcharts-tracker\" : \"\")), T && (T.options = c, T.attr(A), s.styledMode || T.css(S).shadow(c.shadow), h(T, \"beforeAddingDataLabel\", {\n              labelOptions: c,\n              point: t\n            }), T.added || T.add(e), i.alignDataLabel(t, T, c, void 0, P), T.isActive = !0, r[f] && r[f] !== T && r[f].destroy(), r[f] = T));\n          });\n          var c = r.length;\n          for (; c--;) {\n            var _r$c;\n            r[c] && r[c].isActive ? r[c].isActive = !1 : ((_r$c = r[c]) !== null && _r$c !== void 0 && _r$c.destroy(), r.splice(c, 1));\n          }\n          t.dataLabel = r[0], t.dataLabels = r;\n        })), h(this, \"afterDrawDataLabels\");\n      }\n      function y(t, e, i, s, r, o) {\n        var n = this.chart,\n          a = e.align,\n          h = e.verticalAlign,\n          l = t.box ? 0 : t.padding || 0,\n          d = n.inverted ? this.yAxis : this.xAxis,\n          c = d ? d.left - n.plotLeft : 0,\n          p = n.inverted ? this.xAxis : this.yAxis,\n          u = p ? p.top - n.plotTop : 0,\n          _e$x = e.x,\n          g = _e$x === void 0 ? 0 : _e$x,\n          _e$y = e.y,\n          f = _e$y === void 0 ? 0 : _e$y,\n          m,\n          x;\n        return (m = (i.x || 0) + l + c) < 0 && (\"right\" === a && g >= 0 ? (e.align = \"left\", e.inside = !0) : g -= m, x = !0), (m = (i.x || 0) + s.width - l + c) > n.plotWidth && (\"left\" === a && g <= 0 ? (e.align = \"right\", e.inside = !0) : g += n.plotWidth - m, x = !0), (m = i.y + l + u) < 0 && (\"bottom\" === h && f >= 0 ? (e.verticalAlign = \"top\", e.inside = !0) : f -= m, x = !0), (m = (i.y || 0) + s.height - l + u) > n.plotHeight && (\"top\" === h && f <= 0 ? (e.verticalAlign = \"bottom\", e.inside = !0) : f += n.plotHeight - m, x = !0), x && (e.x = g, e.y = f, t.placed = !o, t.align(e, void 0, r)), x;\n      }\n      function b(t, e) {\n        var i = [],\n          s;\n        if (l(t) && !l(e)) i = t.map(function (t) {\n          return c(t, e);\n        });else if (l(e) && !l(t)) i = e.map(function (e) {\n          return c(t, e);\n        });else if (l(t) || l(e)) {\n          if (l(t) && l(e)) for (s = Math.max(t.length, e.length); s--;) i[s] = c(t[s], e[s]);\n        } else i = c(t, e);\n        return i;\n      }\n      function v(t) {\n        var _e$series, _e$t$type;\n        var e = t.chart.options.plotOptions;\n        return f(b(b(e === null || e === void 0 || (_e$series = e.series) === null || _e$series === void 0 ? void 0 : _e$series.dataLabels, e === null || e === void 0 || (_e$t$type = e[t.type]) === null || _e$t$type === void 0 ? void 0 : _e$t$type.dataLabels), t.options.dataLabels));\n      }\n      function S(t, e, i, s, r) {\n        var o = this.chart,\n          n = o.inverted,\n          a = this.xAxis,\n          h = a.reversed,\n          l = ((n ? e.height : e.width) || 0) / 2,\n          d = t.pointWidth,\n          c = d ? d / 2 : 0;\n        e.startXPos = n ? r.x : h ? -l - c : a.width - l + c, e.startYPos = n ? h ? this.yAxis.height - l + c : -l - c : r.y, s ? \"hidden\" === e.visibility && (e.show(), e.attr({\n          opacity: 0\n        }).animate({\n          opacity: 1\n        })) : e.attr({\n          opacity: 1\n        }).animate({\n          opacity: 0\n        }, void 0, e.hide), o.hasRendered && (i && e.attr({\n          x: e.startXPos,\n          y: e.startYPos\n        }), e.placed = !0);\n      }\n      t.compose = function (t) {\n        var r = t.prototype;\n        r.initDataLabels || (r.initDataLabels = m, r.initDataLabelsGroup = s, r.alignDataLabel = i, r.drawDataLabels = x, r.justifyDataLabel = y, r.setDataLabelStartPos = S, r.hasDataLabels = e);\n      };\n    }(s || (s = {})), s;\n  }), i(e, \"Series/Column/ColumnDataLabel.js\", [e[\"Core/Series/DataLabel.js\"], e[\"Core/Globals.js\"], e[\"Core/Series/SeriesRegistry.js\"], e[\"Core/Utilities.js\"]], function (t, e, i, s) {\n    var r;\n    var o = e.composed,\n      n = i.series,\n      a = s.merge,\n      h = s.pick,\n      l = s.pushUnique;\n    return function (e) {\n      function i(t, e, i, s, r) {\n        var o = this.chart.inverted,\n          l = t.series,\n          d = (l.xAxis ? l.xAxis.len : this.chart.plotSizeX) || 0,\n          c = (l.yAxis ? l.yAxis.len : this.chart.plotSizeY) || 0,\n          p = t.dlBox || t.shapeArgs,\n          u = h(t.below, t.plotY > h(this.translatedThreshold, c)),\n          g = h(i.inside, !!this.options.stacking);\n        if (p) {\n          if (s = a(p), !(\"allow\" === i.overflow && !1 === i.crop)) {\n            s.y < 0 && (s.height += s.y, s.y = 0);\n            var _t87 = s.y + s.height - c;\n            _t87 > 0 && _t87 < s.height - 1 && (s.height -= _t87);\n          }\n          o && (s = {\n            x: c - s.y - s.height,\n            y: d - s.x - s.width,\n            width: s.height,\n            height: s.width\n          }), g || (o ? (s.x += u ? 0 : s.width, s.width = 0) : (s.y += u ? s.height : 0, s.height = 0));\n        }\n        i.align = h(i.align, !o || g ? \"center\" : u ? \"right\" : \"left\"), i.verticalAlign = h(i.verticalAlign, o || g ? \"middle\" : u ? \"top\" : \"bottom\"), n.prototype.alignDataLabel.call(this, t, e, i, s, r), i.inside && t.contrastColor && e.css({\n          color: t.contrastColor\n        });\n      }\n      e.compose = function (e) {\n        t.compose(n), l(o, \"ColumnDataLabel\") && (e.prototype.alignDataLabel = i);\n      };\n    }(r || (r = {})), r;\n  }), i(e, \"Series/Bar/BarSeries.js\", [e[\"Series/Column/ColumnSeries.js\"], e[\"Core/Series/SeriesRegistry.js\"], e[\"Core/Utilities.js\"]], function (t, e, i) {\n    var s = i.extend,\n      r = i.merge;\n    var o = /*#__PURE__*/function (_t88) {\n      function o() {\n        _classCallCheck(this, o);\n        return _callSuper(this, o, arguments);\n      }\n      _inherits(o, _t88);\n      return _createClass(o);\n    }(t);\n    return o.defaultOptions = r(t.defaultOptions, {}), s(o.prototype, {\n      inverted: !0\n    }), e.registerSeriesType(\"bar\", o), o;\n  }), i(e, \"Series/Scatter/ScatterSeriesDefaults.js\", [], function () {\n    return {\n      lineWidth: 0,\n      findNearestPointBy: \"xy\",\n      jitter: {\n        x: 0,\n        y: 0\n      },\n      marker: {\n        enabled: !0\n      },\n      tooltip: {\n        headerFormat: '<span style=\"color:{point.color}\">‚óè</span> <span style=\"font-size: 0.8em\"> {series.name}</span><br/>',\n        pointFormat: \"x: <b>{point.x}</b><br/>y: <b>{point.y}</b><br/>\"\n      }\n    };\n  }), i(e, \"Series/Scatter/ScatterSeries.js\", [e[\"Series/Scatter/ScatterSeriesDefaults.js\"], e[\"Core/Series/SeriesRegistry.js\"], e[\"Core/Utilities.js\"]], function (t, e, i) {\n    var _e$seriesTypes2 = e.seriesTypes,\n      s = _e$seriesTypes2.column,\n      r = _e$seriesTypes2.line,\n      o = i.addEvent,\n      n = i.extend,\n      a = i.merge;\n    var h = /*#__PURE__*/function (_r24) {\n      function h() {\n        _classCallCheck(this, h);\n        return _callSuper(this, h, arguments);\n      }\n      _inherits(h, _r24);\n      return _createClass(h, [{\n        key: \"applyJitter\",\n        value: function applyJitter() {\n          var t = this,\n            e = this.options.jitter,\n            i = this.points.length;\n          e && this.points.forEach(function (s, r) {\n            [\"x\", \"y\"].forEach(function (o, n) {\n              if (e[o] && !s.isNull) {\n                var _a17 = \"plot\".concat(o.toUpperCase()),\n                  _h13 = t[\"\".concat(o, \"Axis\")],\n                  l = e[o] * _h13.transA;\n                if (_h13 && !_h13.logarithmic) {\n                  var _t89 = Math.max(0, (s[_a17] || 0) - l),\n                    _e58 = Math.min(_h13.len, (s[_a17] || 0) + l);\n                  s[_a17] = _t89 + (_e58 - _t89) * function (t) {\n                    var e = 1e4 * Math.sin(t);\n                    return e - Math.floor(e);\n                  }(r + n * i), \"x\" === o && (s.clientX = s.plotX);\n                }\n              }\n            });\n          });\n        }\n      }, {\n        key: \"drawGraph\",\n        value: function drawGraph() {\n          this.options.lineWidth ? _superPropGet(h, \"drawGraph\", this, 3)([]) : this.graph && (this.graph = this.graph.destroy());\n        }\n      }]);\n    }(r);\n    return h.defaultOptions = a(r.defaultOptions, t), n(h.prototype, {\n      drawTracker: s.prototype.drawTracker,\n      sorted: !1,\n      requireSorting: !1,\n      noSharedTooltip: !0,\n      trackerGroups: [\"group\", \"markerGroup\", \"dataLabelsGroup\"]\n    }), o(h, \"afterTranslate\", function () {\n      this.applyJitter();\n    }), e.registerSeriesType(\"scatter\", h), h;\n  }), i(e, \"Series/CenteredUtilities.js\", [e[\"Core/Globals.js\"], e[\"Core/Series/Series.js\"], e[\"Core/Utilities.js\"]], function (t, e, i) {\n    var s, r;\n    var o = t.deg2rad,\n      n = i.fireEvent,\n      a = i.isNumber,\n      h = i.pick,\n      l = i.relativeLength;\n    return (r = s || (s = {})).getCenter = function () {\n      var t = this.options,\n        i = this.chart,\n        s = 2 * (t.slicedOffset || 0),\n        r = i.plotWidth - 2 * s,\n        o = i.plotHeight - 2 * s,\n        d = t.center,\n        c = Math.min(r, o),\n        p = t.thickness,\n        u,\n        g = t.size,\n        f = t.innerSize || 0,\n        m,\n        x;\n      \"string\" == typeof g && (g = parseFloat(g)), \"string\" == typeof f && (f = parseFloat(f));\n      var y = [h(d[0], \"50%\"), h(d[1], \"50%\"), h(g && g < 0 ? void 0 : t.size, \"100%\"), h(f && f < 0 ? void 0 : t.innerSize || 0, \"0%\")];\n      for (!i.angular || this instanceof e || (y[3] = 0), m = 0; m < 4; ++m) x = y[m], u = m < 2 || 2 === m && /%$/.test(x), y[m] = l(x, [r, o, c, y[2]][m]) + (u ? s : 0);\n      return y[3] > y[2] && (y[3] = y[2]), a(p) && 2 * p < y[2] && p > 0 && (y[3] = y[2] - 2 * p), n(this, \"afterGetCenter\", {\n        positions: y\n      }), y;\n    }, r.getStartAndEndRadians = function (t, e) {\n      var i = a(t) ? t : 0,\n        s = a(e) && e > i && e - i < 360 ? e : i + 360;\n      return {\n        start: o * (i + -90),\n        end: o * (s + -90)\n      };\n    }, s;\n  }), i(e, \"Series/Pie/PiePoint.js\", [e[\"Core/Animation/AnimationUtilities.js\"], e[\"Core/Series/Point.js\"], e[\"Core/Utilities.js\"]], function (t, e, i) {\n    var s = t.setAnimation,\n      r = i.addEvent,\n      o = i.defined,\n      n = i.extend,\n      a = i.isNumber,\n      h = i.pick,\n      l = i.relativeLength;\n    var d = /*#__PURE__*/function (_e59) {\n      function d(t, e, i) {\n        var _this25$name;\n        var _this25;\n        _classCallCheck(this, d);\n        _this25 = _callSuper(this, d, [t, e, i]), _this25.half = 0, (_this25$name = _this25.name) !== null && _this25$name !== void 0 ? _this25$name : _this25.name = \"Slice\";\n        var s = function s(t) {\n          _this25.slice(\"select\" === t.type);\n        };\n        r(_this25, \"select\", s), r(_this25, \"unselect\", s);\n        return _this25;\n      }\n      _inherits(d, _e59);\n      return _createClass(d, [{\n        key: \"getConnectorPath\",\n        value: function getConnectorPath(t) {\n          var e = t.dataLabelPosition,\n            i = t.options || {},\n            s = i.connectorShape,\n            r = this.connectorShapes[s] || s;\n          return e && r.call(this, _objectSpread(_objectSpread({}, e.computed), {}, {\n            alignment: e.alignment\n          }), e.connectorPosition, i) || [];\n        }\n      }, {\n        key: \"getTranslate\",\n        value: function getTranslate() {\n          return this.sliced && this.slicedTranslation || {\n            translateX: 0,\n            translateY: 0\n          };\n        }\n      }, {\n        key: \"haloPath\",\n        value: function haloPath(t) {\n          var e = this.shapeArgs;\n          return this.sliced || !this.visible ? [] : this.series.chart.renderer.symbols.arc(e.x, e.y, e.r + t, e.r + t, {\n            innerR: e.r - 1,\n            start: e.start,\n            end: e.end,\n            borderRadius: e.borderRadius\n          });\n        }\n      }, {\n        key: \"isValid\",\n        value: function isValid() {\n          return a(this.y) && this.y >= 0;\n        }\n      }, {\n        key: \"setVisible\",\n        value: function setVisible(t) {\n          var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !0;\n          t !== this.visible && this.update({\n            visible: t !== null && t !== void 0 ? t : !this.visible\n          }, e, void 0, !1);\n        }\n      }, {\n        key: \"slice\",\n        value: function slice(t, e, i) {\n          var r = this.series;\n          s(i, r.chart), e = h(e, !0), this.sliced = this.options.sliced = t = o(t) ? t : !this.sliced, r.options.data[r.data.indexOf(this)] = this.options, this.graphic && this.graphic.animate(this.getTranslate());\n        }\n      }]);\n    }(e);\n    return n(d.prototype, {\n      connectorShapes: {\n        fixedOffset: function fixedOffset(t, e, i) {\n          var s = e.breakAt,\n            r = e.touchingSliceAt,\n            o = i.softConnector ? [\"C\", t.x + (\"left\" === t.alignment ? -5 : 5), t.y, 2 * s.x - r.x, 2 * s.y - r.y, s.x, s.y] : [\"L\", s.x, s.y];\n          return [[\"M\", t.x, t.y], o, [\"L\", r.x, r.y]];\n        },\n        straight: function straight(t, e) {\n          var i = e.touchingSliceAt;\n          return [[\"M\", t.x, t.y], [\"L\", i.x, i.y]];\n        },\n        crookedLine: function crookedLine(t, e, i) {\n          var s = e.breakAt,\n            r = e.touchingSliceAt,\n            o = this.series,\n            _o$center = _slicedToArray(o.center, 3),\n            n = _o$center[0],\n            a = _o$center[1],\n            h = _o$center[2],\n            d = h / 2,\n            _o$chart = o.chart,\n            c = _o$chart.plotLeft,\n            p = _o$chart.plotWidth,\n            u = \"left\" === t.alignment,\n            g = t.x,\n            f = t.y,\n            m = s.x;\n          if (i.crookDistance) {\n            var _t90 = l(i.crookDistance, 1);\n            m = u ? n + d + (p + c - n - d) * (1 - _t90) : c + (n - d) * _t90;\n          } else m = n + (a - f) * Math.tan((this.angle || 0) - Math.PI / 2);\n          var x = [[\"M\", g, f]];\n          return (u ? m <= g && m >= s.x : m >= g && m <= s.x) && x.push([\"L\", m, f]), x.push([\"L\", s.x, s.y], [\"L\", r.x, r.y]), x;\n        }\n      }\n    }), d;\n  }), i(e, \"Series/Pie/PieSeriesDefaults.js\", [], function () {\n    return {\n      borderRadius: 3,\n      center: [null, null],\n      clip: !1,\n      colorByPoint: !0,\n      dataLabels: {\n        connectorPadding: 5,\n        connectorShape: \"crookedLine\",\n        crookDistance: void 0,\n        distance: 30,\n        enabled: !0,\n        formatter: function formatter() {\n          return this.point.isNull ? void 0 : this.point.name;\n        },\n        softConnector: !0,\n        x: 0\n      },\n      fillColor: void 0,\n      ignoreHiddenPoint: !0,\n      inactiveOtherPoints: !0,\n      legendType: \"point\",\n      marker: null,\n      size: null,\n      showInLegend: !1,\n      slicedOffset: 10,\n      stickyTracking: !1,\n      tooltip: {\n        followPointer: !0\n      },\n      borderColor: \"#ffffff\",\n      borderWidth: 1,\n      lineWidth: void 0,\n      states: {\n        hover: {\n          brightness: .1\n        }\n      }\n    };\n  }), i(e, \"Series/Pie/PieSeries.js\", [e[\"Series/CenteredUtilities.js\"], e[\"Series/Column/ColumnSeries.js\"], e[\"Core/Globals.js\"], e[\"Series/Pie/PiePoint.js\"], e[\"Series/Pie/PieSeriesDefaults.js\"], e[\"Core/Series/Series.js\"], e[\"Core/Series/SeriesRegistry.js\"], e[\"Core/Renderer/SVG/Symbols.js\"], e[\"Core/Utilities.js\"]], function (t, e, i, s, r, o, n, a, h) {\n    var l = t.getStartAndEndRadians,\n      d = i.noop,\n      c = h.clamp,\n      p = h.extend,\n      u = h.fireEvent,\n      g = h.merge,\n      f = h.pick;\n    var m = /*#__PURE__*/function (_o28) {\n      function m() {\n        _classCallCheck(this, m);\n        return _callSuper(this, m, arguments);\n      }\n      _inherits(m, _o28);\n      return _createClass(m, [{\n        key: \"animate\",\n        value: function animate(t) {\n          var e = this,\n            i = e.points,\n            s = e.startAngleRad;\n          t || i.forEach(function (t) {\n            var i = t.graphic,\n              r = t.shapeArgs;\n            i && r && (i.attr({\n              r: f(t.startR, e.center && e.center[3] / 2),\n              start: s,\n              end: s\n            }), i.animate({\n              r: r.r,\n              start: r.start,\n              end: r.end\n            }, e.options.animation));\n          });\n        }\n      }, {\n        key: \"drawEmpty\",\n        value: function drawEmpty() {\n          var t, e;\n          var i = this.startAngleRad,\n            s = this.endAngleRad,\n            r = this.options;\n          0 === this.total && this.center ? (t = this.center[0], e = this.center[1], this.graph || (this.graph = this.chart.renderer.arc(t, e, this.center[1] / 2, 0, i, s).addClass(\"highcharts-empty-series\").add(this.group)), this.graph.attr({\n            d: a.arc(t, e, this.center[2] / 2, 0, {\n              start: i,\n              end: s,\n              innerR: this.center[3] / 2\n            })\n          }), this.chart.styledMode || this.graph.attr({\n            \"stroke-width\": r.borderWidth,\n            fill: r.fillColor || \"none\",\n            stroke: r.color || \"#cccccc\"\n          })) : this.graph && (this.graph = this.graph.destroy());\n        }\n      }, {\n        key: \"drawPoints\",\n        value: function drawPoints() {\n          var t = this.chart.renderer;\n          this.points.forEach(function (e) {\n            e.graphic && e.hasNewShapeType() && (e.graphic = e.graphic.destroy()), e.graphic || (e.graphic = t[e.shapeType](e.shapeArgs).add(e.series.group), e.delayedRendering = !0);\n          });\n        }\n      }, {\n        key: \"generatePoints\",\n        value: function generatePoints() {\n          _superPropGet(m, \"generatePoints\", this, 3)([]), this.updateTotals();\n        }\n      }, {\n        key: \"getX\",\n        value: function getX(t, e, i, s) {\n          var r = this.center,\n            o = this.radii ? this.radii[i.index] || 0 : r[2] / 2,\n            n = s.dataLabelPosition,\n            a = (n === null || n === void 0 ? void 0 : n.distance) || 0,\n            h = Math.asin(c((t - r[1]) / (o + a), -1, 1));\n          return r[0] + Math.cos(h) * (o + a) * (e ? -1 : 1) + (a > 0 ? (e ? -1 : 1) * (s.padding || 0) : 0);\n        }\n      }, {\n        key: \"hasData\",\n        value: function hasData() {\n          return !!this.processedXData.length;\n        }\n      }, {\n        key: \"redrawPoints\",\n        value: function redrawPoints() {\n          var t, e, i, s;\n          var r = this,\n            o = r.chart;\n          this.drawEmpty(), r.group && !o.styledMode && r.group.shadow(r.options.shadow), r.points.forEach(function (n) {\n            var a = {};\n            e = n.graphic, !n.isNull && e ? (s = n.shapeArgs, t = n.getTranslate(), o.styledMode || (i = r.pointAttribs(n, n.selected && \"select\")), n.delayedRendering ? (e.setRadialReference(r.center).attr(s).attr(t), o.styledMode || e.attr(i).attr({\n              \"stroke-linejoin\": \"round\"\n            }), n.delayedRendering = !1) : (e.setRadialReference(r.center), o.styledMode || g(!0, a, i), g(!0, a, s, t), e.animate(a)), e.attr({\n              visibility: n.visible ? \"inherit\" : \"hidden\"\n            }), e.addClass(n.getClassName(), !0)) : e && (n.graphic = e.destroy());\n          });\n        }\n      }, {\n        key: \"sortByAngle\",\n        value: function sortByAngle(t, e) {\n          t.sort(function (t, i) {\n            return void 0 !== t.angle && (i.angle - t.angle) * e;\n          });\n        }\n      }, {\n        key: \"translate\",\n        value: function translate(t) {\n          u(this, \"translate\"), this.generatePoints();\n          var e = this.options,\n            i = e.slicedOffset,\n            s = l(e.startAngle, e.endAngle),\n            r = this.startAngleRad = s.start,\n            o = (this.endAngleRad = s.end) - r,\n            n = this.points,\n            a = e.ignoreHiddenPoint,\n            h = n.length,\n            d,\n            c,\n            p,\n            g,\n            f,\n            _m5,\n            x,\n            y = 0;\n          for (t || (this.center = t = this.getCenter()), _m5 = 0; _m5 < h; _m5++) {\n            x = n[_m5], d = r + y * o, x.isValid() && (!a || x.visible) && (y += x.percentage / 100), c = r + y * o;\n            var _e60 = {\n              x: t[0],\n              y: t[1],\n              r: t[2] / 2,\n              innerR: t[3] / 2,\n              start: Math.round(1e3 * d) / 1e3,\n              end: Math.round(1e3 * c) / 1e3\n            };\n            x.shapeType = \"arc\", x.shapeArgs = _e60, (p = (c + d) / 2) > 1.5 * Math.PI ? p -= 2 * Math.PI : p < -Math.PI / 2 && (p += 2 * Math.PI), x.slicedTranslation = {\n              translateX: Math.round(Math.cos(p) * i),\n              translateY: Math.round(Math.sin(p) * i)\n            }, g = Math.cos(p) * t[2] / 2, f = Math.sin(p) * t[2] / 2, x.tooltipPos = [t[0] + .7 * g, t[1] + .7 * f], x.half = p < -Math.PI / 2 || p > Math.PI / 2 ? 1 : 0, x.angle = p;\n          }\n          u(this, \"afterTranslate\");\n        }\n      }, {\n        key: \"updateTotals\",\n        value: function updateTotals() {\n          var t = this.points,\n            e = t.length,\n            i = this.options.ignoreHiddenPoint,\n            s,\n            r,\n            o = 0;\n          for (s = 0; s < e; s++) (r = t[s]).isValid() && (!i || r.visible) && (o += r.y);\n          for (s = 0, this.total = o; s < e; s++) (r = t[s]).percentage = o > 0 && (r.visible || !i) ? r.y / o * 100 : 0, r.total = o;\n        }\n      }]);\n    }(o);\n    return m.defaultOptions = g(o.defaultOptions, r), p(m.prototype, {\n      axisTypes: [],\n      directTouch: !0,\n      drawGraph: void 0,\n      drawTracker: e.prototype.drawTracker,\n      getCenter: t.getCenter,\n      getSymbol: d,\n      invertible: !1,\n      isCartesian: !1,\n      noSharedTooltip: !0,\n      pointAttribs: e.prototype.pointAttribs,\n      pointClass: s,\n      requireSorting: !1,\n      searchPoint: d,\n      trackerGroups: [\"group\", \"dataLabelsGroup\"]\n    }), n.registerSeriesType(\"pie\", m), m;\n  }), i(e, \"Series/Pie/PieDataLabel.js\", [e[\"Core/Series/DataLabel.js\"], e[\"Core/Globals.js\"], e[\"Core/Renderer/RendererUtilities.js\"], e[\"Core/Series/SeriesRegistry.js\"], e[\"Core/Utilities.js\"]], function (t, e, i, s, r) {\n    var o;\n    var n = e.composed,\n      a = e.noop,\n      h = i.distribute,\n      l = s.series,\n      d = r.arrayMax,\n      c = r.clamp,\n      p = r.defined,\n      u = r.pick,\n      g = r.pushUnique,\n      f = r.relativeLength;\n    return function (e) {\n      var i = {\n        radialDistributionY: function radialDistributionY(t, e) {\n          var _e$dataLabelPosition;\n          return (((_e$dataLabelPosition = e.dataLabelPosition) === null || _e$dataLabelPosition === void 0 ? void 0 : _e$dataLabelPosition.top) || 0) + t.distributeBox.pos;\n        },\n        radialDistributionX: function radialDistributionX(t, e, i, s, r) {\n          var o = r.dataLabelPosition;\n          return t.getX(i < ((o === null || o === void 0 ? void 0 : o.top) || 0) + 2 || i > ((o === null || o === void 0 ? void 0 : o.bottom) || 0) - 2 ? s : i, e.half, e, r);\n        },\n        justify: function justify(t, e, i, s) {\n          var _e$dataLabelPosition2;\n          return s[0] + (t.half ? -1 : 1) * (i + (((_e$dataLabelPosition2 = e.dataLabelPosition) === null || _e$dataLabelPosition2 === void 0 ? void 0 : _e$dataLabelPosition2.distance) || 0));\n        },\n        alignToPlotEdges: function alignToPlotEdges(t, e, i, s) {\n          var r = t.getBBox().width;\n          return e ? r + s : i - r - s;\n        },\n        alignToConnectors: function alignToConnectors(t, e, i, s) {\n          var r = 0,\n            o;\n          return t.forEach(function (t) {\n            (o = t.dataLabel.getBBox().width) > r && (r = o);\n          }), e ? r + s : i - r - s;\n        }\n      };\n      function s(t, e) {\n        var i = this.center,\n          s = this.options,\n          r = i[2] / 2,\n          o = t.angle || 0,\n          n = Math.cos(o),\n          a = Math.sin(o),\n          h = i[0] + n * r,\n          l = i[1] + a * r,\n          d = Math.min((s.slicedOffset || 0) + (s.borderWidth || 0), e / 5);\n        return {\n          natural: {\n            x: h + n * e,\n            y: l + a * e\n          },\n          computed: {},\n          alignment: e < 0 ? \"center\" : t.half ? \"right\" : \"left\",\n          connectorPosition: {\n            breakAt: {\n              x: h + n * d,\n              y: l + a * d\n            },\n            touchingSliceAt: {\n              x: h,\n              y: l\n            }\n          },\n          distance: e\n        };\n      }\n      function r() {\n        var _t$hasDataLabels,\n          _this26 = this;\n        var t = this,\n          e = t.points,\n          i = t.chart,\n          s = i.plotWidth,\n          r = i.plotHeight,\n          o = i.plotLeft,\n          n = Math.round(i.chartWidth / 3),\n          a = t.center,\n          c = a[2] / 2,\n          g = a[1],\n          m = [[], []],\n          x = [0, 0, 0, 0],\n          y = t.dataLabelPositioners,\n          b,\n          v,\n          S,\n          C = 0;\n        t.visible && ((_t$hasDataLabels = t.hasDataLabels) === null || _t$hasDataLabels === void 0 ? void 0 : _t$hasDataLabels.call(t)) && (e.forEach(function (t) {\n          (t.dataLabels || []).forEach(function (t) {\n            t.shortened && (t.attr({\n              width: \"auto\"\n            }).css({\n              width: \"auto\",\n              textOverflow: \"clip\"\n            }), t.shortened = !1);\n          });\n        }), l.prototype.drawDataLabels.apply(t), e.forEach(function (t) {\n          (t.dataLabels || []).forEach(function (e, i) {\n            var _r$style;\n            var s = a[2] / 2,\n              r = e.options,\n              o = f((r === null || r === void 0 ? void 0 : r.distance) || 0, s);\n            0 === i && m[t.half].push(t), !p(r === null || r === void 0 || (_r$style = r.style) === null || _r$style === void 0 ? void 0 : _r$style.width) && e.getBBox().width > n && (e.css({\n              width: Math.round(.7 * n) + \"px\"\n            }), e.shortened = !0), e.dataLabelPosition = _this26.getDataLabelPosition(t, o), C = Math.max(C, o);\n          });\n        }), m.forEach(function (e, n) {\n          var l = e.length,\n            d = [],\n            f,\n            m,\n            b = 0,\n            k;\n          l && (t.sortByAngle(e, n - .5), C > 0 && (f = Math.max(0, g - c - C), m = Math.min(g + c + C, i.plotHeight), e.forEach(function (t) {\n            (t.dataLabels || []).forEach(function (e) {\n              var _e$dataLabelPosition3;\n              var s = e.dataLabelPosition;\n              s && s.distance > 0 && (s.top = Math.max(0, g - c - s.distance), s.bottom = Math.min(g + c + s.distance, i.plotHeight), b = e.getBBox().height || 21, e.lineHeight = i.renderer.fontMetrics(e.text || e).h + 2 * e.padding, t.distributeBox = {\n                target: (((_e$dataLabelPosition3 = e.dataLabelPosition) === null || _e$dataLabelPosition3 === void 0 ? void 0 : _e$dataLabelPosition3.natural.y) || 0) - s.top + e.lineHeight / 2,\n                size: b,\n                rank: t.y\n              }, d.push(t.distributeBox));\n            });\n          }), h(d, k = m + b - f, k / 5)), e.forEach(function (i) {\n            (i.dataLabels || []).forEach(function (h) {\n              var l = h.options || {},\n                g = i.distributeBox,\n                f = h.dataLabelPosition,\n                m = (f === null || f === void 0 ? void 0 : f.natural.y) || 0,\n                b = l.connectorPadding || 0,\n                C = h.lineHeight || 21,\n                k = (C - h.getBBox().height) / 2,\n                M = 0,\n                w = m,\n                A = \"inherit\";\n              if (f) {\n                if (d && p(g) && f.distance > 0 && (void 0 === g.pos ? A = \"hidden\" : (S = g.size, w = y.radialDistributionY(i, h))), l.justify) M = y.justify(i, h, c, a);else switch (l.alignTo) {\n                  case \"connectors\":\n                    M = y.alignToConnectors(e, n, s, o);\n                    break;\n                  case \"plotEdges\":\n                    M = y.alignToPlotEdges(h, n, s, o);\n                    break;\n                  default:\n                    M = y.radialDistributionX(t, i, w - k, m, h);\n                }\n                if (f.attribs = {\n                  visibility: A,\n                  align: f.alignment\n                }, f.posAttribs = {\n                  x: M + (l.x || 0) + ({\n                    left: b,\n                    right: -b\n                  }[f.alignment] || 0),\n                  y: w + (l.y || 0) - C / 2\n                }, f.computed.x = M, f.computed.y = w - k, u(l.crop, !0)) {\n                  var _t91;\n                  M - (v = h.getBBox().width) < b && 1 === n ? (_t91 = Math.round(v - M + b), x[3] = Math.max(_t91, x[3])) : M + v > s - b && 0 === n && (_t91 = Math.round(M + v - s + b), x[1] = Math.max(_t91, x[1])), w - S / 2 < 0 ? x[0] = Math.max(Math.round(-w + S / 2), x[0]) : w + S / 2 > r && (x[2] = Math.max(Math.round(w + S / 2 - r), x[2])), f.sideOverflow = _t91;\n                }\n              }\n            });\n          }));\n        }), (0 === d(x) || this.verifyDataLabelOverflow(x)) && (this.placeDataLabels(), this.points.forEach(function (e) {\n          (e.dataLabels || []).forEach(function (s) {\n            var _ref17 = s.options || {},\n              r = _ref17.connectorColor,\n              _ref17$connectorWidth = _ref17.connectorWidth,\n              o = _ref17$connectorWidth === void 0 ? 1 : _ref17$connectorWidth,\n              n = s.dataLabelPosition;\n            if (o) {\n              var _n$attribs;\n              var _a18;\n              b = s.connector, n && n.distance > 0 ? (_a18 = !b, b || (s.connector = b = i.renderer.path().addClass(\"highcharts-data-label-connector  highcharts-color-\" + e.colorIndex + (e.className ? \" \" + e.className : \"\")).add(t.dataLabelsGroup)), i.styledMode || b.attr({\n                \"stroke-width\": o,\n                stroke: r || e.color || \"#666666\"\n              }), b[_a18 ? \"attr\" : \"animate\"]({\n                d: e.getConnectorPath(s)\n              }), b.attr({\n                visibility: (_n$attribs = n.attribs) === null || _n$attribs === void 0 ? void 0 : _n$attribs.visibility\n              })) : b && (s.connector = b.destroy());\n            }\n          });\n        })));\n      }\n      function o() {\n        this.points.forEach(function (t) {\n          (t.dataLabels || []).forEach(function (t) {\n            var _t$options4;\n            var e = t.dataLabelPosition;\n            e ? (e.sideOverflow && (t.css({\n              width: Math.max(t.getBBox().width - e.sideOverflow, 0) + \"px\",\n              textOverflow: (((_t$options4 = t.options) === null || _t$options4 === void 0 ? void 0 : _t$options4.style) || {}).textOverflow || \"ellipsis\"\n            }), t.shortened = !0), t.attr(e.attribs), t[t.moved ? \"animate\" : \"attr\"](e.posAttribs), t.moved = !0) : t && t.attr({\n              y: -9999\n            });\n          }), delete t.distributeBox;\n        }, this);\n      }\n      function m(t) {\n        var e = this.center,\n          i = this.options,\n          s = i.center,\n          r = i.minSize || 80,\n          o = r,\n          n = null !== i.size;\n        return !n && (null !== s[0] ? o = Math.max(e[2] - Math.max(t[1], t[3]), r) : (o = Math.max(e[2] - t[1] - t[3], r), e[0] += (t[3] - t[1]) / 2), null !== s[1] ? o = c(o, r, e[2] - Math.max(t[0], t[2])) : (o = c(o, r, e[2] - t[0] - t[2]), e[1] += (t[0] - t[2]) / 2), o < e[2] ? (e[2] = o, e[3] = Math.min(i.thickness ? Math.max(0, o - 2 * i.thickness) : Math.max(0, f(i.innerSize || 0, o)), o), this.translate(e), this.drawDataLabels && this.drawDataLabels()) : n = !0), n;\n      }\n      e.compose = function (e) {\n        if (t.compose(l), g(n, \"PieDataLabel\")) {\n          var _t92 = e.prototype;\n          _t92.dataLabelPositioners = i, _t92.alignDataLabel = a, _t92.drawDataLabels = r, _t92.getDataLabelPosition = s, _t92.placeDataLabels = o, _t92.verifyDataLabelOverflow = m;\n        }\n      };\n    }(o || (o = {})), o;\n  }), i(e, \"Core/Geometry/GeometryUtilities.js\", [], function () {\n    var t, e;\n    return (e = t || (t = {})).getCenterOfPoints = function (t) {\n      var e = t.reduce(function (t, e) {\n        return t.x += e.x, t.y += e.y, t;\n      }, {\n        x: 0,\n        y: 0\n      });\n      return {\n        x: e.x / t.length,\n        y: e.y / t.length\n      };\n    }, e.getDistanceBetweenPoints = function (t, e) {\n      return Math.sqrt(Math.pow(e.x - t.x, 2) + Math.pow(e.y - t.y, 2));\n    }, e.getAngleBetweenPoints = function (t, e) {\n      return Math.atan2(e.x - t.x, e.y - t.y);\n    }, e.pointInPolygon = function (_ref18, i) {\n      var t = _ref18.x,\n        e = _ref18.y;\n      var s = i.length,\n        r,\n        o,\n        n = !1;\n      for (r = 0, o = s - 1; r < s; o = r++) {\n        var _i$r = _slicedToArray(i[r], 2),\n          _s43 = _i$r[0],\n          a = _i$r[1],\n          _i$o = _slicedToArray(i[o], 2),\n          h = _i$o[0],\n          l = _i$o[1];\n        a > e != l > e && t < (h - _s43) * (e - a) / (l - a) + _s43 && (n = !n);\n      }\n      return n;\n    }, t;\n  }), i(e, \"Extensions/OverlappingDataLabels.js\", [e[\"Core/Geometry/GeometryUtilities.js\"], e[\"Core/Utilities.js\"]], function (t, e) {\n    var i = t.pointInPolygon,\n      s = e.addEvent,\n      r = e.fireEvent,\n      o = e.objectEach,\n      n = e.pick;\n    function a(t) {\n      var e = t.length,\n        s = function s(t, e) {\n          return !(e.x >= t.x + t.width || e.x + e.width <= t.x || e.y >= t.y + t.height || e.y + e.height <= t.y);\n        },\n        o = function o(t, e) {\n          var _iterator18 = _createForOfIteratorHelper(t),\n            _step18;\n          try {\n            for (_iterator18.s(); !(_step18 = _iterator18.n()).done;) {\n              var _s44 = _step18.value;\n              if (i({\n                x: _s44[0],\n                y: _s44[1]\n              }, e)) return !0;\n            }\n          } catch (err) {\n            _iterator18.e(err);\n          } finally {\n            _iterator18.f();\n          }\n          return !1;\n        },\n        n,\n        a,\n        l,\n        d,\n        c,\n        p = !1;\n      for (var _i49 = 0; _i49 < e; _i49++) (n = t[_i49]) && (n.oldOpacity = n.opacity, n.newOpacity = 1, n.absoluteBox = function (t) {\n        if (t && (!t.alignAttr || t.placed)) {\n          var _t$parentGroup2, _t$parentGroup3;\n          var _e61 = t.box ? 0 : t.padding || 0,\n            _i50 = t.alignAttr || {\n              x: t.attr(\"x\"),\n              y: t.attr(\"y\")\n            },\n            _s45 = t.getBBox();\n          return t.width = _s45.width, t.height = _s45.height, {\n            x: _i50.x + (((_t$parentGroup2 = t.parentGroup) === null || _t$parentGroup2 === void 0 ? void 0 : _t$parentGroup2.translateX) || 0) + _e61,\n            y: _i50.y + (((_t$parentGroup3 = t.parentGroup) === null || _t$parentGroup3 === void 0 ? void 0 : _t$parentGroup3.translateY) || 0) + _e61,\n            width: (t.width || 0) - 2 * _e61,\n            height: (t.height || 0) - 2 * _e61,\n            polygon: _s45 === null || _s45 === void 0 ? void 0 : _s45.polygon\n          };\n        }\n      }(n));\n      t.sort(function (t, e) {\n        return (e.labelrank || 0) - (t.labelrank || 0);\n      });\n      for (var _i51 = 0; _i51 < e; ++_i51) {\n        var _d9;\n        d = (a = t[_i51]) && a.absoluteBox;\n        var _r25 = (_d9 = d) === null || _d9 === void 0 ? void 0 : _d9.polygon;\n        for (var _n17 = _i51 + 1; _n17 < e; ++_n17) {\n          c = (l = t[_n17]) && l.absoluteBox;\n          var _e62 = !1;\n          if (d && c && a !== l && 0 !== a.newOpacity && 0 !== l.newOpacity && \"hidden\" !== a.visibility && \"hidden\" !== l.visibility) {\n            var _t93 = c.polygon;\n            if (_r25 && _t93 && _r25 !== _t93 ? o(_r25, _t93) && (_e62 = !0) : s(d, c) && (_e62 = !0), _e62) {\n              var _t94 = a.labelrank < l.labelrank ? a : l,\n                _e63 = _t94.text;\n              _t94.newOpacity = 0, (_e63 === null || _e63 === void 0 ? void 0 : _e63.element.querySelector(\"textPath\")) && _e63.hide();\n            }\n          }\n        }\n      }\n      var _iterator19 = _createForOfIteratorHelper(t),\n        _step19;\n      try {\n        for (_iterator19.s(); !(_step19 = _iterator19.n()).done;) {\n          var _e64 = _step19.value;\n          h(_e64, this) && (p = !0);\n        }\n      } catch (err) {\n        _iterator19.e(err);\n      } finally {\n        _iterator19.f();\n      }\n      p && r(this, \"afterHideAllOverlappingLabels\");\n    }\n    function h(t, e) {\n      var i,\n        s,\n        o = !1;\n      return t && (s = t.newOpacity, t.oldOpacity !== s && (t.hasClass(\"highcharts-data-label\") ? (t[s ? \"removeClass\" : \"addClass\"](\"highcharts-data-label-hidden\"), i = function i() {\n        e.styledMode || t.css({\n          pointerEvents: s ? \"auto\" : \"none\"\n        });\n      }, o = !0, t[t.isOld ? \"animate\" : \"attr\"]({\n        opacity: s\n      }, void 0, i), r(e, \"afterHideOverlappingLabel\")) : t.attr({\n        opacity: s\n      })), t.isOld = !0), o;\n    }\n    function l() {\n      var t = this,\n        e = [];\n      var _iterator20 = _createForOfIteratorHelper(t.labelCollectors || []),\n        _step20;\n      try {\n        for (_iterator20.s(); !(_step20 = _iterator20.n()).done;) {\n          var _i52 = _step20.value;\n          e = e.concat(_i52());\n        }\n      } catch (err) {\n        _iterator20.e(err);\n      } finally {\n        _iterator20.f();\n      }\n      var _iterator21 = _createForOfIteratorHelper(t.yAxis || []),\n        _step21;\n      try {\n        for (_iterator21.s(); !(_step21 = _iterator21.n()).done;) {\n          var _i53 = _step21.value;\n          _i53.stacking && _i53.options.stackLabels && !_i53.options.stackLabels.allowOverlap && o(_i53.stacking.stacks, function (t) {\n            o(t, function (t) {\n              t.label && e.push(t.label);\n            });\n          });\n        }\n      } catch (err) {\n        _iterator21.e(err);\n      } finally {\n        _iterator21.f();\n      }\n      var _iterator22 = _createForOfIteratorHelper(t.series || []),\n        _step22;\n      try {\n        for (_iterator22.s(); !(_step22 = _iterator22.n()).done;) {\n          var _i54$hasDataLabels;\n          var _i54 = _step22.value;\n          if (_i54.visible && (_i54$hasDataLabels = _i54.hasDataLabels) !== null && _i54$hasDataLabels !== void 0 && _i54$hasDataLabels.call(_i54)) {\n            var _s46 = function _s46(i) {\n              var _iterator23 = _createForOfIteratorHelper(i),\n                _step23;\n              try {\n                var _loop = function _loop() {\n                  var s = _step23.value;\n                  s.visible && (s.dataLabels || []).forEach(function (i) {\n                    var _s$shapeArgs, _r$allowOverlap;\n                    var r = i.options || {};\n                    i.labelrank = n(r.labelrank, s.labelrank, (_s$shapeArgs = s.shapeArgs) === null || _s$shapeArgs === void 0 ? void 0 : _s$shapeArgs.height), ((_r$allowOverlap = r.allowOverlap) !== null && _r$allowOverlap !== void 0 ? _r$allowOverlap : Number(r.distance) > 0) ? (i.oldOpacity = i.opacity, i.newOpacity = 1, h(i, t)) : e.push(i);\n                  });\n                };\n                for (_iterator23.s(); !(_step23 = _iterator23.n()).done;) {\n                  _loop();\n                }\n              } catch (err) {\n                _iterator23.e(err);\n              } finally {\n                _iterator23.f();\n              }\n            };\n            _s46(_i54.nodes || []), _s46(_i54.points);\n          }\n        }\n      } catch (err) {\n        _iterator22.e(err);\n      } finally {\n        _iterator22.f();\n      }\n      this.hideOverlappingLabels(e);\n    }\n    return {\n      compose: function compose(t) {\n        var e = t.prototype;\n        e.hideOverlappingLabels || (e.hideOverlappingLabels = a, s(t, \"render\", l));\n      }\n    };\n  }), i(e, \"Extensions/BorderRadius.js\", [e[\"Core/Defaults.js\"], e[\"Core/Globals.js\"], e[\"Core/Utilities.js\"]], function (t, e, i) {\n    var s = t.defaultOptions,\n      r = e.noop,\n      o = i.addEvent,\n      n = i.extend,\n      a = i.isObject,\n      h = i.merge,\n      l = i.relativeLength,\n      d = {\n        radius: 0,\n        scope: \"stack\",\n        where: void 0\n      },\n      c = r,\n      p = r;\n    function u(t, e, i, s) {\n      var r = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n      var o = c(t, e, i, s, r),\n        _r$innerR = r.innerR,\n        n = _r$innerR === void 0 ? 0 : _r$innerR,\n        _r$r = r.r,\n        a = _r$r === void 0 ? i : _r$r,\n        _r$start = r.start,\n        h = _r$start === void 0 ? 0 : _r$start,\n        _r$end = r.end,\n        d = _r$end === void 0 ? 0 : _r$end;\n      if (r.open || !r.borderRadius) return o;\n      var p = d - h,\n        g = Math.sin(p / 2),\n        f = Math.max(Math.min(l(r.borderRadius || 0, a - n), (a - n) / 2, a * g / (1 + g)), 0),\n        m = Math.min(f, p / Math.PI * 2 * n),\n        x = o.length - 1;\n      for (; x--;) !function (t, e, i) {\n        var s, r, o;\n        var n = t[e],\n          a = t[e + 1];\n        if (\"Z\" === a[0] && (a = t[0]), (\"M\" === n[0] || \"L\" === n[0]) && \"A\" === a[0] ? (s = n, r = a, o = !0) : \"A\" === n[0] && (\"M\" === a[0] || \"L\" === a[0]) && (s = a, r = n), s && r && r.params) {\n          var _n18 = r[1],\n            _a19 = r[5],\n            _h14 = r.params,\n            _l7 = _h14.start,\n            _d10 = _h14.end,\n            _c8 = _h14.cx,\n            _p11 = _h14.cy,\n            _u5 = _a19 ? _n18 - i : _n18 + i,\n            _g6 = _u5 ? Math.asin(i / _u5) : 0,\n            _f3 = _a19 ? _g6 : -_g6,\n            _m6 = Math.cos(_g6) * _u5;\n          o ? (_h14.start = _l7 + _f3, s[1] = _c8 + _m6 * Math.cos(_l7), s[2] = _p11 + _m6 * Math.sin(_l7), t.splice(e + 1, 0, [\"A\", i, i, 0, 0, 1, _c8 + _n18 * Math.cos(_h14.start), _p11 + _n18 * Math.sin(_h14.start)])) : (_h14.end = _d10 - _f3, r[6] = _c8 + _n18 * Math.cos(_h14.end), r[7] = _p11 + _n18 * Math.sin(_h14.end), t.splice(e + 1, 0, [\"A\", i, i, 0, 0, 1, _c8 + _m6 * Math.cos(_d10), _p11 + _m6 * Math.sin(_d10)])), r[4] = Math.abs(_h14.end - _h14.start) < Math.PI ? 0 : 1;\n        }\n      }(o, x, x > 1 ? m : f);\n      return o;\n    }\n    function g() {\n      if (this.options.borderRadius && !(this.chart.is3d && this.chart.is3d())) {\n        var _s$plotOptions;\n        var _t95 = this.options,\n          _e65 = this.yAxis,\n          _i55 = \"percent\" === _t95.stacking,\n          _r26 = (_s$plotOptions = s.plotOptions) === null || _s$plotOptions === void 0 || (_s$plotOptions = _s$plotOptions[this.type]) === null || _s$plotOptions === void 0 ? void 0 : _s$plotOptions.borderRadius,\n          _o29 = f(_t95.borderRadius, a(_r26) ? _r26 : {}),\n          _h15 = _e65.options.reversed;\n        var _iterator24 = _createForOfIteratorHelper(this.points),\n          _step24;\n        try {\n          for (_iterator24.s(); !(_step24 = _iterator24.n()).done;) {\n            var _s47 = _step24.value;\n            var _r27 = _s47.shapeArgs;\n            if (\"roundedRect\" === _s47.shapeType && _r27) {\n              var _r27$width = _r27.width,\n                _a20 = _r27$width === void 0 ? 0 : _r27$width,\n                _r27$height = _r27.height,\n                _d11 = _r27$height === void 0 ? 0 : _r27$height,\n                _r27$y = _r27.y,\n                _c9 = _r27$y === void 0 ? 0 : _r27$y,\n                _p12 = _c9,\n                _u6 = _d11;\n              if (\"stack\" === _o29.scope && _s47.stackTotal) {\n                var _r28 = _e65.translate(_i55 ? 100 : _s47.stackTotal, !1, !0, !1, !0),\n                  _o30 = _e65.translate(_t95.threshold || 0, !1, !0, !1, !0),\n                  _n19 = this.crispCol(0, Math.min(_r28, _o30), 0, Math.abs(_r28 - _o30));\n                _p12 = _n19.y, _u6 = _n19.height;\n              }\n              var _g7 = (_s47.negative ? -1 : 1) * (_h15 ? -1 : 1) == -1,\n                _f4 = _o29.where;\n              !_f4 && this.is(\"waterfall\") && Math.abs((_s47.yBottom || 0) - (this.translatedThreshold || 0)) > this.borderWidth && (_f4 = \"all\"), _f4 || (_f4 = \"end\");\n              var _m7 = Math.min(l(_o29.radius, _a20), _a20 / 2, \"all\" === _f4 ? _d11 / 2 : 1 / 0) || 0;\n              \"end\" === _f4 && (_g7 && (_p12 -= _m7), _u6 += _m7), n(_r27, {\n                brBoxHeight: _u6,\n                brBoxY: _p12,\n                r: _m7\n              });\n            }\n          }\n        } catch (err) {\n          _iterator24.e(err);\n        } finally {\n          _iterator24.f();\n        }\n      }\n    }\n    function f(t, e) {\n      return a(t) || (t = {\n        radius: t || 0\n      }), h(d, e, t);\n    }\n    function m() {\n      var t = f(this.options.borderRadius);\n      var _iterator25 = _createForOfIteratorHelper(this.points),\n        _step25;\n      try {\n        for (_iterator25.s(); !(_step25 = _iterator25.n()).done;) {\n          var _e66 = _step25.value;\n          var _i56 = _e66.shapeArgs;\n          _i56 && (_i56.borderRadius = l(t.radius, (_i56.r || 0) - (_i56.innerR || 0)));\n        }\n      } catch (err) {\n        _iterator25.e(err);\n      } finally {\n        _iterator25.f();\n      }\n    }\n    function x(t, e, i, s) {\n      var r = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n      var o = p(t, e, i, s, r),\n        _r$r2 = r.r,\n        n = _r$r2 === void 0 ? 0 : _r$r2,\n        _r$brBoxHeight = r.brBoxHeight,\n        a = _r$brBoxHeight === void 0 ? s : _r$brBoxHeight,\n        _r$brBoxY = r.brBoxY,\n        h = _r$brBoxY === void 0 ? e : _r$brBoxY,\n        l = e - h,\n        d = h + a - (e + s),\n        c = l - n > -.1 ? 0 : n,\n        u = d - n > -.1 ? 0 : n,\n        g = Math.max(c && l, 0),\n        f = Math.max(u && d, 0),\n        m = [t + c, e],\n        y = [t + i - c, e],\n        b = [t + i, e + c],\n        v = [t + i, e + s - u],\n        S = [t + i - u, e + s],\n        C = [t + u, e + s],\n        k = [t, e + s - u],\n        M = [t, e + c],\n        w = function w(t, e) {\n          return Math.sqrt(Math.pow(t, 2) - Math.pow(e, 2));\n        };\n      if (g) {\n        var _t96 = w(c, c - g);\n        m[0] -= _t96, y[0] += _t96, b[1] = M[1] = e + c - g;\n      }\n      if (s < c - g) {\n        var _r29 = w(c, c - g - s);\n        b[0] = v[0] = t + i - c + _r29, S[0] = Math.min(b[0], S[0]), C[0] = Math.max(v[0], C[0]), k[0] = M[0] = t + c - _r29, b[1] = M[1] = e + s;\n      }\n      if (f) {\n        var _t97 = w(u, u - f);\n        S[0] += _t97, C[0] -= _t97, v[1] = k[1] = e + s - u + f;\n      }\n      if (s < u - f) {\n        var _r30 = w(u, u - f - s);\n        b[0] = v[0] = t + i - u + _r30, y[0] = Math.min(b[0], y[0]), m[0] = Math.max(v[0], m[0]), k[0] = M[0] = t + u - _r30, v[1] = k[1] = e;\n      }\n      return o.length = 0, o.push([\"M\"].concat(m), [\"L\"].concat(y), [\"A\", c, c, 0, 0, 1].concat(b), [\"L\"].concat(v), [\"A\", u, u, 0, 0, 1].concat(S), [\"L\"].concat(C), [\"A\", u, u, 0, 0, 1].concat(k), [\"L\"].concat(M), [\"A\", c, c, 0, 0, 1].concat(m), [\"Z\"]), o;\n    }\n    return {\n      compose: function compose(t, e, i) {\n        var s = t.types.pie;\n        if (!e.symbolCustomAttribs.includes(\"borderRadius\")) {\n          var _r31 = i.prototype.symbols;\n          o(t, \"afterColumnTranslate\", g, {\n            order: 9\n          }), o(s, \"afterTranslate\", m), e.symbolCustomAttribs.push(\"borderRadius\", \"brBoxHeight\", \"brBoxY\"), c = _r31.arc, p = _r31.roundedRect, _r31.arc = u, _r31.roundedRect = x;\n        }\n      },\n      optionsToObject: f\n    };\n  }), i(e, \"Core/Responsive.js\", [e[\"Core/Utilities.js\"]], function (t) {\n    var e;\n    var i = t.diffObjects,\n      s = t.extend,\n      r = t.find,\n      o = t.merge,\n      n = t.pick,\n      a = t.uniqueKey;\n    return function (t) {\n      function e(t, e) {\n        var i = t.condition;\n        (i.callback || function () {\n          return this.chartWidth <= n(i.maxWidth, Number.MAX_VALUE) && this.chartHeight <= n(i.maxHeight, Number.MAX_VALUE) && this.chartWidth >= n(i.minWidth, 0) && this.chartHeight >= n(i.minHeight, 0);\n        }).call(this) && e.push(t._id);\n      }\n      function h(t, e) {\n        var _this27 = this;\n        var s = this.options.responsive,\n          n = this.currentResponsive,\n          h = [],\n          l;\n        !e && s && s.rules && s.rules.forEach(function (t) {\n          void 0 === t._id && (t._id = a()), _this27.matchResponsiveRule(t, h);\n        }, this);\n        var d = o.apply(void 0, _toConsumableArray(h.map(function (t) {\n          return r((s || {}).rules || [], function (e) {\n            return e._id === t;\n          });\n        }).map(function (t) {\n          return t && t.chartOptions;\n        })));\n        d.isResponsiveOptions = !0, h = h.toString() || void 0;\n        var c = n && n.ruleIds;\n        h === c || (n && (this.currentResponsive = void 0, this.updatingResponsive = !0, this.update(n.undoOptions, t, !0), this.updatingResponsive = !1), h ? ((l = i(d, this.options, !0, this.collectionsWithUpdate)).isResponsiveOptions = !0, this.currentResponsive = {\n          ruleIds: h,\n          mergedOptions: d,\n          undoOptions: l\n        }, this.updatingResponsive || this.update(d, t, !0)) : this.currentResponsive = void 0);\n      }\n      t.compose = function (t) {\n        var i = t.prototype;\n        return i.matchResponsiveRule || s(i, {\n          matchResponsiveRule: e,\n          setResponsive: h\n        }), t;\n      };\n    }(e || (e = {})), e;\n  }), i(e, \"masters/highcharts.src.js\", [e[\"Core/Globals.js\"], e[\"Core/Utilities.js\"], e[\"Core/Defaults.js\"], e[\"Core/Animation/Fx.js\"], e[\"Core/Animation/AnimationUtilities.js\"], e[\"Core/Renderer/HTML/AST.js\"], e[\"Core/Templating.js\"], e[\"Core/Renderer/RendererRegistry.js\"], e[\"Core/Renderer/RendererUtilities.js\"], e[\"Core/Renderer/SVG/SVGElement.js\"], e[\"Core/Renderer/SVG/SVGRenderer.js\"], e[\"Core/Renderer/HTML/HTMLElement.js\"], e[\"Core/Axis/Axis.js\"], e[\"Core/Axis/DateTimeAxis.js\"], e[\"Core/Axis/LogarithmicAxis.js\"], e[\"Core/Axis/PlotLineOrBand/PlotLineOrBand.js\"], e[\"Core/Axis/Tick.js\"], e[\"Core/Tooltip.js\"], e[\"Core/Series/Point.js\"], e[\"Core/Pointer.js\"], e[\"Core/Legend/Legend.js\"], e[\"Core/Legend/LegendSymbol.js\"], e[\"Core/Chart/Chart.js\"], e[\"Extensions/ScrollablePlotArea.js\"], e[\"Core/Axis/Stacking/StackingAxis.js\"], e[\"Core/Axis/Stacking/StackItem.js\"], e[\"Core/Series/Series.js\"], e[\"Core/Series/SeriesRegistry.js\"], e[\"Series/Column/ColumnDataLabel.js\"], e[\"Series/Pie/PieDataLabel.js\"], e[\"Core/Series/DataLabel.js\"], e[\"Extensions/OverlappingDataLabels.js\"], e[\"Extensions/BorderRadius.js\"], e[\"Core/Responsive.js\"], e[\"Core/Color/Color.js\"], e[\"Core/Time.js\"]], function (t, e, i, s, r, o, n, a, h, l, d, c, p, u, g, f, m, x, y, b, v, S, C, k, M, w, A, T, P, L, O, D, E, I, j, B) {\n    return t.AST = o, t.Axis = p, t.Chart = C, t.Color = j, t.DataLabel = O, t.Fx = s, t.HTMLElement = c, t.Legend = v, t.LegendSymbol = S, t.OverlappingDataLabels = t.OverlappingDataLabels || D, t.PlotLineOrBand = f, t.Point = y, t.Pointer = b, t.RendererRegistry = a, t.Series = A, t.SeriesRegistry = T, t.StackItem = w, t.SVGElement = l, t.SVGRenderer = d, t.Templating = n, t.Tick = m, t.Time = B, t.Tooltip = x, t.animate = r.animate, t.animObject = r.animObject, t.chart = C.chart, t.color = j.parse, t.dateFormat = n.dateFormat, t.defaultOptions = i.defaultOptions, t.distribute = h.distribute, t.format = n.format, t.getDeferredAnimation = r.getDeferredAnimation, t.getOptions = i.getOptions, t.numberFormat = n.numberFormat, t.seriesType = T.seriesType, t.setAnimation = r.setAnimation, t.setOptions = i.setOptions, t.stop = r.stop, t.time = i.defaultTime, t.timers = s.timers, E.compose(t.Series, t.SVGElement, t.SVGRenderer), P.compose(t.Series.types.column), O.compose(t.Series), u.compose(t.Axis), c.compose(t.SVGRenderer), v.compose(t.Chart), g.compose(t.Axis), D.compose(t.Chart), L.compose(t.Series.types.pie), f.compose(t.Axis), b.compose(t.Chart), I.compose(t.Chart), k.compose(t.Axis, t.Chart, t.Series), M.compose(t.Axis, t.Chart, t.Series), x.compose(t.Pointer), e.extend(t, e), t;\n  }), e[\"masters/highcharts.src.js\"]._modules = e, e[\"masters/highcharts.src.js\"];\n});\n\n//# sourceURL=webpack://medaxion-custom-visualizations/./node_modules/highcharts/highcharts.js?");

/***/ }),

/***/ "./node_modules/highcharts/modules/gantt.js":
/*!**************************************************!*\
  !*** ./node_modules/highcharts/modules/gantt.js ***!
  \**************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("/* module decorator */ module = __webpack_require__.nmd(module);\nvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _objectDestructuringEmpty(t) { if (null == t) throw new TypeError(\"Cannot destructure \" + t); }\nfunction _extends() { return _extends = Object.assign ? Object.assign.bind() : function (n) { for (var e = 1; e < arguments.length; e++) { var t = arguments[e]; for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]); } return n; }, _extends.apply(null, arguments); }\nfunction _createForOfIteratorHelper(r, e) { var t = \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && \"number\" == typeof r.length) { t && (r = t); var _n24 = 0, F = function F() {}; return { s: F, n: function n() { return _n24 >= r.length ? { done: !0 } : { done: !1, value: r[_n24++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t[\"return\"] || t[\"return\"](); } finally { if (u) throw o; } } }; }\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _iterableToArray(r) { if (\"undefined\" != typeof Symbol && null != r[Symbol.iterator] || null != r[\"@@iterator\"]) return Array.from(r); }\nfunction _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _superPropGet(t, e, r, o) { var p = _get(_getPrototypeOf(1 & o ? t.prototype : t), e, r); return 2 & o ? function (t) { return p.apply(r, t); } : p; }\nfunction _get() { return _get = \"undefined\" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function (e, t, r) { var p = _superPropBase(e, t); if (p) { var n = Object.getOwnPropertyDescriptor(p, t); return n.get ? n.get.call(arguments.length < 3 ? e : r) : n.value; } }, _get.apply(null, arguments); }\nfunction _superPropBase(t, o) { for (; !{}.hasOwnProperty.call(t, o) && null !== (t = _getPrototypeOf(t));); return t; }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\n!\n/**\n* Highcharts Gantt JS v11.4.7 (2024-08-14)\n*\n* Gantt series\n*\n* (c) 2016-2024 Lars A. V. Cabrera\n*\n* License: www.highcharts.com/license\n*/\nfunction (t) {\n  \"object\" == ( false ? 0 : _typeof(module)) && module.exports ? (t[\"default\"] = t, module.exports = t) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! highcharts */ \"./node_modules/highcharts/highcharts.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (e) {\n    return t(e), t.Highcharts = e, t;\n  }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : 0;\n}(function (t) {\n  \"use strict\";\n\n  var e = t ? t._modules : {};\n  function i(e, i, s, o) {\n    e.hasOwnProperty(i) || (e[i] = o.apply(null, s), \"function\" == typeof CustomEvent && t.win.dispatchEvent(new CustomEvent(\"HighchartsModuleLoaded\", {\n      detail: {\n        path: i,\n        module: e[i]\n      }\n    })));\n  }\n  i(e, \"Extensions/ArrowSymbols.js\", [], function () {\n    function t(t, e, i, s) {\n      return [[\"M\", t, e + s / 2], [\"L\", t + i, e], [\"L\", t, e + s / 2], [\"L\", t + i, e + s]];\n    }\n    function e(e, i, s, o) {\n      return t(e, i, s / 2, o);\n    }\n    function i(t, e, i, s) {\n      return [[\"M\", t + i, e], [\"L\", t, e + s / 2], [\"L\", t + i, e + s], [\"Z\"]];\n    }\n    function s(t, e, s, o) {\n      return i(t, e, s / 2, o);\n    }\n    return {\n      compose: function compose(o) {\n        var r = o.prototype.symbols;\n        r.arrow = t, r[\"arrow-filled\"] = i, r[\"arrow-filled-half\"] = s, r[\"arrow-half\"] = e, r[\"triangle-left\"] = i, r[\"triangle-left-half\"] = s;\n      }\n    };\n  }), i(e, \"Gantt/Connection.js\", [e[\"Core/Globals.js\"], e[\"Core/Utilities.js\"]], function (t, e) {\n    var i = e.defined,\n      s = e.error,\n      o = e.merge,\n      r = e.objectEach,\n      n = t.deg2rad,\n      a = Math.max,\n      l = Math.min;\n    return /*#__PURE__*/function () {\n      function _class(t, e, i) {\n        _classCallCheck(this, _class);\n        this.init(t, e, i);\n      }\n      return _createClass(_class, [{\n        key: \"init\",\n        value: function init(t, e, i) {\n          this.fromPoint = t, this.toPoint = e, this.options = i, this.chart = t.series.chart, this.pathfinder = this.chart.pathfinder;\n        }\n      }, {\n        key: \"renderPath\",\n        value: function renderPath(t, e) {\n          var i = this.chart,\n            s = i.styledMode,\n            o = this.pathfinder,\n            r = {},\n            n = this.graphics && this.graphics.path;\n          o.group || (o.group = i.renderer.g().addClass(\"highcharts-pathfinder-group\").attr({\n            zIndex: -1\n          }).add(i.seriesGroup)), o.group.translate(i.plotLeft, i.plotTop), n && n.renderer || (n = i.renderer.path().add(o.group), s || n.attr({\n            opacity: 0\n          })), n.attr(e), r.d = t, s || (r.opacity = 1), n.animate(r), this.graphics = this.graphics || {}, this.graphics.path = n;\n        }\n      }, {\n        key: \"addMarker\",\n        value: function addMarker(t, e, i) {\n          var s, o, r, a, l, h, d, c;\n          var p = this.fromPoint.series.chart,\n            u = p.pathfinder,\n            g = p.renderer,\n            x = \"start\" === t ? this.fromPoint : this.toPoint,\n            f = x.getPathfinderAnchorPoint(e);\n          e.enabled && ((c = \"start\" === t ? i[1] : i[i.length - 2]) && \"M\" === c[0] || \"L\" === c[0]) && (d = {\n            x: c[1],\n            y: c[2]\n          }, o = x.getRadiansToVector(d, f), s = x.getMarkerVector(o, e.radius, f), r = -o / n, e.width && e.height ? (l = e.width, h = e.height) : l = h = 2 * e.radius, this.graphics = this.graphics || {}, a = {\n            x: s.x - l / 2,\n            y: s.y - h / 2,\n            width: l,\n            height: h,\n            rotation: r,\n            rotationOriginX: s.x,\n            rotationOriginY: s.y\n          }, this.graphics[t] ? this.graphics[t].animate(a) : (this.graphics[t] = g.symbol(e.symbol).addClass(\"highcharts-point-connecting-path-\" + t + \"-marker highcharts-color-\" + this.fromPoint.colorIndex).attr(a).add(u.group), g.styledMode || this.graphics[t].attr({\n            fill: e.color || this.fromPoint.color,\n            stroke: e.lineColor,\n            \"stroke-width\": e.lineWidth,\n            opacity: 0\n          }).animate({\n            opacity: 1\n          }, x.series.options.animation)));\n        }\n      }, {\n        key: \"getPath\",\n        value: function getPath(t) {\n          var e = this.pathfinder,\n            i = this.chart,\n            r = e.algorithms[t.type],\n            n = e.chartObstacles;\n          return \"function\" != typeof r ? (s('\"' + t.type + '\" is not a Pathfinder algorithm.'), {\n            path: [],\n            obstacles: []\n          }) : (r.requiresObstacles && !n && (n = e.chartObstacles = e.getChartObstacles(t), i.options.connectors.algorithmMargin = t.algorithmMargin, e.chartObstacleMetrics = e.getObstacleMetrics(n)), r(this.fromPoint.getPathfinderAnchorPoint(t.startMarker), this.toPoint.getPathfinderAnchorPoint(t.endMarker), o({\n            chartObstacles: n,\n            lineObstacles: e.lineObstacles || [],\n            obstacleMetrics: e.chartObstacleMetrics,\n            hardBounds: {\n              xMin: 0,\n              xMax: i.plotWidth,\n              yMin: 0,\n              yMax: i.plotHeight\n            },\n            obstacleOptions: {\n              margin: t.algorithmMargin\n            },\n            startDirectionX: e.getAlgorithmStartDirection(t.startMarker)\n          }, t)));\n        }\n      }, {\n        key: \"render\",\n        value: function render() {\n          var t = this.fromPoint,\n            e = t.series,\n            s = e.chart,\n            r = s.pathfinder,\n            n = {},\n            h = o(s.options.connectors, e.options.connectors, t.options.connectors, this.options);\n          !s.styledMode && (n.stroke = h.lineColor || t.color, n[\"stroke-width\"] = h.lineWidth, h.dashStyle && (n.dashstyle = h.dashStyle)), n[\"class\"] = \"highcharts-point-connecting-path highcharts-color-\" + t.colorIndex, i((h = o(n, h)).marker.radius) || (h.marker.radius = l(a(Math.ceil((h.algorithmMargin || 8) / 2) - 1, 1), 5));\n          var d = this.getPath(h),\n            c = d.path;\n          d.obstacles && (r.lineObstacles = r.lineObstacles || [], r.lineObstacles = r.lineObstacles.concat(d.obstacles)), this.renderPath(c, n), this.addMarker(\"start\", o(h.marker, h.startMarker), c), this.addMarker(\"end\", o(h.marker, h.endMarker), c);\n        }\n      }, {\n        key: \"destroy\",\n        value: function destroy() {\n          this.graphics && (r(this.graphics, function (t) {\n            t.destroy();\n          }), delete this.graphics);\n        }\n      }]);\n    }();\n  }), i(e, \"Extensions/CurrentDateIndication.js\", [e[\"Core/Globals.js\"], e[\"Core/Utilities.js\"]], function (t, e) {\n    var i = t.composed,\n      s = e.addEvent,\n      o = e.merge,\n      r = e.pushUnique,\n      n = e.wrap,\n      a = {\n        color: \"#ccd3ff\",\n        width: 2,\n        label: {\n          format: \"%a, %b %d %Y, %H:%M\",\n          formatter: function formatter(t, e) {\n            return this.axis.chart.time.dateFormat(e || \"\", t);\n          },\n          rotation: 0,\n          style: {\n            fontSize: \"0.7em\"\n          }\n        }\n      };\n    function l() {\n      var t = this.options,\n        e = t.currentDateIndicator;\n      if (e) {\n        var _i = \"object\" == _typeof(e) ? o(a, e) : o(a);\n        _i.value = Date.now(), _i.className = \"highcharts-current-date-indicator\", t.plotLines || (t.plotLines = []), t.plotLines.push(_i);\n      }\n    }\n    function h() {\n      this.label && this.label.attr({\n        text: this.getLabelText(this.options.label)\n      });\n    }\n    function d(t, e) {\n      var i = this.options;\n      return i && i.className && -1 !== i.className.indexOf(\"highcharts-current-date-indicator\") && i.label && \"function\" == typeof i.label.formatter ? (i.value = Date.now(), i.label.formatter.call(this, i.value, i.label.format)) : t.call(this, e);\n    }\n    return {\n      compose: function compose(t, e) {\n        r(i, \"CurrentDateIndication\") && (s(t, \"afterSetOptions\", l), s(e, \"render\", h), n(e.prototype, \"getLabelText\", d));\n      }\n    };\n  }), i(e, \"Core/Chart/GanttChart.js\", [e[\"Core/Chart/Chart.js\"], e[\"Core/Defaults.js\"], e[\"Core/Utilities.js\"]], function (t, e, i) {\n    var s;\n    var o = e.defaultOptions,\n      r = i.isArray,\n      n = i.merge,\n      a = i.splat;\n    var l = /*#__PURE__*/function (_t) {\n      function l() {\n        _classCallCheck(this, l);\n        return _callSuper(this, l, arguments);\n      }\n      _inherits(l, _t);\n      return _createClass(l, [{\n        key: \"init\",\n        value: function init(t, e) {\n          var i;\n          var s = t.xAxis,\n            _l = t.yAxis;\n          t.xAxis = t.yAxis = void 0;\n          var h = n(!0, {\n            chart: {\n              type: \"gantt\"\n            },\n            title: {\n              text: \"\"\n            },\n            legend: {\n              enabled: !1\n            },\n            navigator: {\n              series: {\n                type: \"gantt\"\n              },\n              yAxis: {\n                type: \"category\"\n              }\n            }\n          }, t, {\n            isGantt: !0\n          });\n          t.xAxis = s, t.yAxis = _l, h.xAxis = (r(t.xAxis) ? t.xAxis : [t.xAxis || {}, {}]).map(function (t, e) {\n            var _ref, _o$xAxis$opposite, _o$xAxis;\n            return 1 === e && (i = 0), n({\n              grid: {\n                borderColor: \"#cccccc\",\n                enabled: !0\n              },\n              opposite: (_ref = (_o$xAxis$opposite = (_o$xAxis = o.xAxis) === null || _o$xAxis === void 0 ? void 0 : _o$xAxis.opposite) !== null && _o$xAxis$opposite !== void 0 ? _o$xAxis$opposite : t.opposite) !== null && _ref !== void 0 ? _ref : !0,\n              linkedTo: i\n            }, t, {\n              type: \"datetime\"\n            });\n          }), h.yAxis = a(t.yAxis || {}).map(function (t) {\n            return n({\n              grid: {\n                borderColor: \"#cccccc\",\n                enabled: !0\n              },\n              staticScale: 50,\n              reversed: !0,\n              type: t.categories ? t.type : \"treegrid\"\n            }, t);\n          }), _superPropGet(l, \"init\", this, 3)([h, e]);\n        }\n      }]);\n    }(t);\n    return (s = l || (l = {})).ganttChart = function (t, e, i) {\n      return new s(t, e, i);\n    }, l;\n  }), i(e, \"Stock/Navigator/ChartNavigatorComposition.js\", [e[\"Core/Globals.js\"], e[\"Core/Utilities.js\"]], function (t, e) {\n    var i;\n    var s = t.isTouchDevice,\n      o = e.addEvent,\n      r = e.merge,\n      n = e.pick,\n      a = [];\n    function l() {\n      this.navigator && this.navigator.setBaseSeries(null, !1);\n    }\n    function h() {\n      var t, e, i;\n      var s = this.legend,\n        o = this.navigator;\n      if (o) {\n        var _this$scrollbar;\n        t = s && s.options, e = o.xAxis, i = o.yAxis;\n        var _r = o.scrollbarHeight,\n          _a = o.scrollButtonSize;\n        this.inverted ? (o.left = o.opposite ? this.chartWidth - _r - o.height : this.spacing[3] + _r, o.top = this.plotTop + _a) : (o.left = n(e.left, this.plotLeft + _a), o.top = o.navigatorOptions.top || this.chartHeight - o.height - _r - (((_this$scrollbar = this.scrollbar) === null || _this$scrollbar === void 0 ? void 0 : _this$scrollbar.options.margin) || 0) - this.spacing[2] - (this.rangeSelector && this.extraBottomMargin ? this.rangeSelector.getHeight() : 0) - (t && \"bottom\" === t.verticalAlign && \"proximate\" !== t.layout && t.enabled && !t.floating ? s.legendHeight + n(t.margin, 10) : 0) - (this.titleOffset ? this.titleOffset[2] : 0)), e && i && (this.inverted ? e.options.left = i.options.left = o.left : e.options.top = i.options.top = o.top, e.setAxisSize(), i.setAxisSize());\n      }\n    }\n    function d(t) {\n      !this.navigator && !this.scroller && (this.options.navigator.enabled || this.options.scrollbar.enabled) && (this.scroller = this.navigator = new i(this), n(t.redraw, !0) && this.redraw(t.animation));\n    }\n    function c() {\n      var t = this.options;\n      (t.navigator.enabled || t.scrollbar.enabled) && (this.scroller = this.navigator = new i(this));\n    }\n    function p() {\n      var t = this.options,\n        e = t.navigator,\n        i = t.rangeSelector;\n      if ((e && e.enabled || i && i.enabled) && (!s && \"x\" === this.zooming.type || s && \"x\" === this.zooming.pinchType)) return !1;\n    }\n    function u(t) {\n      var e = t.navigator;\n      if (e && t.xAxis[0]) {\n        var _i2 = t.xAxis[0].getExtremes();\n        e.render(_i2.min, _i2.max);\n      }\n    }\n    function g(t) {\n      var e = t.options.navigator || {},\n        i = t.options.scrollbar || {};\n      !this.navigator && !this.scroller && (e.enabled || i.enabled) && (r(!0, this.options.navigator, e), r(!0, this.options.scrollbar, i), delete t.options.navigator, delete t.options.scrollbar);\n    }\n    return {\n      compose: function compose(t, s) {\n        if (e.pushUnique(a, t)) {\n          var _e = t.prototype;\n          i = s, _e.callbacks.push(u), o(t, \"afterAddSeries\", l), o(t, \"afterSetChartSize\", h), o(t, \"afterUpdate\", d), o(t, \"beforeRender\", c), o(t, \"beforeShowResetZoom\", p), o(t, \"update\", g);\n        }\n      }\n    };\n  }), i(e, \"Core/Axis/NavigatorAxisComposition.js\", [e[\"Core/Globals.js\"], e[\"Core/Utilities.js\"]], function (t, e) {\n    var i = t.isTouchDevice,\n      s = e.addEvent,\n      o = e.correctFloat,\n      r = e.defined,\n      n = e.isNumber,\n      a = e.pick;\n    function l() {\n      this.navigatorAxis || (this.navigatorAxis = new d(this));\n    }\n    function h(t) {\n      var e;\n      var s = this.chart,\n        o = s.options,\n        n = o.navigator,\n        a = this.navigatorAxis,\n        l = s.zooming.pinchType,\n        h = o.rangeSelector,\n        d = s.zooming.type;\n      if (this.isXAxis && (n !== null && n !== void 0 && n.enabled || h !== null && h !== void 0 && h.enabled)) {\n        if (\"y\" === d && \"zoom\" === t.trigger) e = !1;else if ((\"zoom\" === t.trigger && \"xy\" === d || i && \"xy\" === l) && this.options.range) {\n          var _e2 = a.previousZoom;\n          r(t.min) ? a.previousZoom = [this.min, this.max] : _e2 && (t.min = _e2[0], t.max = _e2[1], a.previousZoom = void 0);\n        }\n      }\n      void 0 !== e && t.preventDefault();\n    }\n    var d = /*#__PURE__*/function () {\n      function d(t) {\n        _classCallCheck(this, d);\n        this.axis = t;\n      }\n      return _createClass(d, [{\n        key: \"destroy\",\n        value: function destroy() {\n          this.axis = void 0;\n        }\n      }, {\n        key: \"toFixedRange\",\n        value: function toFixedRange(t, e, i, s) {\n          var l = this.axis,\n            h = (l.pointRange || 0) / 2,\n            _d = a(i, l.translate(t, !0, !l.horiz)),\n            c = a(s, l.translate(e, !0, !l.horiz));\n          return r(i) || (_d = o(_d + h)), r(s) || (c = o(c - h)), n(_d) && n(c) || (_d = c = void 0), {\n            min: _d,\n            max: c\n          };\n        }\n      }], [{\n        key: \"compose\",\n        value: function compose(t) {\n          t.keepProps.includes(\"navigatorAxis\") || (t.keepProps.push(\"navigatorAxis\"), s(t, \"init\", l), s(t, \"setExtremes\", h));\n        }\n      }]);\n    }();\n    return d;\n  }), i(e, \"Stock/Navigator/NavigatorDefaults.js\", [e[\"Core/Color/Color.js\"], e[\"Core/Series/SeriesRegistry.js\"]], function (t, e) {\n    var i = t.parse,\n      s = e.seriesTypes;\n    return {\n      height: 40,\n      margin: 25,\n      maskInside: !0,\n      handles: {\n        width: 7,\n        borderRadius: 0,\n        height: 15,\n        symbols: [\"navigator-handle\", \"navigator-handle\"],\n        enabled: !0,\n        lineWidth: 1,\n        backgroundColor: \"#f2f2f2\",\n        borderColor: \"#999999\"\n      },\n      maskFill: i(\"#667aff\").setOpacity(.3).get(),\n      outlineColor: \"#999999\",\n      outlineWidth: 1,\n      series: {\n        type: void 0 === s.areaspline ? \"line\" : \"areaspline\",\n        fillOpacity: .05,\n        lineWidth: 1,\n        compare: null,\n        sonification: {\n          enabled: !1\n        },\n        dataGrouping: {\n          approximation: \"average\",\n          enabled: !0,\n          groupPixelWidth: 2,\n          firstAnchor: \"firstPoint\",\n          anchor: \"middle\",\n          lastAnchor: \"lastPoint\",\n          units: [[\"millisecond\", [1, 2, 5, 10, 20, 25, 50, 100, 200, 500]], [\"second\", [1, 2, 5, 10, 15, 30]], [\"minute\", [1, 2, 5, 10, 15, 30]], [\"hour\", [1, 2, 3, 4, 6, 8, 12]], [\"day\", [1, 2, 3, 4]], [\"week\", [1, 2, 3]], [\"month\", [1, 3, 6]], [\"year\", null]]\n        },\n        dataLabels: {\n          enabled: !1,\n          zIndex: 2\n        },\n        id: \"highcharts-navigator-series\",\n        className: \"highcharts-navigator-series\",\n        lineColor: null,\n        marker: {\n          enabled: !1\n        },\n        threshold: null\n      },\n      xAxis: {\n        className: \"highcharts-navigator-xaxis\",\n        tickLength: 0,\n        lineWidth: 0,\n        gridLineColor: \"#e6e6e6\",\n        id: \"navigator-x-axis\",\n        gridLineWidth: 1,\n        tickPixelInterval: 200,\n        labels: {\n          align: \"left\",\n          style: {\n            color: \"#000000\",\n            fontSize: \"0.7em\",\n            opacity: .6,\n            textOutline: \"2px contrast\"\n          },\n          x: 3,\n          y: -4\n        },\n        crosshair: !1\n      },\n      yAxis: {\n        className: \"highcharts-navigator-yaxis\",\n        gridLineWidth: 0,\n        startOnTick: !1,\n        endOnTick: !1,\n        minPadding: .1,\n        id: \"navigator-y-axis\",\n        maxPadding: .1,\n        labels: {\n          enabled: !1\n        },\n        crosshair: !1,\n        title: {\n          text: null\n        },\n        tickLength: 0,\n        tickWidth: 0\n      }\n    };\n  }), i(e, \"Stock/Navigator/NavigatorSymbols.js\", [e[\"Core/Renderer/SVG/Symbols.js\"], e[\"Core/Utilities.js\"]], function (t, e) {\n    var i = e.relativeLength;\n    return {\n      \"navigator-handle\": function navigatorHandle(e, s, o, r) {\n        var n = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n        var a = n.width ? n.width / 2 : o,\n          l = i(n.borderRadius || 0, Math.min(2 * a, r));\n        return [[\"M\", -1.5, (r = n.height || r) / 2 - 3.5], [\"L\", -1.5, r / 2 + 4.5], [\"M\", .5, r / 2 - 3.5], [\"L\", .5, r / 2 + 4.5]].concat(_toConsumableArray(t.rect(-a - 1, .5, 2 * a + 1, r, {\n          r: l\n        })));\n      }\n    };\n  }), i(e, \"Stock/Utilities/StockUtilities.js\", [e[\"Core/Utilities.js\"]], function (t) {\n    var e = t.defined;\n    return {\n      setFixedRange: function setFixedRange(t) {\n        var i = this.xAxis[0];\n        e(i.dataMax) && e(i.dataMin) && t ? this.fixedRange = Math.min(t, i.dataMax - i.dataMin) : this.fixedRange = t;\n      }\n    };\n  }), i(e, \"Stock/Navigator/NavigatorComposition.js\", [e[\"Core/Defaults.js\"], e[\"Core/Globals.js\"], e[\"Core/Axis/NavigatorAxisComposition.js\"], e[\"Stock/Navigator/NavigatorDefaults.js\"], e[\"Stock/Navigator/NavigatorSymbols.js\"], e[\"Core/Renderer/RendererRegistry.js\"], e[\"Stock/Utilities/StockUtilities.js\"], e[\"Core/Utilities.js\"]], function (t, e, i, s, o, r, n, a) {\n    var l = t.setOptions,\n      h = e.composed,\n      d = r.getRendererType,\n      c = n.setFixedRange,\n      p = a.addEvent,\n      u = a.extend,\n      g = a.pushUnique;\n    function x() {\n      this.chart.navigator && !this.options.isInternal && this.chart.navigator.setBaseSeries(null, !1);\n    }\n    return {\n      compose: function compose(t, e, r) {\n        i.compose(e), g(h, \"Navigator\") && (t.prototype.setFixedRange = c, u(d().prototype.symbols, o), p(r, \"afterUpdate\", x), l({\n          navigator: s\n        }));\n      }\n    };\n  }), i(e, \"Core/Axis/ScrollbarAxis.js\", [e[\"Core/Globals.js\"], e[\"Core/Utilities.js\"]], function (t, e) {\n    var i;\n    var s = t.composed,\n      o = e.addEvent,\n      r = e.defined,\n      n = e.pick,\n      a = e.pushUnique;\n    return function (t) {\n      var e;\n      function i(t) {\n        var e = n(t.options && t.options.min, t.min),\n          i = n(t.options && t.options.max, t.max);\n        return {\n          axisMin: e,\n          axisMax: i,\n          scrollMin: r(t.dataMin) ? Math.min(e, t.min, t.dataMin, n(t.threshold, 1 / 0)) : e,\n          scrollMax: r(t.dataMax) ? Math.max(i, t.max, t.dataMax, n(t.threshold, -1 / 0)) : i\n        };\n      }\n      function l() {\n        var t = this.scrollbar,\n          e = t && !t.options.opposite,\n          i = this.horiz ? 2 : e ? 3 : 1;\n        t && (this.chart.scrollbarsOffsets = [0, 0], this.chart.axisOffset[i] += t.size + (t.options.margin || 0));\n      }\n      function h() {\n        var t = this;\n        t.options && t.options.scrollbar && t.options.scrollbar.enabled && (t.options.scrollbar.vertical = !t.horiz, t.options.startOnTick = t.options.endOnTick = !1, t.scrollbar = new e(t.chart.renderer, t.options.scrollbar, t.chart), o(t.scrollbar, \"changed\", function (e) {\n          var s, o;\n          var _i3 = i(t),\n            n = _i3.axisMin,\n            a = _i3.axisMax,\n            l = _i3.scrollMin,\n            h = _i3.scrollMax,\n            d = h - l;\n          if (r(n) && r(a)) {\n            if (t.horiz && !t.reversed || !t.horiz && t.reversed ? (s = l + d * this.to, o = l + d * this.from) : (s = l + d * (1 - this.from), o = l + d * (1 - this.to)), this.shouldUpdateExtremes(e.DOMType)) {\n              var _i4 = \"mousemove\" !== e.DOMType && \"touchmove\" !== e.DOMType && void 0;\n              t.setExtremes(o, s, !0, _i4, e);\n            } else this.setRange(this.from, this.to);\n          }\n        }));\n      }\n      function d() {\n        var t, e, s;\n        var _i5 = i(this),\n          o = _i5.scrollMin,\n          n = _i5.scrollMax,\n          a = this.scrollbar,\n          l = this.axisTitleMargin + (this.titleOffset || 0),\n          h = this.chart.scrollbarsOffsets,\n          d = this.options.margin || 0;\n        if (a && h) {\n          if (this.horiz) this.opposite || (h[1] += l), a.position(this.left, this.top + this.height + 2 + h[1] - (this.opposite ? d : 0), this.width, this.height), this.opposite || (h[1] += d), t = 1;else {\n            var _e3;\n            this.opposite && (h[0] += l), _e3 = a.options.opposite ? this.left + this.width + 2 + h[0] - (this.opposite ? 0 : d) : this.opposite ? 0 : d, a.position(_e3, this.top, this.width, this.height), this.opposite && (h[0] += d), t = 0;\n          }\n          h[t] += a.size + (a.options.margin || 0), isNaN(o) || isNaN(n) || !r(this.min) || !r(this.max) || this.min === this.max ? a.setRange(0, 1) : (e = (this.min - o) / (n - o), s = (this.max - o) / (n - o), this.horiz && !this.reversed || !this.horiz && this.reversed ? a.setRange(e, s) : a.setRange(1 - s, 1 - e));\n        }\n      }\n      t.compose = function (t, i) {\n        a(s, \"Axis.Scrollbar\") && (e = i, o(t, \"afterGetOffset\", l), o(t, \"afterInit\", h), o(t, \"afterRender\", d));\n      };\n    }(i || (i = {})), i;\n  }), i(e, \"Stock/Scrollbar/ScrollbarDefaults.js\", [], function () {\n    return {\n      height: 10,\n      barBorderRadius: 5,\n      buttonBorderRadius: 0,\n      buttonsEnabled: !1,\n      liveRedraw: void 0,\n      margin: void 0,\n      minWidth: 6,\n      opposite: !0,\n      step: .2,\n      zIndex: 3,\n      barBackgroundColor: \"#cccccc\",\n      barBorderWidth: 0,\n      barBorderColor: \"#cccccc\",\n      buttonArrowColor: \"#333333\",\n      buttonBackgroundColor: \"#e6e6e6\",\n      buttonBorderColor: \"#cccccc\",\n      buttonBorderWidth: 1,\n      rifleColor: \"none\",\n      trackBackgroundColor: \"rgba(255, 255, 255, 0.001)\",\n      trackBorderColor: \"#cccccc\",\n      trackBorderRadius: 5,\n      trackBorderWidth: 1\n    };\n  }), i(e, \"Stock/Scrollbar/Scrollbar.js\", [e[\"Core/Defaults.js\"], e[\"Core/Globals.js\"], e[\"Core/Axis/ScrollbarAxis.js\"], e[\"Stock/Scrollbar/ScrollbarDefaults.js\"], e[\"Core/Utilities.js\"]], function (t, e, i, s, o) {\n    var r = t.defaultOptions,\n      n = o.addEvent,\n      a = o.correctFloat,\n      l = o.crisp,\n      h = o.defined,\n      d = o.destroyObjectProperties,\n      c = o.fireEvent,\n      p = o.merge,\n      u = o.pick,\n      g = o.removeEvent;\n    var x = /*#__PURE__*/function () {\n      function x(t, e, i) {\n        _classCallCheck(this, x);\n        this._events = [], this.chartX = 0, this.chartY = 0, this.from = 0, this.scrollbarButtons = [], this.scrollbarLeft = 0, this.scrollbarStrokeWidth = 1, this.scrollbarTop = 0, this.size = 0, this.to = 0, this.trackBorderWidth = 1, this.x = 0, this.y = 0, this.init(t, e, i);\n      }\n      return _createClass(x, [{\n        key: \"addEvents\",\n        value: function addEvents() {\n          var t = this.options.inverted ? [1, 0] : [0, 1],\n            e = this.scrollbarButtons,\n            i = this.scrollbarGroup.element,\n            s = this.track.element,\n            o = this.mouseDownHandler.bind(this),\n            r = this.mouseMoveHandler.bind(this),\n            a = this.mouseUpHandler.bind(this),\n            l = [[e[t[0]].element, \"click\", this.buttonToMinClick.bind(this)], [e[t[1]].element, \"click\", this.buttonToMaxClick.bind(this)], [s, \"click\", this.trackClick.bind(this)], [i, \"mousedown\", o], [i.ownerDocument, \"mousemove\", r], [i.ownerDocument, \"mouseup\", a], [i, \"touchstart\", o], [i.ownerDocument, \"touchmove\", r], [i.ownerDocument, \"touchend\", a]];\n          l.forEach(function (t) {\n            n.apply(null, t);\n          }), this._events = l;\n        }\n      }, {\n        key: \"buttonToMaxClick\",\n        value: function buttonToMaxClick(t) {\n          var e = (this.to - this.from) * u(this.options.step, .2);\n          this.updatePosition(this.from + e, this.to + e), c(this, \"changed\", {\n            from: this.from,\n            to: this.to,\n            trigger: \"scrollbar\",\n            DOMEvent: t\n          });\n        }\n      }, {\n        key: \"buttonToMinClick\",\n        value: function buttonToMinClick(t) {\n          var e = a(this.to - this.from) * u(this.options.step, .2);\n          this.updatePosition(a(this.from - e), a(this.to - e)), c(this, \"changed\", {\n            from: this.from,\n            to: this.to,\n            trigger: \"scrollbar\",\n            DOMEvent: t\n          });\n        }\n      }, {\n        key: \"cursorToScrollbarPosition\",\n        value: function cursorToScrollbarPosition(t) {\n          var e = this.options,\n            i = e.minWidth > this.calculatedWidth ? e.minWidth : 0;\n          return {\n            chartX: (t.chartX - this.x - this.xOffset) / (this.barWidth - i),\n            chartY: (t.chartY - this.y - this.yOffset) / (this.barWidth - i)\n          };\n        }\n      }, {\n        key: \"destroy\",\n        value: function destroy() {\n          var t = this,\n            e = t.chart.scroller;\n          t.removeEvents(), [\"track\", \"scrollbarRifles\", \"scrollbar\", \"scrollbarGroup\", \"group\"].forEach(function (e) {\n            t[e] && t[e].destroy && (t[e] = t[e].destroy());\n          }), e && t === e.scrollbar && (e.scrollbar = null, d(e.scrollbarButtons));\n        }\n      }, {\n        key: \"drawScrollbarButton\",\n        value: function drawScrollbarButton(t) {\n          var e = this.renderer,\n            i = this.scrollbarButtons,\n            s = this.options,\n            o = this.size,\n            r = e.g().add(this.group);\n          if (i.push(r), s.buttonsEnabled) {\n            var _n = e.rect().addClass(\"highcharts-scrollbar-button\").add(r);\n            this.chart.styledMode || _n.attr({\n              stroke: s.buttonBorderColor,\n              \"stroke-width\": s.buttonBorderWidth,\n              fill: s.buttonBackgroundColor\n            }), _n.attr(_n.crisp({\n              x: -.5,\n              y: -.5,\n              width: o,\n              height: o,\n              r: s.buttonBorderRadius\n            }, _n.strokeWidth()));\n            var _a2 = e.path(x.swapXY([[\"M\", o / 2 + (t ? -1 : 1), o / 2 - 3], [\"L\", o / 2 + (t ? -1 : 1), o / 2 + 3], [\"L\", o / 2 + (t ? 2 : -2), o / 2]], s.vertical)).addClass(\"highcharts-scrollbar-arrow\").add(i[t]);\n            this.chart.styledMode || _a2.attr({\n              fill: s.buttonArrowColor\n            });\n          }\n        }\n      }, {\n        key: \"init\",\n        value: function init(t, e, i) {\n          this.scrollbarButtons = [], this.renderer = t, this.userOptions = e, this.options = p(s, r.scrollbar, e), this.options.margin = u(this.options.margin, 10), this.chart = i, this.size = u(this.options.size, this.options.height), e.enabled && (this.render(), this.addEvents());\n        }\n      }, {\n        key: \"mouseDownHandler\",\n        value: function mouseDownHandler(t) {\n          var _this$chart$pointer;\n          var e = ((_this$chart$pointer = this.chart.pointer) === null || _this$chart$pointer === void 0 ? void 0 : _this$chart$pointer.normalize(t)) || t,\n            i = this.cursorToScrollbarPosition(e);\n          this.chartX = i.chartX, this.chartY = i.chartY, this.initPositions = [this.from, this.to], this.grabbedCenter = !0;\n        }\n      }, {\n        key: \"mouseMoveHandler\",\n        value: function mouseMoveHandler(t) {\n          var _this$chart$pointer2;\n          var e;\n          var i = ((_this$chart$pointer2 = this.chart.pointer) === null || _this$chart$pointer2 === void 0 ? void 0 : _this$chart$pointer2.normalize(t)) || t,\n            s = this.options.vertical ? \"chartY\" : \"chartX\",\n            o = this.initPositions || [];\n          this.grabbedCenter && (!t.touches || 0 !== t.touches[0][s]) && (e = this.cursorToScrollbarPosition(i)[s] - this[s], this.hasDragged = !0, this.updatePosition(o[0] + e, o[1] + e), this.hasDragged && c(this, \"changed\", {\n            from: this.from,\n            to: this.to,\n            trigger: \"scrollbar\",\n            DOMType: t.type,\n            DOMEvent: t\n          }));\n        }\n      }, {\n        key: \"mouseUpHandler\",\n        value: function mouseUpHandler(t) {\n          this.hasDragged && c(this, \"changed\", {\n            from: this.from,\n            to: this.to,\n            trigger: \"scrollbar\",\n            DOMType: t.type,\n            DOMEvent: t\n          }), this.grabbedCenter = this.hasDragged = this.chartX = this.chartY = null;\n        }\n      }, {\n        key: \"position\",\n        value: function position(t, e, i, s) {\n          var _this$options = this.options,\n            o = _this$options.buttonsEnabled,\n            _this$options$margin = _this$options.margin,\n            r = _this$options$margin === void 0 ? 0 : _this$options$margin,\n            n = _this$options.vertical,\n            a = this.rendered ? \"animate\" : \"attr\",\n            l = s,\n            h = 0;\n          this.group.show(), this.x = t, this.y = e + this.trackBorderWidth, this.width = i, this.height = s, this.xOffset = l, this.yOffset = h, n ? (this.width = this.yOffset = i = h = this.size, this.xOffset = l = 0, this.yOffset = h = o ? this.size : 0, this.barWidth = s - (o ? 2 * i : 0), this.x = t += r) : (this.height = s = this.size, this.xOffset = l = o ? this.size : 0, this.barWidth = i - (o ? 2 * s : 0), this.y = this.y + r), this.group[a]({\n            translateX: t,\n            translateY: this.y\n          }), this.track[a]({\n            width: i,\n            height: s\n          }), this.scrollbarButtons[1][a]({\n            translateX: n ? 0 : i - l,\n            translateY: n ? s - h : 0\n          });\n        }\n      }, {\n        key: \"removeEvents\",\n        value: function removeEvents() {\n          this._events.forEach(function (t) {\n            g.apply(null, t);\n          }), this._events.length = 0;\n        }\n      }, {\n        key: \"render\",\n        value: function render() {\n          var t = this.renderer,\n            e = this.options,\n            i = this.size,\n            s = this.chart.styledMode,\n            o = t.g(\"scrollbar\").attr({\n              zIndex: e.zIndex\n            }).hide().add();\n          this.group = o, this.track = t.rect().addClass(\"highcharts-scrollbar-track\").attr({\n            r: e.trackBorderRadius || 0,\n            height: i,\n            width: i\n          }).add(o), s || this.track.attr({\n            fill: e.trackBackgroundColor,\n            stroke: e.trackBorderColor,\n            \"stroke-width\": e.trackBorderWidth\n          });\n          var r = this.trackBorderWidth = this.track.strokeWidth();\n          this.track.attr({\n            x: -l(0, r),\n            y: -l(0, r)\n          }), this.scrollbarGroup = t.g().add(o), this.scrollbar = t.rect().addClass(\"highcharts-scrollbar-thumb\").attr({\n            height: i - r,\n            width: i - r,\n            r: e.barBorderRadius || 0\n          }).add(this.scrollbarGroup), this.scrollbarRifles = t.path(x.swapXY([[\"M\", -3, i / 4], [\"L\", -3, 2 * i / 3], [\"M\", 0, i / 4], [\"L\", 0, 2 * i / 3], [\"M\", 3, i / 4], [\"L\", 3, 2 * i / 3]], e.vertical)).addClass(\"highcharts-scrollbar-rifles\").add(this.scrollbarGroup), s || (this.scrollbar.attr({\n            fill: e.barBackgroundColor,\n            stroke: e.barBorderColor,\n            \"stroke-width\": e.barBorderWidth\n          }), this.scrollbarRifles.attr({\n            stroke: e.rifleColor,\n            \"stroke-width\": 1\n          })), this.scrollbarStrokeWidth = this.scrollbar.strokeWidth(), this.scrollbarGroup.translate(-l(0, this.scrollbarStrokeWidth), -l(0, this.scrollbarStrokeWidth)), this.drawScrollbarButton(0), this.drawScrollbarButton(1);\n        }\n      }, {\n        key: \"setRange\",\n        value: function setRange(t, e) {\n          var i, s;\n          var o = this.options,\n            r = o.vertical,\n            n = o.minWidth,\n            l = this.barWidth,\n            d = !this.rendered || this.hasDragged || this.chart.navigator && this.chart.navigator.hasDragged ? \"attr\" : \"animate\";\n          if (!h(l)) return;\n          var c = l * Math.min(e, 1);\n          i = Math.ceil(l * (t = Math.max(t, 0))), this.calculatedWidth = s = a(c - i), s < n && (i = (l - n + s) * t, s = n);\n          var p = Math.floor(i + this.xOffset + this.yOffset),\n            u = s / 2 - .5;\n          this.from = t, this.to = e, r ? (this.scrollbarGroup[d]({\n            translateY: p\n          }), this.scrollbar[d]({\n            height: s\n          }), this.scrollbarRifles[d]({\n            translateY: u\n          }), this.scrollbarTop = p, this.scrollbarLeft = 0) : (this.scrollbarGroup[d]({\n            translateX: p\n          }), this.scrollbar[d]({\n            width: s\n          }), this.scrollbarRifles[d]({\n            translateX: u\n          }), this.scrollbarLeft = p, this.scrollbarTop = 0), s <= 12 ? this.scrollbarRifles.hide() : this.scrollbarRifles.show(), !1 === o.showFull && (t <= 0 && e >= 1 ? this.group.hide() : this.group.show()), this.rendered = !0;\n        }\n      }, {\n        key: \"shouldUpdateExtremes\",\n        value: function shouldUpdateExtremes(t) {\n          return u(this.options.liveRedraw, e.svg && !e.isTouchDevice && !this.chart.boosted) || \"mouseup\" === t || \"touchend\" === t || !h(t);\n        }\n      }, {\n        key: \"trackClick\",\n        value: function trackClick(t) {\n          var _this$chart$pointer3;\n          var e = ((_this$chart$pointer3 = this.chart.pointer) === null || _this$chart$pointer3 === void 0 ? void 0 : _this$chart$pointer3.normalize(t)) || t,\n            i = this.to - this.from,\n            s = this.y + this.scrollbarTop,\n            o = this.x + this.scrollbarLeft;\n          this.options.vertical && e.chartY > s || !this.options.vertical && e.chartX > o ? this.updatePosition(this.from + i, this.to + i) : this.updatePosition(this.from - i, this.to - i), c(this, \"changed\", {\n            from: this.from,\n            to: this.to,\n            trigger: \"scrollbar\",\n            DOMEvent: t\n          });\n        }\n      }, {\n        key: \"update\",\n        value: function update(t) {\n          this.destroy(), this.init(this.chart.renderer, p(!0, this.options, t), this.chart);\n        }\n      }, {\n        key: \"updatePosition\",\n        value: function updatePosition(t, e) {\n          e > 1 && (t = a(1 - a(e - t)), e = 1), t < 0 && (e = a(e - t), t = 0), this.from = t, this.to = e;\n        }\n      }], [{\n        key: \"compose\",\n        value: function compose(t) {\n          i.compose(t, x);\n        }\n      }, {\n        key: \"swapXY\",\n        value: function swapXY(t, e) {\n          return e && t.forEach(function (t) {\n            var e;\n            var i = t.length;\n            for (var _s = 0; _s < i; _s += 2) \"number\" == typeof (e = t[_s + 1]) && (t[_s + 1] = t[_s + 2], t[_s + 2] = e);\n          }), t;\n        }\n      }]);\n    }();\n    return x.defaultOptions = s, r.scrollbar = p(!0, x.defaultOptions, r.scrollbar), x;\n  }), i(e, \"Stock/Navigator/Navigator.js\", [e[\"Core/Axis/Axis.js\"], e[\"Stock/Navigator/ChartNavigatorComposition.js\"], e[\"Core/Defaults.js\"], e[\"Core/Globals.js\"], e[\"Core/Axis/NavigatorAxisComposition.js\"], e[\"Stock/Navigator/NavigatorComposition.js\"], e[\"Stock/Scrollbar/Scrollbar.js\"], e[\"Core/Renderer/SVG/SVGRenderer.js\"], e[\"Core/Utilities.js\"]], function (t, e, i, s, o, r, n, a, l) {\n    var h = i.defaultOptions,\n      d = s.isTouchDevice,\n      c = a.prototype.symbols,\n      p = l.addEvent,\n      u = l.clamp,\n      g = l.correctFloat,\n      x = l.defined,\n      f = l.destroyObjectProperties,\n      m = l.erase,\n      b = l.extend,\n      y = l.find,\n      v = l.fireEvent,\n      M = l.isArray,\n      k = l.isNumber,\n      A = l.merge,\n      S = l.pick,\n      C = l.removeEvent,\n      w = l.splat;\n    function P(t) {\n      for (var _len = arguments.length, e = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        e[_key - 1] = arguments[_key];\n      }\n      var i = [].filter.call(e, k);\n      if (i.length) return Math[t].apply(0, i);\n    }\n    var O = /*#__PURE__*/function () {\n      function O(t) {\n        _classCallCheck(this, O);\n        this.isDirty = !1, this.scrollbarHeight = 0, this.init(t);\n      }\n      return _createClass(O, [{\n        key: \"drawHandle\",\n        value: function drawHandle(t, e, i, s) {\n          var o = this.navigatorOptions.handles.height;\n          this.handles[e][s](i ? {\n            translateX: Math.round(this.left + this.height / 2),\n            translateY: Math.round(this.top + parseInt(t, 10) + .5 - o)\n          } : {\n            translateX: Math.round(this.left + parseInt(t, 10)),\n            translateY: Math.round(this.top + this.height / 2 - o / 2 - 1)\n          });\n        }\n      }, {\n        key: \"drawOutline\",\n        value: function drawOutline(t, e, i, s) {\n          var o = this.navigatorOptions.maskInside,\n            r = this.outline.strokeWidth(),\n            n = r / 2,\n            a = r % 2 / 2,\n            l = this.scrollButtonSize,\n            h = this.size,\n            d = this.top,\n            c = this.height,\n            p = d - n,\n            u = d + c,\n            g = this.left,\n            x,\n            f;\n          i ? (x = d + e + a, e = d + t + a, f = [[\"M\", g + c, d - l - a], [\"L\", g + c, x], [\"L\", g, x], [\"M\", g, e], [\"L\", g + c, e], [\"L\", g + c, d + h + l]], o && f.push([\"M\", g + c, x - n], [\"L\", g + c, e + n])) : (g -= l, t += g + l - a, e += g + l - a, f = [[\"M\", g, p], [\"L\", t, p], [\"L\", t, u], [\"M\", e, u], [\"L\", e, p], [\"L\", g + h + 2 * l, p]], o && f.push([\"M\", t - n, p], [\"L\", e + n, p])), this.outline[s]({\n            d: f\n          });\n        }\n      }, {\n        key: \"drawMasks\",\n        value: function drawMasks(t, e, i, s) {\n          var o, r, n, a;\n          var l = this.left,\n            h = this.top,\n            d = this.height;\n          i ? (n = [l, l, l], a = [h, h + t, h + e], r = [d, d, d], o = [t, e - t, this.size - e]) : (n = [l, l + t, l + e], a = [h, h, h], r = [t, e - t, this.size - e], o = [d, d, d]), this.shades.forEach(function (t, e) {\n            t[s]({\n              x: n[e],\n              y: a[e],\n              width: r[e],\n              height: o[e]\n            });\n          });\n        }\n      }, {\n        key: \"renderElements\",\n        value: function renderElements() {\n          var _t$navigatorGroup, _e$handles;\n          var t = this,\n            e = t.navigatorOptions,\n            i = e.maskInside,\n            s = t.chart,\n            o = s.inverted,\n            r = s.renderer,\n            n = {\n              cursor: o ? \"ns-resize\" : \"ew-resize\"\n            },\n            a = (_t$navigatorGroup = t.navigatorGroup) !== null && _t$navigatorGroup !== void 0 ? _t$navigatorGroup : t.navigatorGroup = r.g(\"navigator\").attr({\n              zIndex: 8,\n              visibility: \"hidden\"\n            }).add();\n          if ([!i, i, !i].forEach(function (i, o) {\n            var _t$shades$o;\n            var l = (_t$shades$o = t.shades[o]) !== null && _t$shades$o !== void 0 ? _t$shades$o : t.shades[o] = r.rect().addClass(\"highcharts-navigator-mask\" + (1 === o ? \"-inside\" : \"-outside\")).add(a);\n            s.styledMode || (l.attr({\n              fill: i ? e.maskFill : \"rgba(0,0,0,0)\"\n            }), 1 === o && l.css(n));\n          }), t.outline || (t.outline = r.path().addClass(\"highcharts-navigator-outline\").add(a)), s.styledMode || t.outline.attr({\n            \"stroke-width\": e.outlineWidth,\n            stroke: e.outlineColor\n          }), (_e$handles = e.handles) !== null && _e$handles !== void 0 && _e$handles.enabled) {\n            var _i6 = e.handles,\n              _o = _i6.height,\n              _l2 = _i6.width;\n            [0, 1].forEach(function (e) {\n              var h = _i6.symbols[e];\n              if (t.handles[e]) {\n                if (h !== t.handles[e].symbolName) {\n                  var _i7 = c[h].call(c, -_l2 / 2 - 1, 0, _l2, _o);\n                  t.handles[e].attr({\n                    d: _i7\n                  }), t.handles[e].symbolName = h;\n                }\n              } else t.handles[e] = r.symbol(h, -_l2 / 2 - 1, 0, _l2, _o, _i6), t.handles[e].attr({\n                zIndex: 7 - e\n              }).addClass(\"highcharts-navigator-handle highcharts-navigator-handle-\" + [\"left\", \"right\"][e]).add(a);\n              s.inverted && t.handles[e].attr({\n                rotation: 90,\n                rotationOriginX: Math.floor(-_l2 / 2),\n                rotationOriginY: (_o + _l2) / 2\n              }), s.styledMode || t.handles[e].attr({\n                fill: _i6.backgroundColor,\n                stroke: _i6.borderColor,\n                \"stroke-width\": _i6.lineWidth,\n                width: _i6.width,\n                height: _i6.height,\n                x: -_l2 / 2 - 1,\n                y: 0\n              }).css(n);\n            });\n          }\n        }\n      }, {\n        key: \"update\",\n        value: function update(t) {\n          var _i$scrollbar,\n            _this = this;\n          var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !1;\n          var i = this.chart,\n            s = i.options.chart.inverted !== ((_i$scrollbar = i.scrollbar) === null || _i$scrollbar === void 0 ? void 0 : _i$scrollbar.options.vertical);\n          if (A(!0, i.options.navigator, t), this.navigatorOptions = i.options.navigator || {}, this.setOpposite(), x(t.enabled) || s) return this.destroy(), this.navigatorEnabled = t.enabled || this.navigatorEnabled, this.init(i);\n          if (this.navigatorEnabled && (this.isDirty = !0, !1 === t.adaptToUpdatedData && this.baseSeries.forEach(function (t) {\n            C(t, \"updatedData\", _this.updatedDataHandler);\n          }, this), t.adaptToUpdatedData && this.baseSeries.forEach(function (t) {\n            t.eventsToUnbind.push(p(t, \"updatedData\", _this.updatedDataHandler));\n          }, this), (t.series || t.baseSeries) && this.setBaseSeries(void 0, !1), t.height || t.xAxis || t.yAxis)) {\n            var _t$height;\n            this.height = (_t$height = t.height) !== null && _t$height !== void 0 ? _t$height : this.height;\n            var _e4 = this.getXAxisOffsets();\n            this.xAxis.update(_objectSpread(_objectSpread({}, t.xAxis), {}, _defineProperty(_defineProperty({\n              offsets: _e4\n            }, i.inverted ? \"width\" : \"height\", this.height), i.inverted ? \"height\" : \"width\", void 0)), !1), this.yAxis.update(_objectSpread(_objectSpread({}, t.yAxis), {}, _defineProperty({}, i.inverted ? \"width\" : \"height\", this.height)), !1);\n          }\n          e && i.redraw();\n        }\n      }, {\n        key: \"render\",\n        value: function render(t, e, i, s) {\n          var o = this.chart,\n            r = this.xAxis,\n            n = r.pointRange || 0,\n            a = r.navigatorAxis.fake ? o.xAxis[0] : r,\n            l = this.navigatorEnabled,\n            h = this.rendered,\n            d = o.inverted,\n            c = o.xAxis[0].minRange,\n            p = o.xAxis[0].options.maxRange,\n            f = this.scrollButtonSize,\n            m,\n            b,\n            y,\n            M = this.scrollbarHeight,\n            A,\n            C;\n          if (this.hasDragged && !x(i)) return;\n          if (this.isDirty && this.renderElements(), t = g(t - n / 2), e = g(e + n / 2), !k(t) || !k(e)) {\n            if (!h) return;\n            i = 0, s = S(r.width, a.width);\n          }\n          this.left = S(r.left, o.plotLeft + f + (d ? o.plotWidth : 0));\n          var w = this.size = A = S(r.len, (d ? o.plotHeight : o.plotWidth) - 2 * f);\n          m = d ? M : A + 2 * f, i = S(i, r.toPixels(t, !0)), s = S(s, r.toPixels(e, !0)), k(i) && Math.abs(i) !== 1 / 0 || (i = 0, s = m);\n          var P = r.toValue(i, !0),\n            _O = r.toValue(s, !0),\n            B = Math.abs(g(_O - P));\n          B < c ? this.grabbedLeft ? i = r.toPixels(_O - c - n, !0) : this.grabbedRight && (s = r.toPixels(P + c + n, !0)) : x(p) && g(B - n) > p && (this.grabbedLeft ? i = r.toPixels(_O - p - n, !0) : this.grabbedRight && (s = r.toPixels(P + p + n, !0))), this.zoomedMax = u(Math.max(i, s), 0, w), this.zoomedMin = u(this.fixedWidth ? this.zoomedMax - this.fixedWidth : Math.min(i, s), 0, w), this.range = this.zoomedMax - this.zoomedMin, w = Math.round(this.zoomedMax);\n          var E = Math.round(this.zoomedMin);\n          l && (this.navigatorGroup.attr({\n            visibility: \"inherit\"\n          }), C = h && !this.hasDragged ? \"animate\" : \"attr\", this.drawMasks(E, w, d, C), this.drawOutline(E, w, d, C), this.navigatorOptions.handles.enabled && (this.drawHandle(E, 0, d, C), this.drawHandle(w, 1, d, C))), this.scrollbar && (d ? (y = this.top - f, b = this.left - M + (l || !a.opposite ? 0 : (a.titleOffset || 0) + a.axisTitleMargin), M = A + 2 * f) : (y = this.top + (l ? this.height : -M), b = this.left - f), this.scrollbar.position(b, y, m, M), this.scrollbar.setRange(this.zoomedMin / (A || 1), this.zoomedMax / (A || 1))), this.rendered = !0, this.isDirty = !1, v(this, \"afterRender\");\n        }\n      }, {\n        key: \"addMouseEvents\",\n        value: function addMouseEvents() {\n          var t = this,\n            e = t.chart,\n            i = e.container,\n            s = [],\n            o,\n            r;\n          t.mouseMoveHandler = o = function o(e) {\n            t.onMouseMove(e);\n          }, t.mouseUpHandler = r = function r(e) {\n            t.onMouseUp(e);\n          }, (s = t.getPartsEvents(\"mousedown\")).push(p(e.renderTo, \"mousemove\", o), p(i.ownerDocument, \"mouseup\", r), p(e.renderTo, \"touchmove\", o), p(i.ownerDocument, \"touchend\", r)), s.concat(t.getPartsEvents(\"touchstart\")), t.eventsToUnbind = s, t.series && t.series[0] && s.push(p(t.series[0].xAxis, \"foundExtremes\", function () {\n            e.navigator.modifyNavigatorAxisExtremes();\n          }));\n        }\n      }, {\n        key: \"getPartsEvents\",\n        value: function getPartsEvents(t) {\n          var e = this,\n            i = [];\n          return [\"shades\", \"handles\"].forEach(function (s) {\n            e[s].forEach(function (o, r) {\n              i.push(p(o.element, t, function (t) {\n                e[s + \"Mousedown\"](t, r);\n              }));\n            });\n          }), i;\n        }\n      }, {\n        key: \"shadesMousedown\",\n        value: function shadesMousedown(t, e) {\n          var _this$chart$pointer4;\n          t = ((_this$chart$pointer4 = this.chart.pointer) === null || _this$chart$pointer4 === void 0 ? void 0 : _this$chart$pointer4.normalize(t)) || t;\n          var i = this.chart,\n            s = this.xAxis,\n            o = this.zoomedMin,\n            r = this.size,\n            n = this.range,\n            a = this.left,\n            l = t.chartX,\n            h,\n            d,\n            c,\n            p;\n          i.inverted && (l = t.chartY, a = this.top), 1 === e ? (this.grabbedCenter = l, this.fixedWidth = n, this.dragOffset = l - o) : (p = l - a - n / 2, 0 === e ? p = Math.max(0, p) : 2 === e && p + n >= r && (p = r - n, this.reversedExtremes ? (p -= n, d = this.getUnionExtremes().dataMin) : h = this.getUnionExtremes().dataMax), p !== o && (this.fixedWidth = n, x((c = s.navigatorAxis.toFixedRange(p, p + n, d, h)).min) && v(this, \"setRange\", {\n            min: Math.min(c.min, c.max),\n            max: Math.max(c.min, c.max),\n            redraw: !0,\n            eventArguments: {\n              trigger: \"navigator\"\n            }\n          })));\n        }\n      }, {\n        key: \"handlesMousedown\",\n        value: function handlesMousedown(t, e) {\n          var _this$chart$pointer5;\n          t = ((_this$chart$pointer5 = this.chart.pointer) === null || _this$chart$pointer5 === void 0 ? void 0 : _this$chart$pointer5.normalize(t)) || t;\n          var i = this.chart,\n            s = i.xAxis[0],\n            o = this.reversedExtremes;\n          0 === e ? (this.grabbedLeft = !0, this.otherHandlePos = this.zoomedMax, this.fixedExtreme = o ? s.min : s.max) : (this.grabbedRight = !0, this.otherHandlePos = this.zoomedMin, this.fixedExtreme = o ? s.max : s.min), i.setFixedRange(void 0);\n        }\n      }, {\n        key: \"onMouseMove\",\n        value: function onMouseMove(t) {\n          var _i$pointer;\n          var e = this,\n            i = e.chart,\n            s = e.navigatorSize,\n            o = e.range,\n            r = e.dragOffset,\n            n = i.inverted,\n            a = e.left,\n            l;\n          (!t.touches || 0 !== t.touches[0].pageX) && (l = (t = ((_i$pointer = i.pointer) === null || _i$pointer === void 0 ? void 0 : _i$pointer.normalize(t)) || t).chartX, n && (a = e.top, l = t.chartY), e.grabbedLeft ? (e.hasDragged = !0, e.render(0, 0, l - a, e.otherHandlePos)) : e.grabbedRight ? (e.hasDragged = !0, e.render(0, 0, e.otherHandlePos, l - a)) : e.grabbedCenter && (e.hasDragged = !0, l < r ? l = r : l > s + r - o && (l = s + r - o), e.render(0, 0, l - r, l - r + o)), e.hasDragged && e.scrollbar && S(e.scrollbar.options.liveRedraw, !d && !this.chart.boosted) && (t.DOMType = t.type, setTimeout(function () {\n            e.onMouseUp(t);\n          }, 0)));\n        }\n      }, {\n        key: \"onMouseUp\",\n        value: function onMouseUp(t) {\n          var e, i, s, o, r, n;\n          var a = this.chart,\n            l = this.xAxis,\n            h = this.scrollbar,\n            d = t.DOMEvent || t,\n            c = a.inverted,\n            p = this.rendered && !this.hasDragged ? \"animate\" : \"attr\";\n          (this.hasDragged && (!h || !h.hasDragged) || \"scrollbar\" === t.trigger) && (s = this.getUnionExtremes(), this.zoomedMin === this.otherHandlePos ? o = this.fixedExtreme : this.zoomedMax === this.otherHandlePos && (r = this.fixedExtreme), this.zoomedMax === this.size && (r = this.reversedExtremes ? s.dataMin : s.dataMax), 0 === this.zoomedMin && (o = this.reversedExtremes ? s.dataMax : s.dataMin), x((n = l.navigatorAxis.toFixedRange(this.zoomedMin, this.zoomedMax, o, r)).min) && v(this, \"setRange\", {\n            min: Math.min(n.min, n.max),\n            max: Math.max(n.min, n.max),\n            redraw: !0,\n            animation: !this.hasDragged && null,\n            eventArguments: {\n              trigger: \"navigator\",\n              triggerOp: \"navigator-drag\",\n              DOMEvent: d\n            }\n          })), \"mousemove\" !== t.DOMType && \"touchmove\" !== t.DOMType && (this.grabbedLeft = this.grabbedRight = this.grabbedCenter = this.fixedWidth = this.fixedExtreme = this.otherHandlePos = this.hasDragged = this.dragOffset = null), this.navigatorEnabled && k(this.zoomedMin) && k(this.zoomedMax) && (i = Math.round(this.zoomedMin), e = Math.round(this.zoomedMax), this.shades && this.drawMasks(i, e, c, p), this.outline && this.drawOutline(i, e, c, p), this.navigatorOptions.handles.enabled && Object.keys(this.handles).length === this.handles.length && (this.drawHandle(i, 0, c, p), this.drawHandle(e, 1, c, p)));\n        }\n      }, {\n        key: \"removeEvents\",\n        value: function removeEvents() {\n          this.eventsToUnbind && (this.eventsToUnbind.forEach(function (t) {\n            t();\n          }), this.eventsToUnbind = void 0), this.removeBaseSeriesEvents();\n        }\n      }, {\n        key: \"removeBaseSeriesEvents\",\n        value: function removeBaseSeriesEvents() {\n          var t = this.baseSeries || [];\n          this.navigatorEnabled && t[0] && (!1 !== this.navigatorOptions.adaptToUpdatedData && t.forEach(function (t) {\n            C(t, \"updatedData\", this.updatedDataHandler);\n          }, this), t[0].xAxis && C(t[0].xAxis, \"foundExtremes\", this.modifyBaseAxisExtremes));\n        }\n      }, {\n        key: \"getXAxisOffsets\",\n        value: function getXAxisOffsets() {\n          return this.chart.inverted ? [this.scrollButtonSize, 0, -this.scrollButtonSize, 0] : [0, -this.scrollButtonSize, 0, this.scrollButtonSize];\n        }\n      }, {\n        key: \"init\",\n        value: function init(e) {\n          var i = e.options,\n            s = i.navigator || {},\n            r = s.enabled,\n            a = i.scrollbar || {},\n            l = a.enabled,\n            h = r && s.height || 0,\n            d = l && a.height || 0,\n            c = a.buttonsEnabled && d || 0;\n          this.handles = [], this.shades = [], this.chart = e, this.setBaseSeries(), this.height = h, this.scrollbarHeight = d, this.scrollButtonSize = c, this.scrollbarEnabled = l, this.navigatorEnabled = r, this.navigatorOptions = s, this.scrollbarOptions = a, this.setOpposite();\n          var u = this,\n            g = u.baseSeries,\n            x = e.xAxis.length,\n            f = e.yAxis.length,\n            m = g && g[0] && g[0].xAxis || e.xAxis[0] || {\n              options: {}\n            };\n          if (e.isDirtyBox = !0, u.navigatorEnabled) {\n            var _s$yAxis;\n            var _i8 = this.getXAxisOffsets();\n            u.xAxis = new t(e, A({\n              breaks: m.options.breaks,\n              ordinal: m.options.ordinal,\n              overscroll: m.options.overscroll\n            }, s.xAxis, {\n              type: \"datetime\",\n              yAxis: (_s$yAxis = s.yAxis) === null || _s$yAxis === void 0 ? void 0 : _s$yAxis.id,\n              index: x,\n              isInternal: !0,\n              offset: 0,\n              keepOrdinalPadding: !0,\n              startOnTick: !1,\n              endOnTick: !1,\n              minPadding: m.options.ordinal ? 0 : m.options.minPadding,\n              maxPadding: m.options.ordinal ? 0 : m.options.maxPadding,\n              zoomEnabled: !1\n            }, e.inverted ? {\n              offsets: _i8,\n              width: h\n            } : {\n              offsets: _i8,\n              height: h\n            }), \"xAxis\"), u.yAxis = new t(e, A(s.yAxis, {\n              alignTicks: !1,\n              offset: 0,\n              index: f,\n              isInternal: !0,\n              reversed: S(s.yAxis && s.yAxis.reversed, e.yAxis[0] && e.yAxis[0].reversed, !1),\n              zoomEnabled: !1\n            }, e.inverted ? {\n              width: h\n            } : {\n              height: h\n            }), \"yAxis\"), g || s.series.data ? u.updateNavigatorSeries(!1) : 0 === e.series.length && (u.unbindRedraw = p(e, \"beforeRedraw\", function () {\n              e.series.length > 0 && !u.series && (u.setBaseSeries(), u.unbindRedraw());\n            })), u.reversedExtremes = e.inverted && !u.xAxis.reversed || !e.inverted && u.xAxis.reversed, u.renderElements(), u.addMouseEvents();\n          } else u.xAxis = {\n            chart: e,\n            navigatorAxis: {\n              fake: !0\n            },\n            translate: function translate(t, i) {\n              var s = e.xAxis[0],\n                o = s.getExtremes(),\n                r = s.len - 2 * c,\n                n = P(\"min\", s.options.min, o.dataMin),\n                a = P(\"max\", s.options.max, o.dataMax) - n;\n              return i ? t * a / r + n : r * (t - n) / a;\n            },\n            toPixels: function toPixels(t) {\n              return this.translate(t);\n            },\n            toValue: function toValue(t) {\n              return this.translate(t, !0);\n            }\n          }, u.xAxis.navigatorAxis.axis = u.xAxis, u.xAxis.navigatorAxis.toFixedRange = o.prototype.toFixedRange.bind(u.xAxis.navigatorAxis);\n          if (e.options.scrollbar.enabled) {\n            var _t2 = A(e.options.scrollbar, {\n              vertical: e.inverted\n            });\n            !k(_t2.margin) && u.navigatorEnabled && (_t2.margin = e.inverted ? -3 : 3), e.scrollbar = u.scrollbar = new n(e.renderer, _t2, e), p(u.scrollbar, \"changed\", function (t) {\n              var e = u.size,\n                i = e * this.to,\n                s = e * this.from;\n              u.hasDragged = u.scrollbar.hasDragged, u.render(0, 0, s, i), this.shouldUpdateExtremes(t.DOMType) && setTimeout(function () {\n                u.onMouseUp(t);\n              });\n            });\n          }\n          u.addBaseSeriesEvents(), u.addChartEvents();\n        }\n      }, {\n        key: \"setOpposite\",\n        value: function setOpposite() {\n          var t = this.navigatorOptions,\n            e = this.navigatorEnabled,\n            i = this.chart;\n          this.opposite = S(t.opposite, !!(!e && i.inverted));\n        }\n      }, {\n        key: \"getUnionExtremes\",\n        value: function getUnionExtremes(t) {\n          var e;\n          var i = this.chart.xAxis[0],\n            s = this.xAxis,\n            o = s.options,\n            r = i.options;\n          return t && null === i.dataMin || (e = {\n            dataMin: S(o && o.min, P(\"min\", r.min, i.dataMin, s.dataMin, s.min)),\n            dataMax: S(o && o.max, P(\"max\", r.max, i.dataMax, s.dataMax, s.max))\n          }), e;\n        }\n      }, {\n        key: \"setBaseSeries\",\n        value: function setBaseSeries(t, e) {\n          var i = this.chart,\n            s = this.baseSeries = [];\n          t = t || i.options && i.options.navigator.baseSeries || (i.series.length ? y(i.series, function (t) {\n            return !t.options.isInternal;\n          }).index : 0), (i.series || []).forEach(function (e, i) {\n            !e.options.isInternal && (e.options.showInNavigator || (i === t || e.options.id === t) && !1 !== e.options.showInNavigator) && s.push(e);\n          }), this.xAxis && !this.xAxis.navigatorAxis.fake && this.updateNavigatorSeries(!0, e);\n        }\n      }, {\n        key: \"updateNavigatorSeries\",\n        value: function updateNavigatorSeries(t, e) {\n          var _this$navigatorOption, _this$navigatorOption2;\n          var i = this,\n            s = i.chart,\n            o = i.baseSeries,\n            r = {\n              enableMouseTracking: !1,\n              index: null,\n              linkedTo: null,\n              group: \"nav\",\n              padXAxis: !1,\n              xAxis: (_this$navigatorOption = this.navigatorOptions.xAxis) === null || _this$navigatorOption === void 0 ? void 0 : _this$navigatorOption.id,\n              yAxis: (_this$navigatorOption2 = this.navigatorOptions.yAxis) === null || _this$navigatorOption2 === void 0 ? void 0 : _this$navigatorOption2.id,\n              showInLegend: !1,\n              stacking: void 0,\n              isInternal: !0,\n              states: {\n                inactive: {\n                  opacity: 1\n                }\n              }\n            },\n            n = i.series = (i.series || []).filter(function (t) {\n              var e = t.baseSeries;\n              return !(0 > o.indexOf(e)) || (e && (C(e, \"updatedData\", i.updatedDataHandler), delete e.navigatorSeries), t.chart && t.destroy(), !1);\n            }),\n            a,\n            l,\n            d = i.navigatorOptions.series,\n            c;\n          o && o.length && o.forEach(function (t) {\n            var p = t.navigatorSeries,\n              u = b({\n                color: t.color,\n                visible: t.visible\n              }, M(d) ? h.navigator.series : d);\n            if (p && !1 === i.navigatorOptions.adaptToUpdatedData) return;\n            r.name = \"Navigator \" + o.length, c = (a = t.options || {}).navigatorOptions || {}, u.dataLabels = w(u.dataLabels), (l = A(a, r, u, c)).pointRange = S(u.pointRange, c.pointRange, h.plotOptions[l.type || \"line\"].pointRange);\n            var g = c.data || u.data;\n            i.hasNavigatorData = i.hasNavigatorData || !!g, l.data = g || a.data && a.data.slice(0), p && p.options ? p.update(l, e) : (t.navigatorSeries = s.initSeries(l), s.setSortedData(), t.navigatorSeries.baseSeries = t, n.push(t.navigatorSeries));\n          }), (d.data && !(o && o.length) || M(d)) && (i.hasNavigatorData = !1, (d = w(d)).forEach(function (t, e) {\n            r.name = \"Navigator \" + (n.length + 1), (l = A(h.navigator.series, {\n              color: s.series[e] && !s.series[e].options.isInternal && s.series[e].color || s.options.colors[e] || s.options.colors[0]\n            }, r, t)).data = t.data, l.data && (i.hasNavigatorData = !0, n.push(s.initSeries(l)));\n          })), t && this.addBaseSeriesEvents();\n        }\n      }, {\n        key: \"addBaseSeriesEvents\",\n        value: function addBaseSeriesEvents() {\n          var _this2 = this;\n          var t = this,\n            e = t.baseSeries || [];\n          e[0] && e[0].xAxis && e[0].eventsToUnbind.push(p(e[0].xAxis, \"foundExtremes\", this.modifyBaseAxisExtremes)), e.forEach(function (i) {\n            i.eventsToUnbind.push(p(i, \"show\", function () {\n              this.navigatorSeries && this.navigatorSeries.setVisible(!0, !1);\n            })), i.eventsToUnbind.push(p(i, \"hide\", function () {\n              this.navigatorSeries && this.navigatorSeries.setVisible(!1, !1);\n            })), !1 !== _this2.navigatorOptions.adaptToUpdatedData && i.xAxis && i.eventsToUnbind.push(p(i, \"updatedData\", _this2.updatedDataHandler)), i.eventsToUnbind.push(p(i, \"remove\", function () {\n              e && m(e, i), this.navigatorSeries && (m(t.series, this.navigatorSeries), x(this.navigatorSeries.options) && this.navigatorSeries.remove(!1), delete this.navigatorSeries);\n            }));\n          });\n        }\n      }, {\n        key: \"getBaseSeriesMin\",\n        value: function getBaseSeriesMin(t) {\n          return this.baseSeries.reduce(function (t, e) {\n            return Math.min(t, e.xData && e.xData.length ? e.xData[0] : t);\n          }, t);\n        }\n      }, {\n        key: \"modifyNavigatorAxisExtremes\",\n        value: function modifyNavigatorAxisExtremes() {\n          var t = this.xAxis;\n          if (void 0 !== t.getExtremes) {\n            var _e5 = this.getUnionExtremes(!0);\n            _e5 && (_e5.dataMin !== t.min || _e5.dataMax !== t.max) && (t.min = _e5.dataMin, t.max = _e5.dataMax);\n          }\n        }\n      }, {\n        key: \"modifyBaseAxisExtremes\",\n        value: function modifyBaseAxisExtremes() {\n          var _this$ordinal;\n          var t, e;\n          var i = this.chart.navigator,\n            s = this.getExtremes(),\n            o = s.min,\n            r = s.max,\n            n = s.dataMin,\n            a = s.dataMax,\n            l = r - o,\n            h = i.stickToMin,\n            d = i.stickToMax,\n            c = S((_this$ordinal = this.ordinal) === null || _this$ordinal === void 0 ? void 0 : _this$ordinal.convertOverscroll(this.options.overscroll), 0),\n            p = i.series && i.series[0],\n            u = !!this.setExtremes;\n          !(this.eventArgs && \"rangeSelectorButton\" === this.eventArgs.trigger) && (h && (t = (e = n) + l), d && (t = a + c, h || (e = Math.max(n, t - l, i.getBaseSeriesMin(p && p.xData ? p.xData[0] : -Number.MAX_VALUE)))), u && (h || d) && k(e) && (this.min = this.userMin = e, this.max = this.userMax = t)), i.stickToMin = i.stickToMax = null;\n        }\n      }, {\n        key: \"updatedDataHandler\",\n        value: function updatedDataHandler() {\n          var t = this.chart.navigator,\n            e = this.navigatorSeries,\n            i = t.reversedExtremes ? 0 === Math.round(t.zoomedMin) : Math.round(t.zoomedMax) >= Math.round(t.size);\n          t.stickToMax = S(this.chart.options.navigator && this.chart.options.navigator.stickToMax, i), t.stickToMin = t.shouldStickToMin(this, t), e && !t.hasNavigatorData && (e.options.pointStart = this.xData[0], e.setData(this.options.data, !1, null, !1));\n        }\n      }, {\n        key: \"shouldStickToMin\",\n        value: function shouldStickToMin(t, e) {\n          var i = e.getBaseSeriesMin(t.xData[0]),\n            s = t.xAxis,\n            o = s.max,\n            r = s.min,\n            n = s.options.range;\n          return !!(k(o) && k(r)) && (n && o - i > 0 ? o - i < n : r <= i);\n        }\n      }, {\n        key: \"addChartEvents\",\n        value: function addChartEvents() {\n          this.eventsToUnbind || (this.eventsToUnbind = []), this.eventsToUnbind.push(p(this.chart, \"redraw\", function () {\n            var t = this.navigator,\n              e = t && (t.baseSeries && t.baseSeries[0] && t.baseSeries[0].xAxis || this.xAxis[0]);\n            e && t.render(e.min, e.max);\n          }), p(this.chart, \"getMargins\", function () {\n            var t = this.navigator,\n              e = t.opposite ? \"plotTop\" : \"marginBottom\";\n            this.inverted && (e = t.opposite ? \"marginRight\" : \"plotLeft\"), this[e] = (this[e] || 0) + (t.navigatorEnabled || !this.inverted ? t.height + t.scrollbarHeight : 0) + t.navigatorOptions.margin;\n          }), p(O, \"setRange\", function (t) {\n            this.chart.xAxis[0].setExtremes(t.min, t.max, t.redraw, t.animation, t.eventArguments);\n          }));\n        }\n      }, {\n        key: \"destroy\",\n        value: function destroy() {\n          var _this3 = this;\n          this.removeEvents(), this.xAxis && (m(this.chart.xAxis, this.xAxis), m(this.chart.axes, this.xAxis)), this.yAxis && (m(this.chart.yAxis, this.yAxis), m(this.chart.axes, this.yAxis)), (this.series || []).forEach(function (t) {\n            t.destroy && t.destroy();\n          }), [\"series\", \"xAxis\", \"yAxis\", \"shades\", \"outline\", \"scrollbarTrack\", \"scrollbarRifles\", \"scrollbarGroup\", \"scrollbar\", \"navigatorGroup\", \"rendered\"].forEach(function (t) {\n            _this3[t] && _this3[t].destroy && _this3[t].destroy(), _this3[t] = null;\n          }), [this.handles].forEach(function (t) {\n            f(t);\n          }), this.navigatorEnabled = !1;\n        }\n      }], [{\n        key: \"compose\",\n        value: function compose(t, i, s) {\n          e.compose(t, O), r.compose(t, i, s);\n        }\n      }]);\n    }();\n    return O;\n  }), i(e, \"Stock/RangeSelector/RangeSelectorDefaults.js\", [], function () {\n    return {\n      lang: {\n        rangeSelectorZoom: \"Zoom\",\n        rangeSelectorFrom: \"\",\n        rangeSelectorTo: \"‚Üí\"\n      },\n      rangeSelector: {\n        allButtonsEnabled: !1,\n        buttons: void 0,\n        buttonSpacing: 5,\n        dropdown: \"responsive\",\n        enabled: void 0,\n        verticalAlign: \"top\",\n        buttonTheme: {\n          width: 28,\n          height: 18,\n          padding: 2,\n          zIndex: 7\n        },\n        floating: !1,\n        x: 0,\n        y: 0,\n        height: void 0,\n        inputBoxBorderColor: \"none\",\n        inputBoxHeight: 17,\n        inputBoxWidth: void 0,\n        inputDateFormat: \"%e %b %Y\",\n        inputDateParser: void 0,\n        inputEditDateFormat: \"%Y-%m-%d\",\n        inputEnabled: !0,\n        inputPosition: {\n          align: \"right\",\n          x: 0,\n          y: 0\n        },\n        inputSpacing: 5,\n        selected: void 0,\n        buttonPosition: {\n          align: \"left\",\n          x: 0,\n          y: 0\n        },\n        inputStyle: {\n          color: \"#334eff\",\n          cursor: \"pointer\",\n          fontSize: \"0.8em\"\n        },\n        labelStyle: {\n          color: \"#666666\",\n          fontSize: \"0.8em\"\n        }\n      }\n    };\n  }), i(e, \"Stock/RangeSelector/RangeSelectorComposition.js\", [e[\"Core/Defaults.js\"], e[\"Core/Globals.js\"], e[\"Stock/RangeSelector/RangeSelectorDefaults.js\"], e[\"Core/Utilities.js\"]], function (t, e, i, s) {\n    var o;\n    var r = t.defaultOptions,\n      n = e.composed,\n      a = s.addEvent,\n      l = s.defined,\n      h = s.extend,\n      d = s.isNumber,\n      c = s.merge,\n      p = s.pick,\n      u = s.pushUnique,\n      g = [];\n    function x() {\n      var t, e;\n      var i = this.range,\n        s = i.type,\n        o = this.max,\n        r = this.chart.time,\n        n = function n(t, e) {\n          var i = \"year\" === s ? \"FullYear\" : \"Month\",\n            o = new r.Date(t),\n            n = r.get(i, o);\n          return r.set(i, o, n + e), n === r.get(i, o) && r.set(\"Date\", o, 0), o.getTime() - t;\n        };\n      d(i) ? (t = o - i, e = i) : i && (t = o + n(o, -(i.count || 1)), this.chart && this.chart.setFixedRange(o - t));\n      var a = p(this.dataMin, Number.MIN_VALUE);\n      return d(t) || (t = a), t <= a && (t = a, void 0 === e && (e = n(t, i.count)), this.newMax = Math.min(t + e, p(this.dataMax, Number.MAX_VALUE))), d(o) ? !d(i) && i && i._offsetMin && (t += i._offsetMin) : t = void 0, t;\n    }\n    function f() {\n      this.options.rangeSelector && this.options.rangeSelector.enabled && (this.rangeSelector = new o(this));\n    }\n    function m() {\n      var t = this.rangeSelector;\n      if (t) {\n        d(t.deferredYTDClick) && (t.clickButton(t.deferredYTDClick), delete t.deferredYTDClick);\n        var _e6 = t.options.verticalAlign;\n        t.options.floating || (\"bottom\" === _e6 ? this.extraBottomMargin = !0 : \"middle\" === _e6 || (this.extraTopMargin = !0));\n      }\n    }\n    function b() {\n      var t;\n      var e = this.rangeSelector;\n      if (!e) return;\n      var i = this.xAxis[0].getExtremes(),\n        s = this.legend,\n        o = e && e.options.verticalAlign;\n      d(i.min) && e.render(i.min, i.max), s.display && \"top\" === o && o === s.options.verticalAlign && (t = c(this.spacingBox), \"vertical\" === s.options.layout ? t.y = this.plotTop : t.y += e.getHeight(), s.group.placed = !1, s.align(t));\n    }\n    function y() {\n      for (var _t3 = 0, _e7 = g.length; _t3 < _e7; ++_t3) {\n        var _e8 = g[_t3];\n        if (_e8[0] === this) {\n          _e8[1].forEach(function (t) {\n            return t();\n          }), g.splice(_t3, 1);\n          return;\n        }\n      }\n    }\n    function v() {\n      var t = this.rangeSelector;\n      if (t) {\n        var _e9 = t.getHeight();\n        this.extraTopMargin && (this.plotTop += _e9), this.extraBottomMargin && (this.marginBottom += _e9);\n      }\n    }\n    function M(t) {\n      var e = t.options.rangeSelector,\n        i = this.extraBottomMargin,\n        s = this.extraTopMargin,\n        r = this.rangeSelector;\n      if (e && e.enabled && !l(r) && this.options.rangeSelector && (this.options.rangeSelector.enabled = !0, this.rangeSelector = r = new o(this)), this.extraBottomMargin = !1, this.extraTopMargin = !1, r) {\n        var _t4 = e && e.verticalAlign || r.options && r.options.verticalAlign;\n        r.options.floating || (\"bottom\" === _t4 ? this.extraBottomMargin = !0 : \"middle\" === _t4 || (this.extraTopMargin = !0)), (this.extraBottomMargin !== i || this.extraTopMargin !== s) && (this.isDirtyBox = !0);\n      }\n    }\n    return {\n      compose: function compose(t, e, s) {\n        if (o = s, u(n, \"RangeSelector\")) {\n          var _s2 = e.prototype;\n          t.prototype.minFromRange = x, a(e, \"afterGetContainer\", f), a(e, \"beforeRender\", m), a(e, \"destroy\", y), a(e, \"getMargins\", v), a(e, \"redraw\", b), a(e, \"update\", M), _s2.callbacks.push(b), h(r, {\n            rangeSelector: i.rangeSelector\n          }), h(r.lang, i.lang);\n        }\n      }\n    };\n  }), i(e, \"Core/Axis/OrdinalAxis.js\", [e[\"Core/Axis/Axis.js\"], e[\"Core/Globals.js\"], e[\"Core/Series/Series.js\"], e[\"Core/Utilities.js\"]], function (t, e, i, s) {\n    var o;\n    var r = s.addEvent,\n      n = s.correctFloat,\n      a = s.css,\n      l = s.defined,\n      h = s.error,\n      d = s.isNumber,\n      c = s.pick,\n      p = s.timeUnits,\n      u = s.isString;\n    return function (t) {\n      function s(t, e, i, o) {\n        var r = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [];\n        var n = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;\n        var a = arguments.length > 6 ? arguments[6] : undefined;\n        var d = {},\n          c = this.options.tickPixelInterval,\n          u = this.chart.time,\n          g = [],\n          x,\n          f,\n          m,\n          b,\n          y,\n          v = 0,\n          M = [],\n          k = -Number.MAX_VALUE;\n        if (!this.options.ordinal && !this.options.breaks || !r || r.length < 3 || void 0 === e) return u.getTimeTicks.apply(u, arguments);\n        var A = r.length;\n        for (x = 0; x < A; x++) {\n          if (y = x && r[x - 1] > i, r[x] < e && (v = x), x === A - 1 || r[x + 1] - r[x] > 5 * n || y) {\n            if (r[x] > k) {\n              for (f = u.getTimeTicks(t, r[v], r[x], o); f.length && f[0] <= k;) f.shift();\n              f.length && (k = f[f.length - 1]), g.push(M.length), M = M.concat(f);\n            }\n            v = x + 1;\n          }\n          if (y) break;\n        }\n        if (f) {\n          if (b = f.info, a && b.unitRange <= p.hour) {\n            for (v = 1, x = M.length - 1; v < x; v++) u.dateFormat(\"%d\", M[v]) !== u.dateFormat(\"%d\", M[v - 1]) && (d[M[v]] = \"day\", m = !0);\n            m && (d[M[0]] = \"day\"), b.higherRanks = d;\n          }\n          b.segmentStarts = g, M.info = b;\n        } else h(12, !1, this.chart);\n        if (a && l(c)) {\n          var _t5 = M.length,\n            _e10 = [],\n            _s3 = [],\n            _o2,\n            _r2,\n            _n2,\n            _a3,\n            _l3,\n            _h = _t5;\n          for (; _h--;) _r2 = this.translate(M[_h]), _n2 && (_s3[_h] = _n2 - _r2), _e10[_h] = _n2 = _r2;\n          for (_s3.sort(function (t, e) {\n            return t - e;\n          }), (_a3 = _s3[Math.floor(_s3.length / 2)]) < .6 * c && (_a3 = null), _h = M[_t5 - 1] > i ? _t5 - 1 : _t5, _n2 = void 0; _h--;) _l3 = Math.abs(_n2 - (_r2 = _e10[_h])), _n2 && _l3 < .8 * c && (null === _a3 || _l3 < .8 * _a3) ? (d[M[_h]] && !d[M[_h + 1]] ? (_o2 = _h + 1, _n2 = _r2) : _o2 = _h, M.splice(_o2, 1)) : _n2 = _r2;\n        }\n        return M;\n      }\n      function o(t) {\n        var e = this.ordinal.positions;\n        if (!e) return t;\n        var i = e.length - 1,\n          s;\n        return (t < 0 ? t = e[0] : t > i ? t = e[i] : (i = Math.floor(t), s = t - i), void 0 !== s && void 0 !== e[i]) ? e[i] + (s ? s * (e[i + 1] - e[i]) : 0) : t;\n      }\n      function g(t) {\n        var e = this.ordinal,\n          i = this.old ? this.old.min : this.min,\n          s = this.old ? this.old.transA : this.transA,\n          o = e.getExtendedPositions();\n        if (o && o.length) {\n          var _r3 = n((t - i) * s + this.minPixelPadding),\n            _a4 = n(e.getIndexOfPoint(_r3, o)),\n            _l4 = n(_a4 % 1);\n          if (_a4 >= 0 && _a4 <= o.length - 1) {\n            var _t6 = o[Math.floor(_a4)],\n              _e11 = o[Math.ceil(_a4)];\n            return o[Math.floor(_a4)] + _l4 * (_e11 - _t6);\n          }\n        }\n        return t;\n      }\n      function x(e, i) {\n        var s = t.Additions.findIndexOf(e, i, !0);\n        if (e[s] === i) return s;\n        var o = (i - e[s]) / (e[s + 1] - e[s]);\n        return s + o;\n      }\n      function f() {\n        this.ordinal || (this.ordinal = new t.Additions(this));\n      }\n      function m() {\n        var t = this.eventArgs,\n          e = this.options;\n        if (this.isXAxis && l(e.overscroll) && 0 !== e.overscroll && d(this.max) && d(this.min) && (this.options.ordinal && !this.ordinal.originalOrdinalRange && this.ordinal.getExtendedPositions(!1), this.max === this.dataMax && ((t === null || t === void 0 ? void 0 : t.trigger) !== \"pan\" || this.isInternal) && (t === null || t === void 0 ? void 0 : t.trigger) !== \"navigator\")) {\n          var _i9 = this.ordinal.convertOverscroll(e.overscroll);\n          this.max += _i9, !this.isInternal && l(this.userMin) && (t === null || t === void 0 ? void 0 : t.trigger) !== \"mousewheel\" && (this.min += _i9);\n        }\n      }\n      function b() {\n        this.horiz && !this.isDirty && (this.isDirty = this.isOrdinal && this.chart.navigator && !this.chart.navigator.adaptToUpdatedData);\n      }\n      function y() {\n        this.ordinal && (this.ordinal.beforeSetTickPositions(), this.tickInterval = this.ordinal.postProcessTickInterval(this.tickInterval));\n      }\n      function v(t) {\n        var e = this.xAxis[0],\n          i = e.ordinal.convertOverscroll(e.options.overscroll),\n          s = t.originalEvent.chartX,\n          o = this.options.chart.panning,\n          r = !1;\n        if (o && \"y\" !== o.type && e.options.ordinal && e.series.length && (!t.touches || t.touches.length <= 1)) {\n          var _t7, _o3;\n          var _n3 = this.mouseDownX,\n            _l5 = e.getExtremes(),\n            _h2 = _l5.dataMin,\n            _d2 = _l5.dataMax,\n            _c = _l5.min,\n            _p = _l5.max,\n            _u = this.hoverPoints,\n            _g = e.closestPointRange || e.ordinal && e.ordinal.overscrollPointsRange,\n            _x = Math.round((_n3 - s) / (e.translationSlope * (e.ordinal.slope || _g))),\n            _f = e.ordinal.getExtendedPositions(),\n            _m = {\n              ordinal: {\n                positions: _f,\n                extendedOrdinalPositions: _f\n              }\n            },\n            _b = e.index2val,\n            _y = e.val2lin;\n          if (_c <= _h2 && _x < 0 || _p + i >= _d2 && _x > 0) return;\n          _m.ordinal.positions ? Math.abs(_x) > 1 && (_u && _u.forEach(function (t) {\n            t.setState();\n          }), _d2 > (_o3 = _m.ordinal.positions)[_o3.length - 1] && _o3.push(_d2), this.setFixedRange(_p - _c), (_t7 = e.navigatorAxis.toFixedRange(void 0, void 0, _b.apply(_m, [_y.apply(_m, [_c, !0]) + _x]), _b.apply(_m, [_y.apply(_m, [_p, !0]) + _x]))).min >= Math.min(_l5.dataMin, _c) && _t7.max <= Math.max(_d2, _p) + i && e.setExtremes(_t7.min, _t7.max, !0, !1, {\n            trigger: \"pan\"\n          }), this.mouseDownX = s, a(this.container, {\n            cursor: \"move\"\n          })) : r = !0;\n        } else r = !0;\n        r || o && /y/.test(o.type) ? i && (e.max = e.dataMax + i) : t.preventDefault();\n      }\n      function M() {\n        var t = this.xAxis;\n        t && t.options.ordinal && (delete t.ordinal.index, delete t.ordinal.originalOrdinalRange);\n      }\n      function k(t, e) {\n        var i;\n        var s = this.ordinal,\n          o = s.positions,\n          r = s.slope,\n          n;\n        if (!o) return t;\n        var a = o.length;\n        if (o[0] <= t && o[a - 1] >= t) i = x(o, t);else {\n          if (!((n = s.getExtendedPositions && s.getExtendedPositions()) && n.length)) return t;\n          var _a5 = n.length;\n          r || (r = (n[_a5 - 1] - n[0]) / _a5);\n          var _l6 = x(n, o[0]);\n          if (t >= n[0] && t <= n[_a5 - 1]) i = x(n, t) - _l6;else {\n            if (!e) return t;\n            i = t < n[0] ? -_l6 - (n[0] - t) / r : (t - n[_a5 - 1]) / r + _a5 - _l6;\n          }\n        }\n        return e ? i : r * (i || 0) + s.offset;\n      }\n      t.compose = function (t, e, i) {\n        var n = t.prototype;\n        return n.ordinal2lin || (n.getTimeTicks = s, n.index2val = o, n.lin2val = g, n.val2lin = k, n.ordinal2lin = n.val2lin, r(t, \"afterInit\", f), r(t, \"foundExtremes\", m), r(t, \"afterSetScale\", b), r(t, \"initialAxisTranslation\", y), r(i, \"pan\", v), r(i, \"touchpan\", v), r(e, \"updatedData\", M)), t;\n      };\n      var A = /*#__PURE__*/function () {\n        function A(t) {\n          _classCallCheck(this, A);\n          this.index = {}, this.axis = t;\n        }\n        return _createClass(A, [{\n          key: \"beforeSetTickPositions\",\n          value: function beforeSetTickPositions() {\n            var _t$brokenAxis;\n            var t = this.axis,\n              e = t.ordinal,\n              i = t.getExtremes(),\n              s = i.min,\n              o = i.max,\n              r = (_t$brokenAxis = t.brokenAxis) === null || _t$brokenAxis === void 0 ? void 0 : _t$brokenAxis.hasBreaks,\n              n = t.options.ordinal,\n              a,\n              l,\n              h,\n              d,\n              p,\n              u,\n              g,\n              x = [],\n              f = Number.MAX_VALUE,\n              m = !1,\n              b = !1,\n              y = !1;\n            if (n || r) {\n              var _i10 = 0;\n              if (t.series.forEach(function (t, e) {\n                if (l = [], e > 0 && \"highcharts-navigator-series\" !== t.options.id && t.processedXData.length > 1 && (b = _i10 !== t.processedXData[1] - t.processedXData[0]), _i10 = t.processedXData[1] - t.processedXData[0], t.boosted && (y = t.boosted), t.reserveSpace() && (!1 !== t.takeOrdinalPosition || r) && (a = (x = x.concat(t.processedXData)).length, x.sort(function (t, e) {\n                  return t - e;\n                }), f = Math.min(f, c(t.closestPointRange, f)), a)) {\n                  for (e = 0; e < a - 1;) x[e] !== x[e + 1] && l.push(x[e + 1]), e++;\n                  l[0] !== x[0] && l.unshift(x[0]), x = l;\n                }\n              }), t.ordinal.originalOrdinalRange || (t.ordinal.originalOrdinalRange = (x.length - 1) * f), b && y && (x.pop(), x.shift()), (a = x.length) > 2) {\n                for (h = x[1] - x[0], g = a - 1; g-- && !m;) x[g + 1] - x[g] !== h && (m = !0);\n                !t.options.keepOrdinalPadding && (x[0] - s > h || o - x[x.length - 1] > h) && (m = !0);\n              } else t.options.overscroll && (2 === a ? f = x[1] - x[0] : 1 === a ? (f = t.ordinal.convertOverscroll(t.options.overscroll), x = [x[0], x[0] + f]) : f = e.overscrollPointsRange);\n              m || t.forceOrdinal ? (t.options.overscroll && (e.overscrollPointsRange = f, x = x.concat(e.getOverscrollPositions())), e.positions = x, d = t.ordinal2lin(Math.max(s, x[0]), !0), p = Math.max(t.ordinal2lin(Math.min(o, x[x.length - 1]), !0), 1), e.slope = u = (o - s) / (p - d), e.offset = s - d * u) : (e.overscrollPointsRange = c(t.closestPointRange, e.overscrollPointsRange), e.positions = t.ordinal.slope = e.offset = void 0);\n            }\n            t.isOrdinal = n && m, e.groupIntervalFactor = null;\n          }\n        }, {\n          key: \"getExtendedPositions\",\n          value: function getExtendedPositions() {\n            var _o$series$, _p2, _p3;\n            var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : !0;\n            var s = this,\n              o = s.axis,\n              r = o.constructor.prototype,\n              n = o.chart,\n              a = (_o$series$ = o.series[0]) === null || _o$series$ === void 0 ? void 0 : _o$series$.currentDataGrouping,\n              l = a ? a.count + a.unitName : \"raw\",\n              h = t ? o.ordinal.convertOverscroll(o.options.overscroll) : 0,\n              d = o.getExtremes(),\n              c,\n              p,\n              u = s.index;\n            return u || (u = s.index = {}), u[l] || ((c = {\n              series: [],\n              chart: n,\n              forceOrdinal: !1,\n              getExtremes: function getExtremes() {\n                return {\n                  min: d.dataMin,\n                  max: d.dataMax + h\n                };\n              },\n              applyGrouping: r.applyGrouping,\n              getGroupPixelWidth: r.getGroupPixelWidth,\n              getTimeTicks: r.getTimeTicks,\n              options: {\n                ordinal: !0\n              },\n              ordinal: {\n                getGroupIntervalFactor: this.getGroupIntervalFactor\n              },\n              ordinal2lin: r.ordinal2lin,\n              getIndexOfPoint: r.getIndexOfPoint,\n              val2lin: r.val2lin\n            }).ordinal.axis = c, o.series.forEach(function (o) {\n              var _o$options$dataGroupi, _o$options$dataGroupi2, _o$options$dataGroupi3;\n              p = {\n                xAxis: c,\n                xData: o.xData.slice(),\n                chart: n,\n                groupPixelWidth: o.groupPixelWidth,\n                destroyGroupedData: e.noop,\n                getProcessedData: i.prototype.getProcessedData,\n                applyGrouping: i.prototype.applyGrouping,\n                reserveSpace: i.prototype.reserveSpace,\n                visible: o.visible\n              }, t && (p.xData = p.xData.concat(s.getOverscrollPositions())), p.options = {\n                dataGrouping: a ? {\n                  firstAnchor: (_o$options$dataGroupi = o.options.dataGrouping) === null || _o$options$dataGroupi === void 0 ? void 0 : _o$options$dataGroupi.firstAnchor,\n                  anchor: (_o$options$dataGroupi2 = o.options.dataGrouping) === null || _o$options$dataGroupi2 === void 0 ? void 0 : _o$options$dataGroupi2.anchor,\n                  lastAnchor: (_o$options$dataGroupi3 = o.options.dataGrouping) === null || _o$options$dataGroupi3 === void 0 ? void 0 : _o$options$dataGroupi3.firstAnchor,\n                  enabled: !0,\n                  forced: !0,\n                  approximation: \"open\",\n                  units: [[a.unitName, [a.count]]]\n                } : {\n                  enabled: !1\n                }\n              }, c.series.push(p), o.processData.apply(p);\n            }), c.applyGrouping({\n              hasExtremesChanged: !0\n            }), ((_p2 = p) === null || _p2 === void 0 ? void 0 : _p2.closestPointRange) !== ((_p3 = p) === null || _p3 === void 0 ? void 0 : _p3.basePointRange) && p.currentDataGrouping && (c.forceOrdinal = !0), o.ordinal.beforeSetTickPositions.apply({\n              axis: c\n            }), !o.ordinal.originalOrdinalRange && c.ordinal.originalOrdinalRange && (o.ordinal.originalOrdinalRange = c.ordinal.originalOrdinalRange), u[l] = c.ordinal.positions), u[l];\n          }\n        }, {\n          key: \"getGroupIntervalFactor\",\n          value: function getGroupIntervalFactor(t, e, i) {\n            var s = i.processedXData,\n              o = s.length,\n              r = [],\n              n,\n              a,\n              l = this.groupIntervalFactor;\n            if (!l) {\n              for (a = 0; a < o - 1; a++) r[a] = s[a + 1] - s[a];\n              r.sort(function (t, e) {\n                return t - e;\n              }), n = r[Math.floor(o / 2)], t = Math.max(t, s[0]), e = Math.min(e, s[o - 1]), this.groupIntervalFactor = l = o * n / (e - t);\n            }\n            return l;\n          }\n        }, {\n          key: \"getIndexOfPoint\",\n          value: function getIndexOfPoint(t, e) {\n            var _i11;\n            var i;\n            var s = this.axis,\n              o = 0,\n              r = function r(t) {\n                var e = s.min,\n                  i = s.max;\n                return !!(l(e) && l(i)) && t.points.some(function (t) {\n                  return t.x >= e && t.x <= i;\n                });\n              };\n            s.series.forEach(function (t) {\n              var _t$points;\n              var e = (_t$points = t.points) === null || _t$points === void 0 ? void 0 : _t$points[0];\n              l(e === null || e === void 0 ? void 0 : e.plotX) && (e.plotX < i || !l(i)) && r(t) && (i = e.plotX, o = e.x);\n            }), (_i11 = i) !== null && _i11 !== void 0 ? _i11 : i = s.minPixelPadding;\n            var a = s.translationSlope * (this.slope || s.closestPointRange || this.overscrollPointsRange),\n              h = n((t - i) / a);\n            return A.findIndexOf(e, o, !0) + h;\n          }\n        }, {\n          key: \"getOverscrollPositions\",\n          value: function getOverscrollPositions() {\n            var t = this.axis,\n              e = this.convertOverscroll(t.options.overscroll),\n              i = this.overscrollPointsRange,\n              s = [],\n              o = t.dataMax;\n            if (l(i)) for (; o <= t.dataMax + e;) s.push(o += i);\n            return s;\n          }\n        }, {\n          key: \"postProcessTickInterval\",\n          value: function postProcessTickInterval(t) {\n            var e = this.axis,\n              i = this.slope;\n            return i ? e.options.breaks ? e.closestPointRange || t : t / (i / e.closestPointRange) : t;\n          }\n        }, {\n          key: \"convertOverscroll\",\n          value: function convertOverscroll() {\n            var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n            var e = this,\n              i = e.axis,\n              s = function s(t) {\n                return c(e.originalOrdinalRange, l(i.dataMax) && l(i.dataMin) ? i.dataMax - i.dataMin : 0) * t;\n              };\n            if (u(t)) {\n              var _e12 = parseInt(t, 10);\n              if (/%$/.test(t)) return s(_e12 / 100);\n              if (/px/.test(t)) {\n                var _t8 = Math.min(_e12, .9 * i.len) / i.len;\n                return s(_t8 / (1 - _t8));\n              }\n              return 0;\n            }\n            return t;\n          }\n        }], [{\n          key: \"findIndexOf\",\n          value: function findIndexOf(t, e, i) {\n            var s = 0,\n              o = t.length - 1,\n              r;\n            for (; s < o;) t[r = Math.ceil((s + o) / 2)] <= e ? s = r : o = r - 1;\n            return t[s] === e ? s : i ? s : -1;\n          }\n        }]);\n      }();\n      t.Additions = A;\n    }(o || (o = {})), o;\n  }), i(e, \"Stock/RangeSelector/RangeSelector.js\", [e[\"Core/Axis/Axis.js\"], e[\"Core/Defaults.js\"], e[\"Core/Globals.js\"], e[\"Stock/RangeSelector/RangeSelectorComposition.js\"], e[\"Core/Renderer/SVG/SVGElement.js\"], e[\"Core/Utilities.js\"], e[\"Core/Axis/OrdinalAxis.js\"]], function (t, e, i, s, o, r, n) {\n    var a = e.defaultOptions,\n      l = r.addEvent,\n      h = r.createElement,\n      d = r.css,\n      c = r.defined,\n      p = r.destroyObjectProperties,\n      u = r.discardElement,\n      g = r.extend,\n      x = r.fireEvent,\n      f = r.isNumber,\n      m = r.merge,\n      b = r.objectEach,\n      y = r.pad,\n      v = r.pick,\n      M = r.pInt,\n      k = r.splat;\n    var A = /*#__PURE__*/function () {\n      function A(t) {\n        _classCallCheck(this, A);\n        this.buttonOptions = A.prototype.defaultButtons, this.initialButtonGroupWidth = 0, this.init(t);\n      }\n      return _createClass(A, [{\n        key: \"clickButton\",\n        value: function clickButton(e, i) {\n          var s = this.chart,\n            o = this.buttonOptions[e],\n            r = s.xAxis[0],\n            n = s.scroller && s.scroller.getUnionExtremes() || r || {},\n            a = o.type,\n            h = o.dataGrouping,\n            d = n.dataMin,\n            p = n.dataMax,\n            u,\n            g = r && Math.round(Math.min(r.max, v(p, r.max))),\n            m,\n            b = o._range,\n            y,\n            M,\n            _A,\n            S = !0;\n          if (null !== d && null !== p) {\n            if (this.setSelected(e), h && (this.forcedDataGrouping = !0, t.prototype.setDataGrouping.call(r || {\n              chart: this.chart\n            }, h, !1), this.frozenStates = o.preserveDataGrouping), \"month\" === a || \"year\" === a) r ? (M = {\n              range: o,\n              max: g,\n              chart: s,\n              dataMin: d,\n              dataMax: p\n            }, u = r.minFromRange.call(M), f(M.newMax) && (g = M.newMax), S = !1) : b = o;else if (b) g = Math.min((u = Math.max(g - b, d)) + b, p), S = !1;else if (\"ytd\" === a) {\n              if (r) (void 0 === p || void 0 === d) && (d = Number.MAX_VALUE, p = Number.MIN_VALUE, s.series.forEach(function (t) {\n                var e = t.xData;\n                e && (d = Math.min(e[0], d), p = Math.max(e[e.length - 1], p));\n              }), i = !1), u = y = (_A = this.getYTDExtremes(p, d, s.time.useUTC)).min, g = _A.max;else {\n                this.deferredYTDClick = e;\n                return;\n              }\n            } else \"all\" === a && r && (s.navigator && s.navigator.baseSeries[0] && (s.navigator.baseSeries[0].xAxis.options.range = void 0), u = d, g = p);\n            if (S && o._offsetMin && c(u) && (u += o._offsetMin), o._offsetMax && c(g) && (g += o._offsetMax), this.dropdown && (this.dropdown.selectedIndex = e + 1), r) r.setExtremes(u, g, v(i, !0), void 0, {\n              trigger: \"rangeSelectorButton\",\n              rangeSelectorButton: o\n            }), s.setFixedRange(o._range);else {\n              m = k(s.options.xAxis)[0];\n              var _t9 = l(s, \"afterGetAxes\", function () {\n                var t = s.xAxis[0];\n                t.range = t.options.range = b, t.min = t.options.min = y;\n              });\n              l(s, \"load\", function () {\n                var e = s.xAxis[0];\n                s.setFixedRange(o._range), e.options.range = m.range, e.options.min = m.min, _t9();\n              });\n            }\n            x(this, \"afterBtnClick\");\n          }\n        }\n      }, {\n        key: \"setSelected\",\n        value: function setSelected(t) {\n          this.selected = this.options.selected = t;\n        }\n      }, {\n        key: \"init\",\n        value: function init(t) {\n          var e = this,\n            i = t.options.rangeSelector,\n            s = i.buttons || e.defaultButtons.slice(),\n            o = i.selected,\n            r = function r() {\n              var t = e.minInput,\n                i = e.maxInput;\n              t && t.blur && x(t, \"blur\"), i && i.blur && x(i, \"blur\");\n            };\n          e.chart = t, e.options = i, e.buttons = [], e.buttonOptions = s, this.eventsToUnbind = [], this.eventsToUnbind.push(l(t.container, \"mousedown\", r)), this.eventsToUnbind.push(l(t, \"resize\", r)), s.forEach(e.computeButtonRange), void 0 !== o && s[o] && this.clickButton(o, !1), this.eventsToUnbind.push(l(t, \"load\", function () {\n            t.xAxis && t.xAxis[0] && l(t.xAxis[0], \"setExtremes\", function (i) {\n              f(this.max) && f(this.min) && this.max - this.min !== t.fixedRange && \"rangeSelectorButton\" !== i.trigger && \"updatedData\" !== i.trigger && e.forcedDataGrouping && !e.frozenStates && this.setDataGrouping(!1, !1);\n            });\n          })), this.createElements();\n        }\n      }, {\n        key: \"updateButtonStates\",\n        value: function updateButtonStates() {\n          var t = this,\n            e = this.chart,\n            i = this.dropdown,\n            s = this.dropdownLabel,\n            o = e.xAxis[0],\n            r = Math.round(o.max - o.min),\n            l = !o.hasVisibleSeries,\n            h = 24 * 36e5,\n            c = e.scroller && e.scroller.getUnionExtremes() || o,\n            p = c.dataMin,\n            u = c.dataMax,\n            g = t.getYTDExtremes(u, p, e.time.useUTC),\n            x = g.min,\n            m = g.max,\n            b = t.selected,\n            y = t.options.allButtonsEnabled,\n            v = Array(t.buttonOptions.length).fill(0),\n            M = f(b),\n            k = t.buttons,\n            _A2 = !1,\n            S = null;\n          t.buttonOptions.forEach(function (e, i) {\n            var _o$ordinal;\n            var s = e._range,\n              a = e.type,\n              d = e.count || 1,\n              c = e._offsetMax - e._offsetMin,\n              g = i === b,\n              f = s > u - p,\n              k = s < o.minRange,\n              C = !1,\n              w = s === r;\n            if (g && f && (_A2 = !0), o.isOrdinal && (_o$ordinal = o.ordinal) !== null && _o$ordinal !== void 0 && _o$ordinal.positions && s && r < s) {\n              var _t10 = o.ordinal.positions,\n                _e13 = n.Additions.findIndexOf(_t10, o.min, !0),\n                _i12 = Math.min(n.Additions.findIndexOf(_t10, o.max, !0) + 1, _t10.length - 1);\n              _t10[_i12] - _t10[_e13] > s && (w = !0);\n            } else (\"month\" === a || \"year\" === a) && r + 36e5 >= {\n              month: 28,\n              year: 365\n            }[a] * h * d - c && r - 36e5 <= {\n              month: 31,\n              year: 366\n            }[a] * h * d + c ? w = !0 : \"ytd\" === a ? (w = m - x + c === r, C = !g) : \"all\" === a && (w = o.max - o.min >= u - p);\n            var P = !y && !(_A2 && \"all\" === a) && (f || k || l),\n              O = _A2 && \"all\" === a || !C && w || g && t.frozenStates;\n            P ? v[i] = 3 : O && (!M || i === b) && (S = i);\n          }), null !== S ? (v[S] = 2, t.setSelected(S)) : (t.setSelected(), s && (s.setState(0), s.attr({\n            text: (a.lang.rangeSelectorZoom || \"\") + \" ‚ñæ\"\n          })));\n          for (var _e14 = 0; _e14 < v.length; _e14++) {\n            var _o4 = v[_e14],\n              _r4 = k[_e14];\n            if (_r4.state !== _o4 && (_r4.setState(_o4), i)) {\n              i.options[_e14 + 1].disabled = 3 === _o4, 2 === _o4 && (s && (s.setState(2), s.attr({\n                text: t.buttonOptions[_e14].text + \" ‚ñæ\"\n              })), i.selectedIndex = _e14 + 1);\n              var _r5 = s.getBBox();\n              d(i, {\n                width: \"\".concat(_r5.width, \"px\"),\n                height: \"\".concat(_r5.height, \"px\")\n              });\n            }\n          }\n        }\n      }, {\n        key: \"computeButtonRange\",\n        value: function computeButtonRange(t) {\n          var e = t.type,\n            i = t.count || 1,\n            s = {\n              millisecond: 1,\n              second: 1e3,\n              minute: 6e4,\n              hour: 36e5,\n              day: 864e5,\n              week: 6048e5\n            };\n          s[e] ? t._range = s[e] * i : (\"month\" === e || \"year\" === e) && (t._range = 24 * {\n            month: 30,\n            year: 365\n          }[e] * 36e5 * i), t._offsetMin = v(t.offsetMin, 0), t._offsetMax = v(t.offsetMax, 0), t._range += t._offsetMax - t._offsetMin;\n        }\n      }, {\n        key: \"getInputValue\",\n        value: function getInputValue(t) {\n          var e = \"min\" === t ? this.minInput : this.maxInput,\n            i = this.chart.options.rangeSelector,\n            s = this.chart.time;\n          return e ? (\"text\" === e.type && i.inputDateParser || this.defaultInputDateParser)(e.value, s.useUTC, s) : 0;\n        }\n      }, {\n        key: \"setInputValue\",\n        value: function setInputValue(t, e) {\n          var i = this.options,\n            s = this.chart.time,\n            o = \"min\" === t ? this.minInput : this.maxInput,\n            r = \"min\" === t ? this.minDateBox : this.maxDateBox;\n          if (o) {\n            var _t11 = o.getAttribute(\"data-hc-time\"),\n              _n4 = c(_t11) ? Number(_t11) : void 0;\n            if (c(e)) {\n              var _t12 = _n4;\n              c(_t12) && o.setAttribute(\"data-hc-time-previous\", _t12), o.setAttribute(\"data-hc-time\", e), _n4 = e;\n            }\n            o.value = s.dateFormat(this.inputTypeFormats[o.type] || i.inputEditDateFormat, _n4), r && r.attr({\n              text: s.dateFormat(i.inputDateFormat, _n4)\n            });\n          }\n        }\n      }, {\n        key: \"setInputExtremes\",\n        value: function setInputExtremes(t, e, i) {\n          var s = \"min\" === t ? this.minInput : this.maxInput;\n          if (s) {\n            var _t13 = this.inputTypeFormats[s.type],\n              _o5 = this.chart.time;\n            if (_t13) {\n              var _r6 = _o5.dateFormat(_t13, e);\n              s.min !== _r6 && (s.min = _r6);\n              var _n5 = _o5.dateFormat(_t13, i);\n              s.max !== _n5 && (s.max = _n5);\n            }\n          }\n        }\n      }, {\n        key: \"showInput\",\n        value: function showInput(t) {\n          var e = \"min\" === t ? this.minDateBox : this.maxDateBox,\n            i = \"min\" === t ? this.minInput : this.maxInput;\n          if (i && e && this.inputGroup) {\n            var _t14 = \"text\" === i.type,\n              _this$inputGroup = this.inputGroup,\n              _this$inputGroup$tran = _this$inputGroup.translateX,\n              _s4 = _this$inputGroup$tran === void 0 ? 0 : _this$inputGroup$tran,\n              _this$inputGroup$tran2 = _this$inputGroup.translateY,\n              _o6 = _this$inputGroup$tran2 === void 0 ? 0 : _this$inputGroup$tran2,\n              _e$x = e.x,\n              _r7 = _e$x === void 0 ? 0 : _e$x,\n              _e$width = e.width,\n              _n6 = _e$width === void 0 ? 0 : _e$width,\n              _e$height = e.height,\n              _a6 = _e$height === void 0 ? 0 : _e$height,\n              _l7 = this.options.inputBoxWidth;\n            d(i, {\n              width: _t14 ? _n6 + (_l7 ? -2 : 20) + \"px\" : \"auto\",\n              height: _a6 - 2 + \"px\",\n              border: \"2px solid silver\"\n            }), _t14 && _l7 ? d(i, {\n              left: _s4 + _r7 + \"px\",\n              top: _o6 + \"px\"\n            }) : d(i, {\n              left: Math.min(Math.round(_r7 + _s4 - (i.offsetWidth - _n6) / 2), this.chart.chartWidth - i.offsetWidth) + \"px\",\n              top: _o6 - (i.offsetHeight - _a6) / 2 + \"px\"\n            });\n          }\n        }\n      }, {\n        key: \"hideInput\",\n        value: function hideInput(t) {\n          var e = \"min\" === t ? this.minInput : this.maxInput;\n          e && d(e, {\n            top: \"-9999em\",\n            border: 0,\n            width: \"1px\",\n            height: \"1px\"\n          });\n        }\n      }, {\n        key: \"defaultInputDateParser\",\n        value: function defaultInputDateParser(t, e, s) {\n          var o = t.split(\"/\").join(\"-\").split(\" \").join(\"T\");\n          if (-1 === o.indexOf(\"T\") && (o += \"T00:00\"), e) o += \"Z\";else {\n            var _t15;\n            if (i.isSafari && !((_t15 = o).length > 6 && (_t15.lastIndexOf(\"-\") === _t15.length - 6 || _t15.lastIndexOf(\"+\") === _t15.length - 6))) {\n              var _t16 = new Date(o).getTimezoneOffset() / 60;\n              o += _t16 <= 0 ? \"+\".concat(y(-_t16), \":00\") : \"-\".concat(y(_t16), \":00\");\n            }\n          }\n          var r = Date.parse(o);\n          if (!f(r)) {\n            var _e15 = t.split(\"-\");\n            r = Date.UTC(M(_e15[0]), M(_e15[1]) - 1, M(_e15[2]));\n          }\n          return s && e && f(r) && (r += s.getTimezoneOffset(r)), r;\n        }\n      }, {\n        key: \"drawInput\",\n        value: function drawInput(t) {\n          var e = this.chart,\n            s = this.div,\n            o = this.inputGroup,\n            r = this,\n            n = e.renderer.style || {},\n            l = e.renderer,\n            c = e.options.rangeSelector,\n            p = a.lang,\n            u = \"min\" === t;\n          function x(t) {\n            var _e$scroller;\n            var i = r.maxInput,\n              s = r.minInput,\n              o = e.xAxis[0],\n              n = ((_e$scroller = e.scroller) === null || _e$scroller === void 0 ? void 0 : _e$scroller.getUnionExtremes()) || o,\n              a = n.dataMin,\n              l = n.dataMax,\n              h = e.xAxis[0].getExtremes()[t],\n              d = r.getInputValue(t);\n            f(d) && d !== h && (u && i && f(a) ? d > Number(i.getAttribute(\"data-hc-time\")) ? d = void 0 : d < a && (d = a) : s && f(l) && (d < Number(s.getAttribute(\"data-hc-time\")) ? d = void 0 : d > l && (d = l)), void 0 !== d && o.setExtremes(u ? d : o.min, u ? o.max : d, void 0, void 0, {\n              trigger: \"rangeSelectorInput\"\n            }));\n          }\n          var b = p[u ? \"rangeSelectorFrom\" : \"rangeSelectorTo\"] || \"\",\n            y = l.label(b, 0).addClass(\"highcharts-range-label\").attr({\n              padding: b ? 2 : 0,\n              height: b ? c.inputBoxHeight : 0\n            }).add(o),\n            v = l.label(\"\", 0).addClass(\"highcharts-range-input\").attr({\n              padding: 2,\n              width: c.inputBoxWidth,\n              height: c.inputBoxHeight,\n              \"text-align\": \"center\"\n            }).on(\"click\", function () {\n              r.showInput(t), r[t + \"Input\"].focus();\n            });\n          e.styledMode || v.attr({\n            stroke: c.inputBoxBorderColor,\n            \"stroke-width\": 1\n          }), v.add(o);\n          var M = h(\"input\", {\n            name: t,\n            className: \"highcharts-range-selector\"\n          }, void 0, s);\n          M.setAttribute(\"type\", function (t) {\n            if (-1 !== t.indexOf(\"%L\")) return \"text\";\n            var e = [\"a\", \"A\", \"d\", \"e\", \"w\", \"b\", \"B\", \"m\", \"o\", \"y\", \"Y\"].some(function (e) {\n                return -1 !== t.indexOf(\"%\" + e);\n              }),\n              i = [\"H\", \"k\", \"I\", \"l\", \"M\", \"S\"].some(function (e) {\n                return -1 !== t.indexOf(\"%\" + e);\n              });\n            return e && i ? \"datetime-local\" : e ? \"date\" : i ? \"time\" : \"text\";\n          }(c.inputDateFormat || \"%e %b %Y\")), e.styledMode || (y.css(m(n, c.labelStyle)), v.css(m({\n            color: \"#333333\"\n          }, n, c.inputStyle)), d(M, g({\n            position: \"absolute\",\n            border: 0,\n            boxShadow: \"0 0 15px rgba(0,0,0,0.3)\",\n            width: \"1px\",\n            height: \"1px\",\n            padding: 0,\n            textAlign: \"center\",\n            fontSize: n.fontSize,\n            fontFamily: n.fontFamily,\n            top: \"-9999em\"\n          }, c.inputStyle))), M.onfocus = function () {\n            r.showInput(t);\n          }, M.onblur = function () {\n            M === i.doc.activeElement && x(t), r.hideInput(t), r.setInputValue(t), M.blur();\n          };\n          var k = !1;\n          return M.onchange = function () {\n            k || (x(t), r.hideInput(t), M.blur());\n          }, M.onkeypress = function (e) {\n            13 === e.keyCode && x(t);\n          }, M.onkeydown = function (e) {\n            k = !0, (\"ArrowUp\" === e.key || \"ArrowDown\" === e.key || \"Tab\" === e.key) && x(t);\n          }, M.onkeyup = function () {\n            k = !1;\n          }, {\n            dateBox: v,\n            input: M,\n            label: y\n          };\n        }\n      }, {\n        key: \"getPosition\",\n        value: function getPosition() {\n          var t = this.chart,\n            e = t.options.rangeSelector,\n            i = \"top\" === e.verticalAlign ? t.plotTop - t.axisOffset[0] : 0;\n          return {\n            buttonTop: i + e.buttonPosition.y,\n            inputTop: i + e.inputPosition.y - 10\n          };\n        }\n      }, {\n        key: \"getYTDExtremes\",\n        value: function getYTDExtremes(t, e, i) {\n          var s = this.chart.time,\n            o = new s.Date(t),\n            r = s.get(\"FullYear\", o),\n            n = Math.max(e, i ? s.Date.UTC(r, 0, 1) : +new s.Date(r, 0, 1)),\n            a = o.getTime();\n          return {\n            max: Math.min(t || a, a),\n            min: n\n          };\n        }\n      }, {\n        key: \"createElements\",\n        value: function createElements() {\n          var _s$chart$style;\n          var t = this.chart,\n            e = t.renderer,\n            i = t.container,\n            s = t.options,\n            o = s.rangeSelector,\n            r = o.inputEnabled,\n            n = v((_s$chart$style = s.chart.style) === null || _s$chart$style === void 0 ? void 0 : _s$chart$style.zIndex, 0) + 1;\n          if (!1 !== o.enabled && (this.group = e.g(\"range-selector-group\").attr({\n            zIndex: 7\n          }).add(), this.div = h(\"div\", void 0, {\n            position: \"relative\",\n            height: 0,\n            zIndex: n\n          }), this.buttonOptions.length && this.renderButtons(), i.parentNode && i.parentNode.insertBefore(this.div, i), r)) {\n            this.inputGroup = e.g(\"input-group\").add(this.group);\n            var _t17 = this.drawInput(\"min\");\n            this.minDateBox = _t17.dateBox, this.minLabel = _t17.label, this.minInput = _t17.input;\n            var _i13 = this.drawInput(\"max\");\n            this.maxDateBox = _i13.dateBox, this.maxLabel = _i13.label, this.maxInput = _i13.input;\n          }\n        }\n      }, {\n        key: \"render\",\n        value: function render(t, e) {\n          var i = this.chart,\n            s = i.options.rangeSelector,\n            o = s.inputEnabled;\n          if (!1 !== s.enabled) {\n            if (o) {\n              this.setInputValue(\"min\", t), this.setInputValue(\"max\", e);\n              var _o7 = i.scroller && i.scroller.getUnionExtremes() || i.xAxis[0] || {};\n              if (c(_o7.dataMin) && c(_o7.dataMax)) {\n                var _t18 = i.xAxis[0].minRange || 0;\n                this.setInputExtremes(\"min\", _o7.dataMin, Math.min(_o7.dataMax, this.getInputValue(\"max\")) - _t18), this.setInputExtremes(\"max\", Math.max(_o7.dataMin, this.getInputValue(\"min\")) + _t18, _o7.dataMax);\n              }\n              if (this.inputGroup) {\n                var _t19 = 0;\n                [this.minLabel, this.minDateBox, this.maxLabel, this.maxDateBox].forEach(function (e) {\n                  if (e) {\n                    var _e$getBBox = e.getBBox(),\n                      _i14 = _e$getBBox.width;\n                    _i14 && (e.attr({\n                      x: _t19\n                    }), _t19 += _i14 + s.inputSpacing);\n                  }\n                });\n              }\n            }\n            this.alignElements(), this.updateButtonStates();\n          }\n        }\n      }, {\n        key: \"renderButtons\",\n        value: function renderButtons() {\n          var _e$userOptions$rangeS,\n            _this4 = this;\n          var t = this.buttons,\n            e = this.chart,\n            s = this.options,\n            o = a.lang,\n            r = e.renderer,\n            n = m(s.buttonTheme),\n            d = n && n.states,\n            c = n.width || 28;\n          delete n.width, delete n.states, this.buttonGroup = r.g(\"range-selector-buttons\").add(this.group);\n          var p = this.dropdown = h(\"select\", void 0, {\n              position: \"absolute\",\n              padding: 0,\n              border: 0,\n              cursor: \"pointer\",\n              opacity: 1e-4\n            }, this.div),\n            u = (_e$userOptions$rangeS = e.userOptions.rangeSelector) === null || _e$userOptions$rangeS === void 0 ? void 0 : _e$userOptions$rangeS.buttonTheme;\n          this.dropdownLabel = r.button(\"\", 0, 0, function () {}, m(n, {\n            \"stroke-width\": v(n[\"stroke-width\"], 0),\n            width: \"auto\",\n            paddingLeft: v(s.buttonTheme.paddingLeft, u === null || u === void 0 ? void 0 : u.padding, 8),\n            paddingRight: v(s.buttonTheme.paddingRight, u === null || u === void 0 ? void 0 : u.padding, 8)\n          }), d && d.hover, d && d.select, d && d.disabled).hide().add(this.group), l(p, \"touchstart\", function () {\n            p.style.fontSize = \"16px\";\n          });\n          var g = i.isMS ? \"mouseover\" : \"mouseenter\",\n            f = i.isMS ? \"mouseout\" : \"mouseleave\";\n          l(p, g, function () {\n            x(_this4.dropdownLabel.element, g);\n          }), l(p, f, function () {\n            x(_this4.dropdownLabel.element, f);\n          }), l(p, \"change\", function () {\n            x(_this4.buttons[p.selectedIndex - 1].element, \"click\");\n          }), this.zoomText = r.label(o.rangeSelectorZoom || \"\", 0).attr({\n            padding: s.buttonTheme.padding,\n            height: s.buttonTheme.height,\n            paddingLeft: 0,\n            paddingRight: 0\n          }).add(this.buttonGroup), this.chart.styledMode || (this.zoomText.css(s.labelStyle), n[\"stroke-width\"] = v(n[\"stroke-width\"], 0)), h(\"option\", {\n            textContent: this.zoomText.textStr,\n            disabled: !0\n          }, void 0, p), this.buttonOptions.forEach(function (e, i) {\n            h(\"option\", {\n              textContent: e.title || e.text\n            }, void 0, p), t[i] = r.button(e.text, 0, 0, function (t) {\n              var s;\n              var o = e.events && e.events.click;\n              o && (s = o.call(e, t)), !1 !== s && _this4.clickButton(i), _this4.isActive = !0;\n            }, n, d && d.hover, d && d.select, d && d.disabled).attr({\n              \"text-align\": \"center\",\n              width: c\n            }).add(_this4.buttonGroup), e.title && t[i].attr(\"title\", e.title);\n          });\n        }\n      }, {\n        key: \"alignElements\",\n        value: function alignElements() {\n          var _this5 = this;\n          var t = this.buttonGroup,\n            e = this.buttons,\n            i = this.chart,\n            s = this.group,\n            o = this.inputGroup,\n            r = this.options,\n            n = this.zoomText,\n            a = i.options,\n            l = a.exporting && !1 !== a.exporting.enabled && a.navigation && a.navigation.buttonOptions,\n            h = r.buttonPosition,\n            d = r.inputPosition,\n            c = r.verticalAlign,\n            p = function p(t, e) {\n              return l && _this5.titleCollision(i) && \"top\" === c && \"right\" === e.align && e.y - t.getBBox().height - 12 < (l.y || 0) + (l.height || 0) + i.spacing[0] ? -40 : 0;\n            },\n            u = i.plotLeft;\n          if (s && h && d) {\n            var _a7 = h.x - i.spacing[3];\n            if (t) {\n              var _this$buttonGroup;\n              if (this.positionButtons(), !this.initialButtonGroupWidth) {\n                var _t20 = 0;\n                n && (_t20 += n.getBBox().width + 5), e.forEach(function (i, s) {\n                  _t20 += i.width || 0, s !== e.length - 1 && (_t20 += r.buttonSpacing);\n                }), this.initialButtonGroupWidth = _t20;\n              }\n              u -= i.spacing[3];\n              var _o8 = p(t, h);\n              this.alignButtonGroup(_o8), (_this$buttonGroup = this.buttonGroup) !== null && _this$buttonGroup !== void 0 && _this$buttonGroup.translateY && this.dropdownLabel.attr({\n                y: this.buttonGroup.translateY\n              }), s.placed = t.placed = i.hasLoaded;\n            }\n            var _l8 = 0;\n            o && (_l8 = p(o, d), \"left\" === d.align ? _a7 = u : \"right\" === d.align && (_a7 = -Math.max(i.axisOffset[1], -_l8)), o.align({\n              y: d.y,\n              width: o.getBBox().width,\n              align: d.align,\n              x: d.x + _a7 - 2\n            }, !0, i.spacingBox), o.placed = i.hasLoaded), this.handleCollision(_l8), s.align({\n              verticalAlign: c\n            }, !0, i.spacingBox);\n            var _g2 = s.alignAttr.translateY,\n              _x2 = s.getBBox().height + 20,\n              _f2 = 0;\n            if (\"bottom\" === c) {\n              var _t21 = i.legend && i.legend.options;\n              _f2 = _g2 - (_x2 = _x2 + (_t21 && \"bottom\" === _t21.verticalAlign && _t21.enabled && !_t21.floating ? i.legend.legendHeight + v(_t21.margin, 10) : 0) - 20) - (r.floating ? 0 : r.y) - (i.titleOffset ? i.titleOffset[2] : 0) - 10;\n            }\n            \"top\" === c ? (r.floating && (_f2 = 0), i.titleOffset && i.titleOffset[0] && (_f2 = i.titleOffset[0]), _f2 += i.margin[0] - i.spacing[0] || 0) : \"middle\" === c && (d.y === h.y ? _f2 = _g2 : (d.y || h.y) && (d.y < 0 || h.y < 0 ? _f2 -= Math.min(d.y, h.y) : _f2 = _g2 - _x2)), s.translate(r.x, r.y + Math.floor(_f2));\n            var _m2 = this.minInput,\n              _b2 = this.maxInput,\n              _y2 = this.dropdown;\n            r.inputEnabled && _m2 && _b2 && (_m2.style.marginTop = s.translateY + \"px\", _b2.style.marginTop = s.translateY + \"px\"), _y2 && (_y2.style.marginTop = s.translateY + \"px\");\n          }\n        }\n      }, {\n        key: \"alignButtonGroup\",\n        value: function alignButtonGroup(t, e) {\n          var i = this.chart,\n            s = this.options,\n            o = this.buttonGroup,\n            r = s.buttonPosition,\n            n = i.plotLeft - i.spacing[3],\n            a = r.x - i.spacing[3];\n          \"right\" === r.align ? a += t - n : \"center\" === r.align && (a -= n / 2), o && o.align({\n            y: r.y,\n            width: v(e, this.initialButtonGroupWidth),\n            align: r.align,\n            x: a\n          }, !0, i.spacingBox);\n        }\n      }, {\n        key: \"positionButtons\",\n        value: function positionButtons() {\n          var t = this.buttons,\n            e = this.chart,\n            i = this.options,\n            s = this.zoomText,\n            o = e.hasLoaded ? \"animate\" : \"attr\",\n            r = i.buttonPosition,\n            n = e.plotLeft,\n            a = n;\n          s && \"hidden\" !== s.visibility && (s[o]({\n            x: v(n + r.x, n)\n          }), a += r.x + s.getBBox().width + 5);\n          for (var _e16 = 0, _s5 = this.buttonOptions.length; _e16 < _s5; ++_e16) \"hidden\" !== t[_e16].visibility ? (t[_e16][o]({\n            x: a\n          }), a += (t[_e16].width || 0) + i.buttonSpacing) : t[_e16][o]({\n            x: n\n          });\n        }\n      }, {\n        key: \"handleCollision\",\n        value: function handleCollision(t) {\n          var _this6 = this;\n          var e = this.chart,\n            i = this.buttonGroup,\n            s = this.inputGroup,\n            _this$options2 = this.options,\n            o = _this$options2.buttonPosition,\n            r = _this$options2.dropdown,\n            n = _this$options2.inputPosition,\n            a = function a() {\n              var t = 0;\n              return _this6.buttons.forEach(function (e) {\n                var i = e.getBBox();\n                i.width > t && (t = i.width);\n              }), t;\n            },\n            l = function l(e) {\n              if (s !== null && s !== void 0 && s.alignOptions && i) {\n                var _r8 = s.alignAttr.translateX + s.alignOptions.x - t + s.getBBox().x + 2,\n                  _a8 = s.alignOptions.width || 0,\n                  _l9 = i.alignAttr.translateX + i.getBBox().x;\n                return _l9 + e > _r8 && _r8 + _a8 > _l9 && o.y < n.y + s.getBBox().height;\n              }\n              return !1;\n            },\n            h = function h() {\n              s && i && s.attr({\n                translateX: s.alignAttr.translateX + (e.axisOffset[1] >= -t ? 0 : -t),\n                translateY: s.alignAttr.translateY + i.getBBox().height + 10\n              });\n            };\n          if (i) {\n            if (\"always\" === r) {\n              this.collapseButtons(), l(a()) && h();\n              return;\n            }\n            \"never\" === r && this.expandButtons();\n          }\n          s && i ? n.align === o.align || l(this.initialButtonGroupWidth + 20) ? \"responsive\" === r ? (this.collapseButtons(), l(a()) && h()) : h() : \"responsive\" === r && this.expandButtons() : i && \"responsive\" === r && (this.initialButtonGroupWidth > e.plotWidth ? this.collapseButtons() : this.expandButtons());\n        }\n      }, {\n        key: \"collapseButtons\",\n        value: function collapseButtons() {\n          var t = this.buttons,\n            e = this.zoomText;\n          !0 !== this.isCollapsed && (this.isCollapsed = !0, e.hide(), t.forEach(function (t) {\n            return void t.hide();\n          }), this.showDropdown());\n        }\n      }, {\n        key: \"expandButtons\",\n        value: function expandButtons() {\n          var t = this.buttons,\n            e = this.zoomText;\n          !1 !== this.isCollapsed && (this.isCollapsed = !1, this.hideDropdown(), e.show(), t.forEach(function (t) {\n            return void t.show();\n          }), this.positionButtons());\n        }\n      }, {\n        key: \"showDropdown\",\n        value: function showDropdown() {\n          var t = this.buttonGroup,\n            e = this.chart,\n            i = this.dropdownLabel,\n            s = this.dropdown;\n          if (t && s) {\n            var _t$translateX = t.translateX,\n              _o9 = _t$translateX === void 0 ? 0 : _t$translateX,\n              _t$translateY = t.translateY,\n              _r9 = _t$translateY === void 0 ? 0 : _t$translateY,\n              _n7 = e.plotLeft + _o9;\n            i.attr({\n              x: _n7,\n              y: _r9\n            }).show(), d(s, {\n              left: _n7 + \"px\",\n              top: _r9 + \"px\",\n              visibility: \"inherit\"\n            }), this.hasVisibleDropdown = !0;\n          }\n        }\n      }, {\n        key: \"hideDropdown\",\n        value: function hideDropdown() {\n          var t = this.dropdown;\n          t && (this.dropdownLabel.hide(), d(t, {\n            visibility: \"hidden\",\n            width: \"1px\",\n            height: \"1px\"\n          }), this.hasVisibleDropdown = !1);\n        }\n      }, {\n        key: \"getHeight\",\n        value: function getHeight() {\n          var t = this.options,\n            e = this.group,\n            i = t.inputPosition,\n            s = t.buttonPosition,\n            o = t.y,\n            r = s.y,\n            n = i.y,\n            a = 0;\n          if (t.height) return t.height;\n          this.alignElements(), a = e ? e.getBBox(!0).height + 13 + o : 0;\n          var l = Math.min(n, r);\n          return (n < 0 && r < 0 || n > 0 && r > 0) && (a += Math.abs(l)), a;\n        }\n      }, {\n        key: \"titleCollision\",\n        value: function titleCollision(t) {\n          return !(t.options.title.text || t.options.subtitle.text);\n        }\n      }, {\n        key: \"update\",\n        value: function update(t) {\n          var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !0;\n          var i = this.chart;\n          m(!0, i.options.rangeSelector, t), this.destroy(), this.init(i), e && this.render();\n        }\n      }, {\n        key: \"destroy\",\n        value: function destroy() {\n          var t = this,\n            e = t.minInput,\n            i = t.maxInput;\n          t.eventsToUnbind && (t.eventsToUnbind.forEach(function (t) {\n            return t();\n          }), t.eventsToUnbind = void 0), p(t.buttons), e && (e.onfocus = e.onblur = e.onchange = null), i && (i.onfocus = i.onblur = i.onchange = null), b(t, function (e, i) {\n            e && \"chart\" !== i && (e instanceof o ? e.destroy() : e instanceof window.HTMLElement && u(e)), e !== A.prototype[i] && (t[i] = null);\n          }, this);\n        }\n      }], [{\n        key: \"compose\",\n        value: function compose(t, e) {\n          s.compose(t, e, A);\n        }\n      }]);\n    }();\n    return g(A.prototype, {\n      defaultButtons: [{\n        type: \"month\",\n        count: 1,\n        text: \"1m\",\n        title: \"View 1 month\"\n      }, {\n        type: \"month\",\n        count: 3,\n        text: \"3m\",\n        title: \"View 3 months\"\n      }, {\n        type: \"month\",\n        count: 6,\n        text: \"6m\",\n        title: \"View 6 months\"\n      }, {\n        type: \"ytd\",\n        text: \"YTD\",\n        title: \"View year to date\"\n      }, {\n        type: \"year\",\n        count: 1,\n        text: \"1y\",\n        title: \"View 1 year\"\n      }, {\n        type: \"all\",\n        text: \"All\",\n        title: \"View all\"\n      }],\n      inputTypeFormats: {\n        \"datetime-local\": \"%Y-%m-%dT%H:%M:%S\",\n        date: \"%Y-%m-%d\",\n        time: \"%H:%M:%S\"\n      }\n    }), A;\n  }), i(e, \"Series/PathUtilities.js\", [], function () {\n    function t(t, e) {\n      var i = [];\n      for (var s = 0; s < t.length; s++) {\n        var o = t[s][1],\n          r = t[s][2];\n        if (\"number\" == typeof o && \"number\" == typeof r) {\n          if (0 === s) i.push([\"M\", o, r]);else if (s === t.length - 1) i.push([\"L\", o, r]);else if (e) {\n            var n = t[s - 1],\n              a = t[s + 1];\n            if (n && a) {\n              var _t22 = n[1],\n                _s6 = n[2],\n                l = a[1],\n                h = a[2];\n              if (\"number\" == typeof _t22 && \"number\" == typeof l && \"number\" == typeof _s6 && \"number\" == typeof h && _t22 !== l && _s6 !== h) {\n                var _n8 = _t22 < l ? 1 : -1,\n                  _a9 = _s6 < h ? 1 : -1;\n                i.push([\"L\", o - _n8 * Math.min(Math.abs(o - _t22), e), r - _a9 * Math.min(Math.abs(r - _s6), e)], [\"C\", o, r, o, r, o + _n8 * Math.min(Math.abs(o - l), e), r + _a9 * Math.min(Math.abs(r - h), e)]);\n              }\n            }\n          } else i.push([\"L\", o, r]);\n        }\n      }\n      return i;\n    }\n    return {\n      applyRadius: t,\n      getLinkPath: {\n        \"default\": function _default(e) {\n          var i = e.x1,\n            s = e.y1,\n            o = e.x2,\n            r = e.y2,\n            _e$width2 = e.width,\n            n = _e$width2 === void 0 ? 0 : _e$width2,\n            _e$inverted = e.inverted,\n            a = _e$inverted === void 0 ? !1 : _e$inverted,\n            l = e.radius,\n            h = e.parentVisible,\n            d = [[\"M\", i, s], [\"L\", i, s], [\"C\", i, s, i, r, i, r], [\"L\", i, r], [\"C\", i, s, i, r, i, r], [\"L\", i, r]];\n          return h ? t([[\"M\", i, s], [\"L\", i + n * (a ? -.5 : .5), s], [\"L\", i + n * (a ? -.5 : .5), r], [\"L\", o, r]], l) : d;\n        },\n        straight: function straight(t) {\n          var e = t.x1,\n            i = t.y1,\n            s = t.x2,\n            o = t.y2,\n            _t$width = t.width,\n            r = _t$width === void 0 ? 0 : _t$width,\n            _t$inverted = t.inverted,\n            n = _t$inverted === void 0 ? !1 : _t$inverted,\n            a = t.parentVisible;\n          return a ? [[\"M\", e, i], [\"L\", e + r * (n ? -1 : 1), o], [\"L\", s, o]] : [[\"M\", e, i], [\"L\", e, o], [\"L\", e, o]];\n        },\n        curved: function curved(t) {\n          var e = t.x1,\n            i = t.y1,\n            s = t.x2,\n            o = t.y2,\n            _t$offset = t.offset,\n            r = _t$offset === void 0 ? 0 : _t$offset,\n            _t$width2 = t.width,\n            n = _t$width2 === void 0 ? 0 : _t$width2,\n            _t$inverted2 = t.inverted,\n            a = _t$inverted2 === void 0 ? !1 : _t$inverted2,\n            l = t.parentVisible;\n          return l ? [[\"M\", e, i], [\"C\", e + r, i, e - r + n * (a ? -1 : 1), o, e + n * (a ? -1 : 1), o], [\"L\", s, o]] : [[\"M\", e, i], [\"C\", e, i, e, o, e, o], [\"L\", s, o]];\n        }\n      }\n    };\n  }), i(e, \"Gantt/PathfinderAlgorithms.js\", [e[\"Series/PathUtilities.js\"], e[\"Core/Utilities.js\"]], function (t, e) {\n    var i = e.pick,\n      s = Math.min,\n      o = Math.max,\n      r = Math.abs;\n    function n(t, e, i) {\n      var s = e - 1e-7,\n        o = i || 0,\n        r = t.length - 1,\n        n,\n        a;\n      for (; o <= r;) if ((a = s - t[n = r + o >> 1].xMin) > 0) o = n + 1;else {\n        if (!(a < 0)) return n;\n        r = n - 1;\n      }\n      return o > 0 ? o - 1 : 0;\n    }\n    function a(t, e) {\n      var i = n(t, e.x + 1) + 1;\n      for (; i--;) {\n        var s;\n        if (t[i].xMax >= e.x && (s = t[i], e.x <= s.xMax && e.x >= s.xMin && e.y <= s.yMax && e.y >= s.yMin)) return i;\n      }\n      return -1;\n    }\n    function l(t) {\n      var e = [];\n      if (t.length) {\n        e.push([\"M\", t[0].start.x, t[0].start.y]);\n        for (var _i15 = 0; _i15 < t.length; ++_i15) e.push([\"L\", t[_i15].end.x, t[_i15].end.y]);\n      }\n      return e;\n    }\n    function h(t, e) {\n      t.yMin = o(t.yMin, e.yMin), t.yMax = s(t.yMax, e.yMax), t.xMin = o(t.xMin, e.xMin), t.xMax = s(t.xMax, e.xMax);\n    }\n    var d = function d(e, s, o) {\n      var n = [],\n        h = o.chartObstacles,\n        d = a(h, e),\n        c = a(h, s),\n        p,\n        u = i(o.startDirectionX, r(s.x - e.x) > r(s.y - e.y)) ? \"x\" : \"y\",\n        g,\n        x,\n        f,\n        m;\n      function b(t, e, i, s, o) {\n        var r = {\n          x: t.x,\n          y: t.y\n        };\n        return r[e] = i[s || e] + (o || 0), r;\n      }\n      function y(t, e, i) {\n        var s = r(e[i] - t[i + \"Min\"]) > r(e[i] - t[i + \"Max\"]);\n        return b(e, i, t, i + (s ? \"Max\" : \"Min\"), s ? 1 : -1);\n      }\n      c > -1 ? (p = {\n        start: x = y(h[c], s, u),\n        end: s\n      }, m = x) : m = s, d > -1 && (x = y(g = h[d], e, u), n.push({\n        start: e,\n        end: x\n      }), x[u] >= e[u] == x[u] >= m[u] && (f = e[u = \"y\" === u ? \"x\" : \"y\"] < s[u], n.push({\n        start: x,\n        end: b(x, u, g, u + (f ? \"Max\" : \"Min\"), f ? 1 : -1)\n      }), u = \"y\" === u ? \"x\" : \"y\"));\n      var v = n.length ? n[n.length - 1].end : e;\n      x = b(v, u, m), n.push({\n        start: v,\n        end: x\n      });\n      var M = b(x, u = \"y\" === u ? \"x\" : \"y\", m);\n      return n.push({\n        start: x,\n        end: M\n      }), n.push(p), {\n        path: t.applyRadius(l(n), o.radius),\n        obstacles: n\n      };\n    };\n    function c(t, e, d) {\n      var c = i(d.startDirectionX, r(e.x - t.x) > r(e.y - t.y)),\n        p = c ? \"x\" : \"y\",\n        u = [],\n        g = d.obstacleMetrics,\n        x = s(t.x, e.x) - g.maxWidth - 10,\n        f = o(t.x, e.x) + g.maxWidth + 10,\n        m = s(t.y, e.y) - g.maxHeight - 10,\n        b = o(t.y, e.y) + g.maxHeight + 10,\n        y,\n        v,\n        M,\n        k = !1,\n        A = d.chartObstacles,\n        S = n(A, f),\n        C = n(A, x);\n      function w(t, e, i) {\n        var o, r, a, l;\n        var h = t.x < e.x ? 1 : -1;\n        t.x < e.x ? (o = t, r = e) : (o = e, r = t), t.y < e.y ? (l = t, a = e) : (l = e, a = t);\n        var d = h < 0 ? s(n(A, r.x), A.length - 1) : 0;\n        for (; A[d] && (h > 0 && A[d].xMin <= r.x || h < 0 && A[d].xMax >= o.x);) {\n          if (A[d].xMin <= r.x && A[d].xMax >= o.x && A[d].yMin <= a.y && A[d].yMax >= l.y) {\n            if (i) return {\n              y: t.y,\n              x: t.x < e.x ? A[d].xMin - 1 : A[d].xMax + 1,\n              obstacle: A[d]\n            };\n            return {\n              x: t.x,\n              y: t.y < e.y ? A[d].yMin - 1 : A[d].yMax + 1,\n              obstacle: A[d]\n            };\n          }\n          d += h;\n        }\n        return e;\n      }\n      function P(t, e, i, s, o) {\n        var n = o.soft,\n          a = o.hard,\n          l = s ? \"x\" : \"y\",\n          h = {\n            x: e.x,\n            y: e.y\n          },\n          d = {\n            x: e.x,\n            y: e.y\n          },\n          c = t[l + \"Max\"] >= n[l + \"Max\"],\n          p = t[l + \"Min\"] <= n[l + \"Min\"],\n          u = t[l + \"Max\"] >= a[l + \"Max\"],\n          g = t[l + \"Min\"] <= a[l + \"Min\"],\n          x = r(t[l + \"Min\"] - e[l]),\n          f = r(t[l + \"Max\"] - e[l]),\n          m = 10 > r(x - f) ? e[l] < i[l] : f < x;\n        d[l] = t[l + \"Min\"], h[l] = t[l + \"Max\"];\n        var b = w(e, d, s)[l] !== d[l],\n          y = w(e, h, s)[l] !== h[l];\n        return m = b ? !y || m : !y && m, m = p ? !c || m : !c && m, m = g ? !u || m : !u && m;\n      }\n      for ((S = a(A = A.slice(C, S + 1), e)) > -1 && (M = function (t, e, i) {\n        var o = s(t.xMax - e.x, e.x - t.xMin) < s(t.yMax - e.y, e.y - t.yMin),\n          r = P(t, e, i, o, {\n            soft: d.hardBounds,\n            hard: d.hardBounds\n          });\n        return o ? {\n          y: e.y,\n          x: t[r ? \"xMax\" : \"xMin\"] + (r ? 1 : -1)\n        } : {\n          x: e.x,\n          y: t[r ? \"yMax\" : \"yMin\"] + (r ? 1 : -1)\n        };\n      }(A[S], e, t), u.push({\n        end: e,\n        start: M\n      }), e = M); (S = a(A, e)) > -1;) v = e[p] - t[p] < 0, (M = {\n        x: e.x,\n        y: e.y\n      })[p] = A[S][v ? p + \"Max\" : p + \"Min\"] + (v ? 1 : -1), u.push({\n        end: e,\n        start: M\n      }), e = M;\n      return {\n        path: l(y = (y = function t(e, i, r) {\n          var n, l, c, p, u, g, y;\n          if (e.x === i.x && e.y === i.y) return [];\n          var v = r ? \"x\" : \"y\",\n            M = d.obstacleOptions.margin,\n            S = {\n              soft: {\n                xMin: x,\n                xMax: f,\n                yMin: m,\n                yMax: b\n              },\n              hard: d.hardBounds\n            };\n          return (u = a(A, e)) > -1 ? (p = P(u = A[u], e, i, r, S), h(u, d.hardBounds), y = r ? {\n            y: e.y,\n            x: u[p ? \"xMax\" : \"xMin\"] + (p ? 1 : -1)\n          } : {\n            x: e.x,\n            y: u[p ? \"yMax\" : \"yMin\"] + (p ? 1 : -1)\n          }, (g = a(A, y)) > -1 && (h(g = A[g], d.hardBounds), y[v] = p ? o(u[v + \"Max\"] - M + 1, (g[v + \"Min\"] + u[v + \"Max\"]) / 2) : s(u[v + \"Min\"] + M - 1, (g[v + \"Max\"] + u[v + \"Min\"]) / 2), e.x === y.x && e.y === y.y ? (k && (y[v] = p ? o(u[v + \"Max\"], g[v + \"Max\"]) + 1 : s(u[v + \"Min\"], g[v + \"Min\"]) - 1), k = !k) : k = !1), l = [{\n            start: e,\n            end: y\n          }]) : (n = w(e, {\n            x: r ? i.x : e.x,\n            y: r ? e.y : i.y\n          }, r), l = [{\n            start: e,\n            end: {\n              x: n.x,\n              y: n.y\n            }\n          }], n[r ? \"x\" : \"y\"] !== i[r ? \"x\" : \"y\"] && (p = P(n.obstacle, n, i, !r, S), h(n.obstacle, d.hardBounds), c = {\n            x: r ? n.x : n.obstacle[p ? \"xMax\" : \"xMin\"] + (p ? 1 : -1),\n            y: r ? n.obstacle[p ? \"yMax\" : \"yMin\"] + (p ? 1 : -1) : n.y\n          }, r = !r, l = l.concat(t({\n            x: n.x,\n            y: n.y\n          }, c, r)))), l = l.concat(t(l[l.length - 1].end, i, !r));\n        }(t, e, c)).concat(u.reverse())),\n        obstacles: y\n      };\n    }\n    return d.requiresObstacles = !0, c.requiresObstacles = !0, {\n      fastAvoid: c,\n      straight: function straight(t, e) {\n        return {\n          path: [[\"M\", t.x, t.y], [\"L\", e.x, e.y]],\n          obstacles: [{\n            start: t,\n            end: e\n          }]\n        };\n      },\n      simpleConnect: d\n    };\n  }), i(e, \"Gantt/ConnectorsDefaults.js\", [], function () {\n    return {\n      connectors: {\n        type: \"straight\",\n        radius: 0,\n        lineWidth: 1,\n        marker: {\n          enabled: !1,\n          align: \"center\",\n          verticalAlign: \"middle\",\n          inside: !1,\n          lineWidth: 1\n        },\n        startMarker: {\n          symbol: \"diamond\"\n        },\n        endMarker: {\n          symbol: \"arrow-filled\"\n        }\n      }\n    };\n  }), i(e, \"Gantt/PathfinderComposition.js\", [e[\"Gantt/ConnectorsDefaults.js\"], e[\"Core/Defaults.js\"], e[\"Core/Utilities.js\"]], function (t, e, i) {\n    var s;\n    var o = e.setOptions,\n      r = i.defined,\n      n = i.error,\n      a = i.merge;\n    function l(t) {\n      var e = t.shapeArgs;\n      if (e) return {\n        xMin: e.x || 0,\n        xMax: (e.x || 0) + (e.width || 0),\n        yMin: e.y || 0,\n        yMax: (e.y || 0) + (e.height || 0)\n      };\n      var i = t.graphic && t.graphic.getBBox();\n      return i ? {\n        xMin: t.plotX - i.width / 2,\n        xMax: t.plotX + i.width / 2,\n        yMin: t.plotY - i.height / 2,\n        yMax: t.plotY + i.height / 2\n      } : null;\n    }\n    return function (e) {\n      function i(t) {\n        var e, i;\n        var s = l(this);\n        switch (t.align) {\n          case \"right\":\n            e = \"xMax\";\n            break;\n          case \"left\":\n            e = \"xMin\";\n        }\n        switch (t.verticalAlign) {\n          case \"top\":\n            i = \"yMin\";\n            break;\n          case \"bottom\":\n            i = \"yMax\";\n        }\n        return {\n          x: e ? s[e] : (s.xMin + s.xMax) / 2,\n          y: i ? s[i] : (s.yMin + s.yMax) / 2\n        };\n      }\n      function s(t, e) {\n        var i;\n        return !r(e) && (i = l(this)) && (e = {\n          x: (i.xMin + i.xMax) / 2,\n          y: (i.yMin + i.yMax) / 2\n        }), Math.atan2(e.y - t.y, t.x - e.x);\n      }\n      function h(t, e, i) {\n        var s = 2 * Math.PI,\n          o = l(this),\n          r = o.xMax - o.xMin,\n          n = o.yMax - o.yMin,\n          a = Math.atan2(n, r),\n          h = r / 2,\n          d = n / 2,\n          c = o.xMin + h,\n          p = o.yMin + d,\n          u = {\n            x: c,\n            y: p\n          },\n          g = t,\n          x = 1,\n          f = !1,\n          m = 1,\n          b = 1;\n        for (; g < -Math.PI;) g += s;\n        for (; g > Math.PI;) g -= s;\n        return x = Math.tan(g), g > -a && g <= a ? (b = -1, f = !0) : g > a && g <= Math.PI - a ? b = -1 : g > Math.PI - a || g <= -(Math.PI - a) ? (m = -1, f = !0) : m = -1, f ? (u.x += m * h, u.y += b * h * x) : (u.x += n / (2 * x) * m, u.y += b * d), i.x !== c && (u.x = i.x), i.y !== p && (u.y = i.y), {\n          x: u.x + e * Math.cos(g),\n          y: u.y - e * Math.sin(g)\n        };\n      }\n      e.compose = function (e, r, l) {\n        var d = l.prototype;\n        d.getPathfinderAnchorPoint || (e.prototype.callbacks.push(function (t) {\n          !1 !== t.options.connectors.enabled && ((t.options.pathfinder || t.series.reduce(function (t, e) {\n            return e.options && a(!0, e.options.connectors = e.options.connectors || {}, e.options.pathfinder), t || e.options && e.options.pathfinder;\n          }, !1)) && (a(!0, t.options.connectors = t.options.connectors || {}, t.options.pathfinder), n('WARNING: Pathfinder options have been renamed. Use \"chart.connectors\" or \"series.connectors\" instead.')), this.pathfinder = new r(this), this.pathfinder.update(!0));\n        }), d.getMarkerVector = h, d.getPathfinderAnchorPoint = i, d.getRadiansToVector = s, o(t));\n      };\n    }(s || (s = {})), s;\n  }), i(e, \"Gantt/Pathfinder.js\", [e[\"Gantt/Connection.js\"], e[\"Gantt/PathfinderAlgorithms.js\"], e[\"Gantt/PathfinderComposition.js\"], e[\"Core/Series/Point.js\"], e[\"Core/Utilities.js\"]], function (t, e, i, s, o) {\n    var r = o.addEvent,\n      n = o.defined,\n      a = o.pick,\n      l = o.splat,\n      h = Math.max,\n      d = Math.min;\n    var c = /*#__PURE__*/function () {\n      function c(t) {\n        _classCallCheck(this, c);\n        this.init(t);\n      }\n      return _createClass(c, [{\n        key: \"init\",\n        value: function init(t) {\n          this.chart = t, this.connections = [], r(t, \"redraw\", function () {\n            this.pathfinder.update();\n          });\n        }\n      }, {\n        key: \"update\",\n        value: function update(e) {\n          var i = this.chart,\n            o = this,\n            r = o.connections;\n          o.connections = [], i.series.forEach(function (e) {\n            e.visible && !e.options.isInternal && e.points.forEach(function (e) {\n              var _e$options;\n              var r;\n              var n = e.options;\n              n && n.dependency && (n.connect = n.dependency);\n              var a = ((_e$options = e.options) === null || _e$options === void 0 ? void 0 : _e$options.connect) && l(e.options.connect);\n              e.visible && !1 !== e.isInside && a && a.forEach(function (n) {\n                (r = i.get(\"string\" == typeof n ? n : n.to)) instanceof s && r.series.visible && r.visible && !1 !== r.isInside && o.connections.push(new t(e, r, \"string\" == typeof n ? {} : n));\n              });\n            });\n          });\n          for (var _t23 = 0, _e17, _i16, _s7 = r.length, _n9 = o.connections.length; _t23 < _s7; ++_t23) {\n            _i16 = !1;\n            var _s8 = r[_t23];\n            for (_e17 = 0; _e17 < _n9; ++_e17) {\n              var _t24 = o.connections[_e17];\n              if ((_s8.options && _s8.options.type) === (_t24.options && _t24.options.type) && _s8.fromPoint === _t24.fromPoint && _s8.toPoint === _t24.toPoint) {\n                _t24.graphics = _s8.graphics, _i16 = !0;\n                break;\n              }\n            }\n            _i16 || _s8.destroy();\n          }\n          delete this.chartObstacles, delete this.lineObstacles, o.renderConnections(e);\n        }\n      }, {\n        key: \"renderConnections\",\n        value: function renderConnections(t) {\n          t ? this.chart.series.forEach(function (t) {\n            var e = function e() {\n              var e = t.chart.pathfinder;\n              (e && e.connections || []).forEach(function (e) {\n                e.fromPoint && e.fromPoint.series === t && e.render();\n              }), t.pathfinderRemoveRenderEvent && (t.pathfinderRemoveRenderEvent(), delete t.pathfinderRemoveRenderEvent);\n            };\n            !1 === t.options.animation ? e() : t.pathfinderRemoveRenderEvent = r(t, \"afterAnimate\", e);\n          }) : this.connections.forEach(function (t) {\n            t.render();\n          });\n        }\n      }, {\n        key: \"getChartObstacles\",\n        value: function getChartObstacles(t) {\n          var e = this.chart.series,\n            i = a(t.algorithmMargin, 0),\n            s = [],\n            o;\n          for (var _t25 = 0, _o10 = e.length; _t25 < _o10; ++_t25) if (e[_t25].visible && !e[_t25].options.isInternal) for (var _o11 = 0, _r10 = e[_t25].points.length, _n10, _a10; _o11 < _r10; ++_o11) (_a10 = e[_t25].points[_o11]).visible && (_n10 = function (t) {\n            var e = t.shapeArgs;\n            if (e) return {\n              xMin: e.x || 0,\n              xMax: (e.x || 0) + (e.width || 0),\n              yMin: e.y || 0,\n              yMax: (e.y || 0) + (e.height || 0)\n            };\n            var i = t.graphic && t.graphic.getBBox();\n            return i ? {\n              xMin: t.plotX - i.width / 2,\n              xMax: t.plotX + i.width / 2,\n              yMin: t.plotY - i.height / 2,\n              yMax: t.plotY + i.height / 2\n            } : null;\n          }(_a10)) && s.push({\n            xMin: _n10.xMin - i,\n            xMax: _n10.xMax + i,\n            yMin: _n10.yMin - i,\n            yMax: _n10.yMax + i\n          });\n          return s = s.sort(function (t, e) {\n            return t.xMin - e.xMin;\n          }), n(t.algorithmMargin) || (o = t.algorithmMargin = function (t) {\n            var e;\n            var i = t.length,\n              s = [];\n            for (var _o12 = 0; _o12 < i; ++_o12) for (var _r11 = _o12 + 1; _r11 < i; ++_r11) (e = function t(e, i, s) {\n              var o = a(s, 10),\n                r = e.yMax + o > i.yMin - o && e.yMin - o < i.yMax + o,\n                n = e.xMax + o > i.xMin - o && e.xMin - o < i.xMax + o,\n                l = r ? e.xMin > i.xMax ? e.xMin - i.xMax : i.xMin - e.xMax : 1 / 0,\n                h = n ? e.yMin > i.yMax ? e.yMin - i.yMax : i.yMin - e.yMax : 1 / 0;\n              return n && r ? o ? t(e, i, Math.floor(o / 2)) : 1 / 0 : d(l, h);\n            }(t[_o12], t[_r11])) < 80 && s.push(e);\n            return s.push(80), h(Math.floor(s.sort(function (t, e) {\n              return t - e;\n            })[Math.floor(s.length / 10)] / 2 - 1), 1);\n          }(s), s.forEach(function (t) {\n            t.xMin -= o, t.xMax += o, t.yMin -= o, t.yMax += o;\n          })), s;\n        }\n      }, {\n        key: \"getObstacleMetrics\",\n        value: function getObstacleMetrics(t) {\n          var e = 0,\n            i = 0,\n            s,\n            o,\n            r = t.length;\n          for (; r--;) s = t[r].xMax - t[r].xMin, o = t[r].yMax - t[r].yMin, e < s && (e = s), i < o && (i = o);\n          return {\n            maxHeight: i,\n            maxWidth: e\n          };\n        }\n      }, {\n        key: \"getAlgorithmStartDirection\",\n        value: function getAlgorithmStartDirection(t) {\n          var e = \"left\" !== t.align && \"right\" !== t.align,\n            i = \"top\" !== t.verticalAlign && \"bottom\" !== t.verticalAlign;\n          return e ? !!i && void 0 : !!i || void 0;\n        }\n      }], [{\n        key: \"compose\",\n        value: function compose(t, e) {\n          i.compose(t, c, e);\n        }\n      }]);\n    }();\n    return c.prototype.algorithms = e, c;\n  }), i(e, \"masters/modules/pathfinder.src.js\", [e[\"Core/Globals.js\"], e[\"Gantt/Pathfinder.js\"], e[\"Extensions/ArrowSymbols.js\"]], function (t, e, i) {\n    return t.Pathfinder = t.Pathfinder || e, i.compose(t.SVGRenderer), t.Pathfinder.compose(t.Chart, t.Point), t;\n  }), i(e, \"Extensions/StaticScale.js\", [e[\"Core/Utilities.js\"]], function (t) {\n    var e = t.addEvent,\n      i = t.defined,\n      s = t.isNumber,\n      o = t.pick;\n    function r() {\n      var t = this.chart.options.chart;\n      !this.horiz && s(this.options.staticScale) && (!t.height || t.scrollablePlotArea && t.scrollablePlotArea.minHeight) && (this.staticScale = this.options.staticScale);\n    }\n    function n() {\n      if (\"adjustHeight\" !== this.redrawTrigger) {\n        var _iterator = _createForOfIteratorHelper(this.axes || []),\n          _step;\n        try {\n          var _loop = function _loop() {\n            var t = _step.value;\n            var e = t.chart,\n              s = !!e.initiatedScale && e.options.animation,\n              r = t.options.staticScale;\n            if (t.staticScale && i(t.min)) {\n              var _i17 = o(t.brokenAxis && t.brokenAxis.unitLength, t.max + t.tickInterval - t.min) * r,\n                _n11 = (_i17 = Math.max(_i17, r)) - e.plotHeight;\n              !e.scrollablePixelsY && Math.abs(_n11) >= 1 && (e.plotHeight = _i17, e.redrawTrigger = \"adjustHeight\", e.setSize(void 0, e.chartHeight + _n11, s)), t.series.forEach(function (t) {\n                var i = t.sharedClipKey && e.sharedClips[t.sharedClipKey];\n                i && i.attr(e.inverted ? {\n                  width: e.plotHeight\n                } : {\n                  height: e.plotHeight\n                });\n              });\n            }\n          };\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            _loop();\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n        this.initiatedScale = !0;\n      }\n      this.redrawTrigger = null;\n    }\n    return {\n      compose: function compose(t, i) {\n        var s = i.prototype;\n        s.adjustHeight || (e(t, \"afterSetOptions\", r), s.adjustHeight = n, e(i, \"render\", s.adjustHeight));\n      }\n    };\n  }), i(e, \"masters/modules/static-scale.src.js\", [e[\"Core/Globals.js\"], e[\"Extensions/StaticScale.js\"]], function (t, e) {\n    return e.compose(t.Axis, t.Chart), t;\n  }), i(e, \"Series/XRange/XRangeSeriesDefaults.js\", [e[\"Core/Utilities.js\"]], function (t) {\n    var e = t.correctFloat,\n      i = t.isNumber,\n      s = t.isObject;\n    return {\n      colorByPoint: !0,\n      dataLabels: {\n        formatter: function formatter() {\n          var t = this.point.partialFill;\n          if (s(t) && (t = t.amount), i(t) && t > 0) return e(100 * t) + \"%\";\n        },\n        inside: !0,\n        verticalAlign: \"middle\",\n        style: {\n          whiteSpace: \"nowrap\"\n        }\n      },\n      tooltip: {\n        headerFormat: '<span style=\"font-size: 0.8em\">{point.x} - {point.x2}</span><br/>',\n        pointFormat: '<span style=\"color:{point.color}\">‚óè</span> {series.name}: <b>{point.yCategory}</b><br/>'\n      },\n      borderRadius: 3,\n      pointRange: 0\n    };\n  }), i(e, \"Series/XRange/XRangePoint.js\", [e[\"Core/Series/SeriesRegistry.js\"], e[\"Core/Utilities.js\"]], function (t, e) {\n    var i = t.seriesTypes.column.prototype.pointClass,\n      s = e.extend;\n    var o = /*#__PURE__*/function (_i18) {\n      function o(t, e) {\n        var _this7;\n        _classCallCheck(this, o);\n        _this7 = _callSuper(this, o, [t, e]), _this7.y || (_this7.y = 0);\n        return _this7;\n      }\n      _inherits(o, _i18);\n      return _createClass(o, [{\n        key: \"resolveColor\",\n        value: function resolveColor() {\n          var t = this.series;\n          if (t.options.colorByPoint && !this.options.color) {\n            var _e18 = o.getColorByCategory(t, this);\n            t.chart.styledMode || (this.color = _e18.color), this.options.colorIndex || (this.colorIndex = _e18.colorIndex);\n          } else this.color = this.options.color || t.color;\n        }\n      }, {\n        key: \"setState\",\n        value: function setState() {\n          _superPropGet(o, \"setState\", this, 1).apply(this, arguments), this.series.drawPoint(this, this.series.getAnimationVerb());\n        }\n      }, {\n        key: \"getLabelConfig\",\n        value: function getLabelConfig() {\n          var t = _superPropGet(o, \"getLabelConfig\", this, 1).call(this),\n            e = this.series.yAxis.categories;\n          return t.x2 = this.x2, t.yCategory = this.yCategory = e && e[this.y], t.key = this.category || this.name, t;\n        }\n      }, {\n        key: \"isValid\",\n        value: function isValid() {\n          return \"number\" == typeof this.x && \"number\" == typeof this.x2;\n        }\n      }], [{\n        key: \"getColorByCategory\",\n        value: function getColorByCategory(t, e) {\n          var i = t.options.colors || t.chart.options.colors,\n            s = i ? i.length : t.chart.options.chart.colorCount,\n            _o13 = e.y % s,\n            r = i && i[_o13];\n          return {\n            colorIndex: _o13,\n            color: r\n          };\n        }\n      }]);\n    }(i);\n    return s(o.prototype, {\n      ttBelow: !1,\n      tooltipDateKeys: [\"x\", \"x2\"]\n    }), o;\n  }), i(e, \"Series/XRange/XRangeSeries.js\", [e[\"Core/Globals.js\"], e[\"Core/Color/Color.js\"], e[\"Core/Series/SeriesRegistry.js\"], e[\"Core/Utilities.js\"], e[\"Series/XRange/XRangeSeriesDefaults.js\"], e[\"Series/XRange/XRangePoint.js\"]], function (t, e, i, s, o, r) {\n    var n = t.composed,\n      a = t.noop,\n      l = e.parse,\n      h = i.seriesTypes.column,\n      d = s.addEvent,\n      c = s.clamp,\n      p = s.crisp,\n      u = s.defined,\n      g = s.extend,\n      x = s.find,\n      f = s.isNumber,\n      m = s.isObject,\n      b = s.merge,\n      y = s.pick,\n      v = s.pushUnique,\n      M = s.relativeLength;\n    function k() {\n      var t, e;\n      if (this.isXAxis) {\n        var _iterator2 = _createForOfIteratorHelper((t = y(this.dataMax, -Number.MAX_VALUE), this.series)),\n          _step2;\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var _i19 = _step2.value;\n            if (_i19.x2Data) {\n              var _iterator3 = _createForOfIteratorHelper(_i19.x2Data),\n                _step3;\n              try {\n                for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n                  var _s9 = _step3.value;\n                  _s9 && _s9 > t && (t = _s9, e = !0);\n                }\n              } catch (err) {\n                _iterator3.e(err);\n              } finally {\n                _iterator3.f();\n              }\n            }\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n        e && (this.dataMax = t);\n      }\n    }\n    var A = /*#__PURE__*/function (_h3) {\n      function A() {\n        _classCallCheck(this, A);\n        return _callSuper(this, A, arguments);\n      }\n      _inherits(A, _h3);\n      return _createClass(A, [{\n        key: \"init\",\n        value: function init() {\n          _superPropGet(A, \"init\", this, 1).apply(this, arguments), this.options.stacking = void 0;\n        }\n      }, {\n        key: \"getColumnMetrics\",\n        value: function getColumnMetrics() {\n          var _this8 = this;\n          var t = function t() {\n            var _iterator4 = _createForOfIteratorHelper(_this8.chart.series),\n              _step4;\n            try {\n              for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n                var _t26 = _step4.value;\n                var _e19 = _t26.xAxis;\n                _t26.xAxis = _t26.yAxis, _t26.yAxis = _e19;\n              }\n            } catch (err) {\n              _iterator4.e(err);\n            } finally {\n              _iterator4.f();\n            }\n          };\n          t();\n          var e = _superPropGet(A, \"getColumnMetrics\", this, 3)([]);\n          return t(), e;\n        }\n      }, {\n        key: \"cropData\",\n        value: function cropData(t, e, i, s) {\n          var o = _superPropGet(A, \"cropData\", this, 3)([this.x2Data, e, i, s]);\n          return o.xData = t.slice(o.start, o.end), o;\n        }\n      }, {\n        key: \"findPointIndex\",\n        value: function findPointIndex(t) {\n          var e;\n          var i = this.cropStart,\n            s = this.points,\n            o = t.id;\n          if (o) {\n            var _t27 = x(s, function (t) {\n              return t.id === o;\n            });\n            e = _t27 ? _t27.index : void 0;\n          }\n          if (void 0 === e) {\n            var _i20 = x(s, function (e) {\n              return e.x === t.x && e.x2 === t.x2 && !e.touched;\n            });\n            e = _i20 ? _i20.index : void 0;\n          }\n          return this.cropped && f(e) && f(i) && e >= i && (e -= i), e;\n        }\n      }, {\n        key: \"alignDataLabel\",\n        value: function alignDataLabel(t) {\n          var _t$shapeArgs;\n          var e = t.plotX;\n          t.plotX = y(t.dlBox && t.dlBox.centerX, t.plotX), t.dataLabel && (_t$shapeArgs = t.shapeArgs) !== null && _t$shapeArgs !== void 0 && _t$shapeArgs.width && t.dataLabel.css({\n            width: \"\".concat(t.shapeArgs.width, \"px\")\n          }), _superPropGet(A, \"alignDataLabel\", this, 1).apply(this, arguments), t.plotX = e;\n        }\n      }, {\n        key: \"translatePoint\",\n        value: function translatePoint(t) {\n          var e = this.xAxis,\n            i = this.yAxis,\n            s = this.columnMetrics,\n            o = this.options,\n            r = o.minPointLength || 0,\n            n = (t.shapeArgs && t.shapeArgs.width || 0) / 2,\n            a = this.pointXOffset = s.offset,\n            l = y(t.x2, t.x + (t.len || 0)),\n            h = o.borderRadius,\n            d = this.chart.plotTop,\n            g = this.chart.plotLeft,\n            x = t.plotX,\n            v = e.translate(l, 0, 0, 0, 1),\n            k = Math.abs(v - x),\n            _A3 = this.chart.inverted,\n            S = y(o.borderWidth, 1),\n            C,\n            w,\n            P = s.offset,\n            O = Math.round(s.width),\n            B,\n            E,\n            T,\n            D;\n          r && ((C = r - k) < 0 && (C = 0), x -= C / 2, v += C / 2), x = Math.max(x, -10), v = c(v, -10, e.len + 10), u(t.options.pointWidth) && (P -= (Math.ceil(t.options.pointWidth) - O) / 2, O = Math.ceil(t.options.pointWidth)), o.pointPlacement && f(t.plotY) && i.categories && (t.plotY = i.translate(t.y, 0, 1, 0, 1, o.pointPlacement));\n          var G = p(Math.min(x, v), S),\n            R = p(Math.max(x, v), S) - G,\n            I = Math.min(M(\"object\" == _typeof(h) ? h.radius : h || 0, O), Math.min(R, O) / 2),\n            j = {\n              x: G,\n              y: p((t.plotY || 0) + P, S),\n              width: R,\n              height: O,\n              r: I\n            };\n          t.shapeArgs = j, _A3 ? t.tooltipPos[1] += a + n : t.tooltipPos[0] -= n + a - j.width / 2, E = (B = j.x) + j.width, B < 0 || E > e.len ? (B = c(B, 0, e.len), T = (E = c(E, 0, e.len)) - B, t.dlBox = b(j, {\n            x: B,\n            width: E - B,\n            centerX: T ? T / 2 : null\n          })) : t.dlBox = null;\n          var L = t.tooltipPos,\n            z = _A3 ? 1 : 0,\n            N = _A3 ? 0 : 1,\n            U = this.columnMetrics ? this.columnMetrics.offset : -s.width / 2;\n          _A3 ? L[z] += j.width / 2 : L[z] = c(L[z] + (e.reversed ? -1 : 0) * j.width, e.left - g, e.left + e.len - g - 1), L[N] = c(L[N] + (_A3 ? -1 : 1) * U, i.top - d, i.top + i.len - d - 1), (w = t.partialFill) && (m(w) && (w = w.amount), f(w) || (w = 0), t.partShapeArgs = b(j), D = Math.max(Math.round(k * w + t.plotX - x), 0), t.clipRectArgs = {\n            x: e.reversed ? j.x + k - D : j.x,\n            y: j.y,\n            width: D,\n            height: j.height\n          });\n        }\n      }, {\n        key: \"translate\",\n        value: function translate() {\n          var _iterator5 = _createForOfIteratorHelper((_superPropGet(A, \"translate\", this, 1).apply(this, arguments), this.points)),\n            _step5;\n          try {\n            for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n              var _t28 = _step5.value;\n              this.translatePoint(_t28);\n            }\n          } catch (err) {\n            _iterator5.e(err);\n          } finally {\n            _iterator5.f();\n          }\n        }\n      }, {\n        key: \"drawPoint\",\n        value: function drawPoint(t, e) {\n          var i = this.options,\n            s = this.chart.renderer,\n            o = t.shapeType,\n            r = t.shapeArgs,\n            n = t.partShapeArgs,\n            a = t.clipRectArgs,\n            h = t.state,\n            d = i.states[h || \"normal\"] || {},\n            c = void 0 === h ? \"attr\" : e,\n            p = this.pointAttribs(t, h),\n            u = y(this.chart.options.chart.animation, d.animation),\n            g = t.graphic,\n            x = t.partialFill;\n          if (t.isNull || !1 === t.visible) g && (t.graphic = g.destroy());else if (g ? g.rect[e](r) : (t.graphic = g = s.g(\"point\").addClass(t.getClassName()).add(t.group || this.group), g.rect = s[o](b(r)).addClass(t.getClassName()).addClass(\"highcharts-partfill-original\").add(g)), n && (g.partRect ? (g.partRect[e](b(n)), g.partialClipRect[e](b(a))) : (g.partialClipRect = s.clipRect(a.x, a.y, a.width, a.height), g.partRect = s[o](n).addClass(\"highcharts-partfill-overlay\").add(g).clip(g.partialClipRect))), !this.chart.styledMode && (g.rect[e](p, u).shadow(i.shadow), n)) {\n            m(x) || (x = {}), m(i.partialFill) && (x = b(i.partialFill, x));\n            var _e20 = x.fill || l(p.fill).brighten(-.3).get() || l(t.color || this.color).brighten(-.3).get();\n            p.fill = _e20, g.partRect[c](p, u).shadow(i.shadow);\n          }\n        }\n      }, {\n        key: \"drawPoints\",\n        value: function drawPoints() {\n          var t = this.getAnimationVerb();\n          var _iterator6 = _createForOfIteratorHelper(this.points),\n            _step6;\n          try {\n            for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n              var _e21 = _step6.value;\n              this.drawPoint(_e21, t);\n            }\n          } catch (err) {\n            _iterator6.e(err);\n          } finally {\n            _iterator6.f();\n          }\n        }\n      }, {\n        key: \"getAnimationVerb\",\n        value: function getAnimationVerb() {\n          return this.chart.pointCount < (this.options.animationLimit || 250) ? \"animate\" : \"attr\";\n        }\n      }, {\n        key: \"isPointInside\",\n        value: function isPointInside(t) {\n          var e = t.shapeArgs,\n            i = t.plotX,\n            s = t.plotY;\n          return e ? void 0 !== i && void 0 !== s && s >= 0 && s <= this.yAxis.len && (e.x || 0) + (e.width || 0) >= 0 && i <= this.xAxis.len : _superPropGet(A, \"isPointInside\", this, 1).apply(this, arguments);\n        }\n      }], [{\n        key: \"compose\",\n        value: function compose(t) {\n          v(n, \"Series.XRange\") && d(t, \"afterGetSeriesExtremes\", k);\n        }\n      }]);\n    }(h);\n    return A.defaultOptions = b(h.defaultOptions, o), g(A.prototype, {\n      pointClass: r,\n      pointArrayMap: [\"x2\", \"y\"],\n      getExtremesFromAll: !0,\n      parallelArrays: [\"x\", \"x2\", \"y\"],\n      requireSorting: !1,\n      type: \"xrange\",\n      animate: i.series.prototype.animate,\n      autoIncrement: a,\n      buildKDTree: a\n    }), i.registerSeriesType(\"xrange\", A), A;\n  }), i(e, \"masters/modules/xrange.src.js\", [e[\"Core/Globals.js\"], e[\"Series/XRange/XRangeSeries.js\"]], function (t, e) {\n    return e.compose(t.Axis), t;\n  }), i(e, \"Series/Gantt/GanttPoint.js\", [e[\"Core/Series/SeriesRegistry.js\"], e[\"Core/Utilities.js\"]], function (t, e) {\n    var i = t.seriesTypes.xrange.prototype.pointClass,\n      s = e.pick;\n    var o = /*#__PURE__*/function (_i21) {\n      function o() {\n        _classCallCheck(this, o);\n        return _callSuper(this, o, arguments);\n      }\n      _inherits(o, _i21);\n      return _createClass(o, [{\n        key: \"applyOptions\",\n        value: function applyOptions(t, e) {\n          var i = _superPropGet(o, \"applyOptions\", this, 3)([t, e]);\n          return o.setGanttPointAliases(i), i;\n        }\n      }, {\n        key: \"isValid\",\n        value: function isValid() {\n          return (\"number\" == typeof this.start || \"number\" == typeof this.x) && (\"number\" == typeof this.end || \"number\" == typeof this.x2 || this.milestone);\n        }\n      }], [{\n        key: \"setGanttPointAliases\",\n        value: function setGanttPointAliases(t) {\n          function e(e, i) {\n            void 0 !== i && (t[e] = i);\n          }\n          e(\"x\", s(t.start, t.x)), e(\"x2\", s(t.end, t.x2)), e(\"partialFill\", s(t.completed, t.partialFill));\n        }\n      }]);\n    }(i);\n    return o;\n  }), i(e, \"Series/Gantt/GanttSeriesDefaults.js\", [e[\"Core/Utilities.js\"]], function (t) {\n    var e = t.isNumber;\n    return {\n      grouping: !1,\n      dataLabels: {\n        enabled: !0\n      },\n      tooltip: {\n        headerFormat: '<span style=\"font-size: 0.8em\">{series.name}</span><br/>',\n        pointFormat: null,\n        pointFormatter: function pointFormatter() {\n          var t = this.series,\n            i = t.xAxis,\n            s = t.tooltipOptions.dateTimeLabelFormats,\n            o = i.options.startOfWeek,\n            r = t.tooltipOptions,\n            n = this.options.milestone,\n            a = r.xDateFormat,\n            l = \"<b>\" + (this.name || this.yCategory) + \"</b>\";\n          if (r.pointFormat) return this.tooltipFormatter(r.pointFormat);\n          !a && e(this.start) && (a = t.chart.time.getDateFormat(i.closestPointRange, this.start, o, s || {}));\n          var h = t.chart.time.dateFormat(a, this.start),\n            d = t.chart.time.dateFormat(a, this.end);\n          return l += \"<br/>\", n ? l += h + \"<br/>\" : l += \"Start: \" + h + \"<br/>End: \" + d + \"<br/>\", l;\n        }\n      },\n      connectors: {\n        type: \"simpleConnect\",\n        animation: {\n          reversed: !0\n        },\n        radius: 0,\n        startMarker: {\n          enabled: !0,\n          symbol: \"arrow-filled\",\n          radius: 4,\n          fill: \"#fa0\",\n          align: \"left\"\n        },\n        endMarker: {\n          enabled: !1,\n          align: \"right\"\n        }\n      }\n    };\n  }), i(e, \"Core/Axis/BrokenAxis.js\", [e[\"Core/Axis/Stacking/StackItem.js\"], e[\"Core/Utilities.js\"]], function (t, e) {\n    var i;\n    var s = e.addEvent,\n      o = e.find,\n      r = e.fireEvent,\n      n = e.isArray,\n      a = e.isNumber,\n      l = e.pick;\n    return function (e) {\n      function i() {\n        void 0 !== this.brokenAxis && this.brokenAxis.setBreaks(this.options.breaks, !1);\n      }\n      function h() {\n        var _this$brokenAxis;\n        ((_this$brokenAxis = this.brokenAxis) === null || _this$brokenAxis === void 0 ? void 0 : _this$brokenAxis.hasBreaks) && (this.options.ordinal = !1);\n      }\n      function d() {\n        var t = this.brokenAxis;\n        if (t !== null && t !== void 0 && t.hasBreaks) {\n          var _e22 = this.tickPositions,\n            _i22 = this.tickPositions.info,\n            _s10 = [];\n          for (var _i23 = 0; _i23 < _e22.length; _i23++) t.isInAnyBreak(_e22[_i23]) || _s10.push(_e22[_i23]);\n          this.tickPositions = _s10, this.tickPositions.info = _i22;\n        }\n      }\n      function c() {\n        this.brokenAxis || (this.brokenAxis = new f(this));\n      }\n      function p() {\n        var t = this.isDirty,\n          e = this.options.connectNulls,\n          i = this.points,\n          s = this.xAxis,\n          o = this.yAxis;\n        if (t) {\n          var _t29 = i.length;\n          for (; _t29--;) {\n            var _s$brokenAxis, _o$brokenAxis;\n            var _r12 = i[_t29],\n              _n12 = !(null === _r12.y && !1 === e) && ((s === null || s === void 0 || (_s$brokenAxis = s.brokenAxis) === null || _s$brokenAxis === void 0 ? void 0 : _s$brokenAxis.isInAnyBreak(_r12.x, !0)) || (o === null || o === void 0 || (_o$brokenAxis = o.brokenAxis) === null || _o$brokenAxis === void 0 ? void 0 : _o$brokenAxis.isInAnyBreak(_r12.y, !0)));\n            _r12.visible = !_n12 && !1 !== _r12.options.visible;\n          }\n        }\n      }\n      function u() {\n        this.drawBreaks(this.xAxis, [\"x\"]), this.drawBreaks(this.yAxis, l(this.pointArrayMap, [\"y\"]));\n      }\n      function g(t, e) {\n        var _t$brokenAxis2;\n        var i, s, o;\n        var n = this,\n          h = n.points;\n        if (t !== null && t !== void 0 && (_t$brokenAxis2 = t.brokenAxis) !== null && _t$brokenAxis2 !== void 0 && _t$brokenAxis2.hasBreaks) {\n          var _d3 = t.brokenAxis;\n          e.forEach(function (e) {\n            var _t$options;\n            i = (_d3 === null || _d3 === void 0 ? void 0 : _d3.breakArray) || [], s = t.isXAxis ? t.min : l(n.options.threshold, t.min);\n            var c = t === null || t === void 0 || (_t$options = t.options) === null || _t$options === void 0 || (_t$options = _t$options.breaks) === null || _t$options === void 0 ? void 0 : _t$options.filter(function (t) {\n              var e = !0;\n              for (var _s11 = 0; _s11 < i.length; _s11++) {\n                var _o14 = i[_s11];\n                if (_o14.from === t.from && _o14.to === t.to) {\n                  e = !1;\n                  break;\n                }\n              }\n              return e;\n            });\n            h.forEach(function (n) {\n              o = l(n[\"stack\" + e.toUpperCase()], n[e]), i.forEach(function (e) {\n                if (a(s) && a(o)) {\n                  var _i24 = \"\";\n                  s < e.from && o > e.to || s > e.from && o < e.from ? _i24 = \"pointBreak\" : (s < e.from && o > e.from && o < e.to || s > e.from && o > e.to && o < e.from) && (_i24 = \"pointInBreak\"), _i24 && r(t, _i24, {\n                    point: n,\n                    brk: e\n                  });\n                }\n              }), c === null || c === void 0 ? void 0 : c.forEach(function (e) {\n                r(t, \"pointOutsideOfBreak\", {\n                  point: n,\n                  brk: e\n                });\n              });\n            });\n          });\n        }\n      }\n      function x() {\n        var e = this.currentDataGrouping,\n          i = e === null || e === void 0 ? void 0 : e.gapSize,\n          s = this.points.slice(),\n          o = this.yAxis,\n          r = this.options.gapSize,\n          n = s.length - 1;\n        if (r && n > 0) {\n          var _e23, _a11;\n          for (\"value\" !== this.options.gapUnit && (r *= this.basePointRange), i && i > r && i >= this.basePointRange && (r = i); n--;) if (_a11 && !1 !== _a11.visible || (_a11 = s[n + 1]), _e23 = s[n], !1 !== _a11.visible && !1 !== _e23.visible) {\n            if (_a11.x - _e23.x > r) {\n              var _i25 = (_e23.x + _a11.x) / 2;\n              s.splice(n + 1, 0, {\n                isNull: !0,\n                x: _i25\n              }), o.stacking && this.options.stacking && ((o.stacking.stacks[this.stackKey][_i25] = new t(o, o.options.stackLabels, !1, _i25, this.stack)).total = 0);\n            }\n            _a11 = _e23;\n          }\n        }\n        return this.getGraphPath(s);\n      }\n      e.compose = function (t, e) {\n        if (!t.keepProps.includes(\"brokenAxis\")) {\n          t.keepProps.push(\"brokenAxis\"), s(t, \"init\", c), s(t, \"afterInit\", i), s(t, \"afterSetTickPositions\", d), s(t, \"afterSetOptions\", h);\n          var _o15 = e.prototype;\n          _o15.drawBreaks = g, _o15.gappedPath = x, s(e, \"afterGeneratePoints\", p), s(e, \"afterRender\", u);\n        }\n        return t;\n      };\n      var f = /*#__PURE__*/function () {\n        function f(t) {\n          _classCallCheck(this, f);\n          this.hasBreaks = !1, this.axis = t;\n        }\n        return _createClass(f, [{\n          key: \"findBreakAt\",\n          value: function findBreakAt(t, e) {\n            return o(e, function (e) {\n              return e.from < t && t < e.to;\n            });\n          }\n        }, {\n          key: \"isInAnyBreak\",\n          value: function isInAnyBreak(t, e) {\n            var i = this.axis,\n              s = i.options.breaks || [],\n              o = s.length,\n              r,\n              n,\n              h;\n            if (o && a(t)) {\n              for (; o--;) f.isInBreak(s[o], t) && (r = !0, n || (n = l(s[o].showPoints, !i.isXAxis)));\n              h = r && e ? r && !n : r;\n            }\n            return h;\n          }\n        }, {\n          key: \"setBreaks\",\n          value: function setBreaks(t, e) {\n            var i = this,\n              s = i.axis,\n              o = n(t) && !!t.length && !!Object.keys(t[0]).length;\n            s.isDirty = i.hasBreaks !== o, i.hasBreaks = o, t !== s.options.breaks && (s.options.breaks = s.userOptions.breaks = t), s.forceRedraw = !0, s.series.forEach(function (t) {\n              t.isDirty = !0;\n            }), o || s.val2lin !== f.val2Lin || (delete s.val2lin, delete s.lin2val), o && (s.userOptions.ordinal = !1, s.lin2val = f.lin2Val, s.val2lin = f.val2Lin, s.setExtremes = function (t, e, o, r, n) {\n              if (i.hasBreaks) {\n                var _s12;\n                var _o16 = this.options.breaks || [];\n                for (; _s12 = i.findBreakAt(t, _o16);) t = _s12.to;\n                for (; _s12 = i.findBreakAt(e, _o16);) e = _s12.from;\n                e < t && (e = t);\n              }\n              s.constructor.prototype.setExtremes.call(this, t, e, o, r, n);\n            }, s.setAxisTranslation = function () {\n              if (s.constructor.prototype.setAxisTranslation.call(this), i.unitLength = void 0, i.hasBreaks) {\n                var _t30 = s.options.breaks || [],\n                  _e24 = [],\n                  _o17 = [],\n                  _n13 = l(s.pointRangePadding, 0),\n                  _h4 = 0,\n                  _d4,\n                  _c2,\n                  _p4 = s.userMin || s.min,\n                  _u2 = s.userMax || s.max,\n                  _g3,\n                  _x3;\n                _t30.forEach(function (t) {\n                  _c2 = t.repeat || 1 / 0, a(_p4) && a(_u2) && (f.isInBreak(t, _p4) && (_p4 += t.to % _c2 - _p4 % _c2), f.isInBreak(t, _u2) && (_u2 -= _u2 % _c2 - t.from % _c2));\n                }), _t30.forEach(function (t) {\n                  if (_g3 = t.from, _c2 = t.repeat || 1 / 0, a(_p4) && a(_u2)) {\n                    for (; _g3 - _c2 > _p4;) _g3 -= _c2;\n                    for (; _g3 < _p4;) _g3 += _c2;\n                    for (_x3 = _g3; _x3 < _u2; _x3 += _c2) _e24.push({\n                      value: _x3,\n                      move: \"in\"\n                    }), _e24.push({\n                      value: _x3 + t.to - t.from,\n                      move: \"out\",\n                      size: t.breakSize\n                    });\n                  }\n                }), _e24.sort(function (t, e) {\n                  return t.value === e.value ? (\"in\" === t.move ? 0 : 1) - (\"in\" === e.move ? 0 : 1) : t.value - e.value;\n                }), _d4 = 0, _g3 = _p4, _e24.forEach(function (t) {\n                  1 === (_d4 += \"in\" === t.move ? 1 : -1) && \"in\" === t.move && (_g3 = t.value), 0 === _d4 && a(_g3) && (_o17.push({\n                    from: _g3,\n                    to: t.value,\n                    len: t.value - _g3 - (t.size || 0)\n                  }), _h4 += t.value - _g3 - (t.size || 0));\n                }), i.breakArray = _o17, a(_p4) && a(_u2) && a(s.min) && (i.unitLength = _u2 - _p4 - _h4 + _n13, r(s, \"afterBreaks\"), s.staticScale ? s.transA = s.staticScale : i.unitLength && (s.transA *= (_u2 - s.min + _n13) / i.unitLength), _n13 && (s.minPixelPadding = s.transA * (s.minPointOffset || 0)), s.min = _p4, s.max = _u2);\n              }\n            }), l(e, !0) && s.chart.redraw();\n          }\n        }], [{\n          key: \"isInBreak\",\n          value: function isInBreak(t, e) {\n            var i = t.repeat || 1 / 0,\n              s = t.from,\n              o = t.to - t.from,\n              r = e >= s ? (e - s) % i : i - (s - e) % i;\n            return t.inclusive ? r <= o : r < o && 0 !== r;\n          }\n        }, {\n          key: \"lin2Val\",\n          value: function lin2Val(t) {\n            var e = this.brokenAxis,\n              i = e && e.breakArray;\n            if (!i || !a(t)) return t;\n            var s = t,\n              o,\n              r;\n            for (r = 0; r < i.length && !((o = i[r]).from >= s); r++) o.to < s ? s += o.len : f.isInBreak(o, s) && (s += o.len);\n            return s;\n          }\n        }, {\n          key: \"val2Lin\",\n          value: function val2Lin(t) {\n            var e = this.brokenAxis,\n              i = e && e.breakArray;\n            if (!i || !a(t)) return t;\n            var s = t,\n              o,\n              r;\n            for (r = 0; r < i.length; r++) if ((o = i[r]).to <= t) s -= o.len;else if (o.from >= t) break;else if (f.isInBreak(o, t)) {\n              s -= t - o.from;\n              break;\n            }\n            return s;\n          }\n        }]);\n      }();\n      e.Additions = f;\n    }(i || (i = {})), i;\n  }), i(e, \"Core/Axis/GridAxis.js\", [e[\"Core/Axis/Axis.js\"], e[\"Core/Globals.js\"], e[\"Core/Utilities.js\"]], function (t, e, i) {\n    var s, o;\n    var r = e.dateFormats,\n      n = i.addEvent,\n      a = i.defined,\n      l = i.erase,\n      h = i.find,\n      d = i.isArray,\n      c = i.isNumber,\n      p = i.merge,\n      u = i.pick,\n      g = i.timeUnits,\n      x = i.wrap;\n    function f(t) {\n      return i.isObject(t, !0);\n    }\n    function m(t, e) {\n      var i = {\n        width: 0,\n        height: 0\n      };\n      if (e.forEach(function (e) {\n        var s = t[e],\n          o = 0,\n          r = 0,\n          n;\n        f(s) && (o = (n = f(s.label) ? s.label : {}).getBBox ? n.getBBox().height : 0, n.textStr && !c(n.textPxLength) && (n.textPxLength = n.getBBox().width), r = c(n.textPxLength) ? Math.round(n.textPxLength) : 0, n.textStr && (r = Math.round(n.getBBox().width)), i.height = Math.max(o, i.height), i.width = Math.max(r, i.width));\n      }), \"treegrid\" === this.options.type && this.treeGrid && this.treeGrid.mapOfPosToGridNode) {\n        var _t31 = this.treeGrid.mapOfPosToGridNode[-1].height || 0;\n        i.width += this.options.labels.indentation * (_t31 - 1);\n      }\n      return i;\n    }\n    function b(t) {\n      var e = this.grid,\n        i = 3 === this.side;\n      if (i || t.apply(this), !(e !== null && e !== void 0 && e.isColumn)) {\n        var _t32 = (e === null || e === void 0 ? void 0 : e.columns) || [];\n        i && (_t32 = _t32.slice().reverse()), _t32.forEach(function (t) {\n          t.getOffset();\n        });\n      }\n      i && t.apply(this);\n    }\n    function y(t) {\n      if (!0 === (this.options.grid || {}).enabled) {\n        var _e25 = this.axisTitle,\n          _i26 = this.height,\n          _o18 = this.horiz,\n          _r13 = this.left,\n          _n14 = this.offset,\n          _a12 = this.opposite,\n          _l10 = this.options,\n          _h5 = this.top,\n          _d5 = this.width,\n          _c3 = this.tickSize(),\n          _p5 = _e25 && _e25.getBBox().width,\n          _g4 = _l10.title.x,\n          _x4 = _l10.title.y,\n          _f3 = u(_l10.title.margin, _o18 ? 5 : 10),\n          _m3 = _e25 ? this.chart.renderer.fontMetrics(_e25).f : 0,\n          _b3 = (_o18 ? _h5 + _i26 : _r13) + (_o18 ? 1 : -1) * (_a12 ? -1 : 1) * (_c3 ? _c3[0] / 2 : 0) + (this.side === s.bottom ? _m3 : 0);\n        t.titlePosition.x = _o18 ? _r13 - (_p5 || 0) / 2 - _f3 + _g4 : _b3 + (_a12 ? _d5 : 0) + _n14 + _g4, t.titlePosition.y = _o18 ? _b3 - (_a12 ? _i26 : 0) + (_a12 ? _m3 : -_m3) / 2 + _n14 + _x4 : _h5 - _f3 + _x4;\n      }\n    }\n    function v() {\n      var e = this.chart,\n        _this$options$grid = this.options.grid,\n        i = _this$options$grid === void 0 ? {} : _this$options$grid,\n        s = this.userOptions;\n      if (i.enabled && function (t) {\n        var e = t.options;\n        e.labels.align = u(e.labels.align, \"center\"), t.categories || (e.showLastLabel = !1), t.labelRotation = 0, e.labels.rotation = 0, e.minTickInterval = 1;\n      }(this), i.columns) {\n        var _o19 = this.grid.columns = [],\n          _r14 = this.grid.columnIndex = 0;\n        for (; ++_r14 < i.columns.length;) {\n          var _n15 = p(s, i.columns[_r14], {\n              isInternal: !0,\n              linkedTo: 0,\n              scrollbar: {\n                enabled: !1\n              }\n            }, {\n              grid: {\n                columns: void 0\n              }\n            }),\n            _a13 = new t(this.chart, _n15, \"yAxis\");\n          _a13.grid.isColumn = !0, _a13.grid.columnIndex = _r14, l(e.axes, _a13), l(e[this.coll] || [], _a13), _o19.push(_a13);\n        }\n      }\n    }\n    function M() {\n      var t = this.axisTitle,\n        e = this.grid,\n        i = this.options;\n      if (!0 === (i.grid || {}).enabled) {\n        var _o20 = this.min || 0,\n          _r15 = this.max || 0,\n          _n16 = this.ticks[this.tickPositions[0]];\n        if (t && !this.chart.styledMode && _n16 !== null && _n16 !== void 0 && _n16.slotWidth && !this.options.title.style.width && t.css({\n          width: \"\".concat(_n16.slotWidth, \"px\")\n        }), this.maxLabelDimensions = this.getMaxLabelDimensions(this.ticks, this.tickPositions), this.rightWall && this.rightWall.destroy(), this.grid && this.grid.isOuterAxis() && this.axisLine) {\n          var _t33 = i.lineWidth;\n          if (_t33) {\n            var _e26 = this.getLinePath(_t33),\n              _n17 = _e26[0],\n              _a14 = _e26[1],\n              _l11 = (this.tickSize(\"tick\") || [1])[0] * (this.side === s.top || this.side === s.left ? -1 : 1);\n            if (\"M\" === _n17[0] && \"L\" === _a14[0] && (this.horiz ? (_n17[2] += _l11, _a14[2] += _l11) : (_n17[1] += _l11, _a14[1] += _l11)), !this.horiz && this.chart.marginRight) {\n              var _t34 = [\"L\", this.left, _n17[2] || 0],\n                _e27 = [_n17, _t34],\n                _s13 = [\"L\", this.chart.chartWidth - this.chart.marginRight, this.toPixels(_r15 + this.tickmarkOffset)],\n                _l12 = [[\"M\", _a14[1] || 0, this.toPixels(_r15 + this.tickmarkOffset)], _s13];\n              this.grid.upperBorder || _o20 % 1 == 0 || (this.grid.upperBorder = this.grid.renderBorder(_e27)), this.grid.upperBorder && (this.grid.upperBorder.attr({\n                stroke: i.lineColor,\n                \"stroke-width\": i.lineWidth\n              }), this.grid.upperBorder.animate({\n                d: _e27\n              })), this.grid.lowerBorder || _r15 % 1 == 0 || (this.grid.lowerBorder = this.grid.renderBorder(_l12)), this.grid.lowerBorder && (this.grid.lowerBorder.attr({\n                stroke: i.lineColor,\n                \"stroke-width\": i.lineWidth\n              }), this.grid.lowerBorder.animate({\n                d: _l12\n              }));\n            }\n            this.grid.axisLineExtra ? (this.grid.axisLineExtra.attr({\n              stroke: i.lineColor,\n              \"stroke-width\": i.lineWidth\n            }), this.grid.axisLineExtra.animate({\n              d: _e26\n            })) : this.grid.axisLineExtra = this.grid.renderBorder(_e26), this.axisLine[this.showAxis ? \"show\" : \"hide\"]();\n          }\n        }\n        if ((e && e.columns || []).forEach(function (t) {\n          return t.render();\n        }), !this.horiz && this.chart.hasRendered && (this.scrollbar || this.linkedParent && this.linkedParent.scrollbar) && this.tickPositions.length) {\n          var _t35, _e28;\n          var _i27 = this.tickmarkOffset,\n            _s14 = this.tickPositions[this.tickPositions.length - 1],\n            _n18 = this.tickPositions[0];\n          for (; (_t35 = this.hiddenLabels.pop()) && _t35.element;) _t35.show();\n          for (; (_e28 = this.hiddenMarks.pop()) && _e28.element;) _e28.show();\n          (_t35 = this.ticks[_n18].label) && (_o20 - _n18 > _i27 ? this.hiddenLabels.push(_t35.hide()) : _t35.show()), (_t35 = this.ticks[_s14].label) && (_s14 - _r15 > _i27 ? this.hiddenLabels.push(_t35.hide()) : _t35.show());\n          var _a15 = this.ticks[_s14].mark;\n          _a15 && _s14 - _r15 < _i27 && _s14 - _r15 > 0 && this.ticks[_s14].isLast && this.hiddenMarks.push(_a15.hide());\n        }\n      }\n    }\n    function k() {\n      var t = this.tickPositions && this.tickPositions.info,\n        e = this.options,\n        i = e.grid || {},\n        s = this.userOptions.labels || {};\n      i.enabled && (this.horiz ? (this.series.forEach(function (t) {\n        t.options.pointRange = 0;\n      }), t && e.dateTimeLabelFormats && e.labels && !a(s.align) && (!1 === e.dateTimeLabelFormats[t.unitName].range || t.count > 1) && (e.labels.align = \"left\", a(s.x) || (e.labels.x = 3))) : \"treegrid\" !== this.options.type && this.grid && this.grid.columns && (this.minPointOffset = this.tickInterval));\n    }\n    function A(t) {\n      var e;\n      var i = this.options,\n        s = t.userOptions,\n        o = i && f(i.grid) ? i.grid : {};\n      !0 === o.enabled && (e = p(!0, {\n        className: \"highcharts-grid-axis \" + (s.className || \"\"),\n        dateTimeLabelFormats: {\n          hour: {\n            list: [\"%H:%M\", \"%H\"]\n          },\n          day: {\n            list: [\"%A, %e. %B\", \"%a, %e. %b\", \"%E\"]\n          },\n          week: {\n            list: [\"Week %W\", \"W%W\"]\n          },\n          month: {\n            list: [\"%B\", \"%b\", \"%o\"]\n          }\n        },\n        grid: {\n          borderWidth: 1\n        },\n        labels: {\n          padding: 2,\n          style: {\n            fontSize: \"0.9em\"\n          }\n        },\n        margin: 0,\n        title: {\n          text: null,\n          reserveSpace: !1,\n          rotation: 0,\n          style: {\n            textOverflow: \"ellipsis\"\n          }\n        },\n        units: [[\"millisecond\", [1, 10, 100]], [\"second\", [1, 10]], [\"minute\", [1, 5, 15]], [\"hour\", [1, 6]], [\"day\", [1]], [\"week\", [1]], [\"month\", [1]], [\"year\", null]]\n      }, s), \"xAxis\" !== this.coll || (a(s.linkedTo) && !a(s.tickPixelInterval) && (e.tickPixelInterval = 350), !(!a(s.tickPixelInterval) && a(s.linkedTo)) || a(s.tickPositioner) || a(s.tickInterval) || a(s.units) || (e.tickPositioner = function (t, i) {\n        var s = this.linkedParent && this.linkedParent.tickPositions && this.linkedParent.tickPositions.info;\n        if (s) {\n          var _o21 = e.units || [],\n            _r16,\n            _n19 = 1,\n            _a16 = \"year\";\n          for (var _t36 = 0; _t36 < _o21.length; _t36++) {\n            var _e29 = _o21[_t36];\n            if (_e29 && _e29[0] === s.unitName) {\n              _r16 = _t36;\n              break;\n            }\n          }\n          var _l13 = c(_r16) && _o21[_r16 + 1];\n          if (_l13) {\n            _a16 = _l13[0] || \"year\";\n            var _t37 = _l13[1];\n            _n19 = _t37 && _t37[0] || 1;\n          } else \"year\" === s.unitName && (_n19 = 10 * s.count);\n          var _h6 = g[_a16];\n          return this.tickInterval = _h6 * _n19, this.chart.time.getTimeTicks({\n            unitRange: _h6,\n            count: _n19,\n            unitName: _a16\n          }, t, i, this.options.startOfWeek);\n        }\n      })), p(!0, this.options, e), this.horiz && (i.minPadding = u(s.minPadding, 0), i.maxPadding = u(s.maxPadding, 0)), c(i.grid.borderWidth) && (i.tickWidth = i.lineWidth = o.borderWidth));\n    }\n    function S(t) {\n      var e = t.userOptions,\n        i = e && e.grid || {},\n        s = i.columns;\n      i.enabled && s && p(!0, this.options, s[0]);\n    }\n    function C() {\n      (this.grid.columns || []).forEach(function (t) {\n        return t.setScale();\n      });\n    }\n    function w(t) {\n      var e = this.horiz,\n        i = this.maxLabelDimensions,\n        _this$options$grid2 = this.options.grid,\n        s = _this$options$grid2 === void 0 ? {} : _this$options$grid2;\n      if (s.enabled && i) {\n        var _o22 = 2 * this.options.labels.distance,\n          _r17 = e ? s.cellHeight || _o22 + i.height : _o22 + i.width;\n        d(t.tickSize) ? t.tickSize[0] = _r17 : t.tickSize = [_r17, 0];\n      }\n    }\n    function P() {\n      this.axes.forEach(function (t) {\n        (t.grid && t.grid.columns || []).forEach(function (t) {\n          t.setAxisSize(), t.setAxisTranslation();\n        });\n      });\n    }\n    function O(t) {\n      var e = this.grid;\n      (e.columns || []).forEach(function (e) {\n        return e.destroy(t.keepEvents);\n      }), e.columns = void 0;\n    }\n    function B(t) {\n      var e = t.userOptions || {},\n        i = e.grid || {};\n      i.enabled && a(i.borderColor) && (e.tickColor = e.lineColor = i.borderColor), this.grid || (this.grid = new R(this)), this.hiddenLabels = [], this.hiddenMarks = [];\n    }\n    function E(t) {\n      var e = this.label,\n        i = this.axis,\n        o = i.reversed,\n        r = i.chart,\n        n = i.options.grid || {},\n        a = i.options.labels,\n        l = a.align,\n        h = s[i.side],\n        d = t.tickmarkOffset,\n        p = i.tickPositions,\n        u = this.pos - d,\n        g = c(p[t.index + 1]) ? p[t.index + 1] - d : (i.max || 0) + d,\n        x = i.tickSize(\"tick\"),\n        f = x ? x[0] : 0,\n        m = x ? x[1] / 2 : 0;\n      if (!0 === n.enabled) {\n        var _s15, _n20, _d6, _c4;\n        if (\"top\" === h ? _n20 = (_s15 = i.top + i.offset) - f : \"bottom\" === h ? _s15 = (_n20 = r.chartHeight - i.bottom + i.offset) + f : (_s15 = i.top + i.len - (i.translate(o ? g : u) || 0), _n20 = i.top + i.len - (i.translate(o ? u : g) || 0)), \"right\" === h ? _c4 = (_d6 = r.chartWidth - i.right + i.offset) + f : \"left\" === h ? _d6 = (_c4 = i.left + i.offset) - f : (_d6 = Math.round(i.left + (i.translate(o ? g : u) || 0)) - m, _c4 = Math.min(Math.round(i.left + (i.translate(o ? u : g) || 0)) - m, i.left + i.len)), this.slotWidth = _c4 - _d6, t.pos.x = \"left\" === l ? _d6 : \"right\" === l ? _c4 : _d6 + (_c4 - _d6) / 2, t.pos.y = _n20 + (_s15 - _n20) / 2, e) {\n          var _i28 = r.renderer.fontMetrics(e),\n            _s16 = e.getBBox().height;\n          if (a.useHTML) t.pos.y += _i28.b + -(_s16 / 2);else {\n            var _e30 = Math.round(_s16 / _i28.h);\n            t.pos.y += (_i28.b - (_i28.h - _i28.f)) / 2 + -((_e30 - 1) * _i28.h / 2);\n          }\n        }\n        t.pos.x += i.horiz && a.x || 0;\n      }\n    }\n    function T(t) {\n      var i = t.axis,\n        s = t.value;\n      if (i.options.grid && i.options.grid.enabled) {\n        var _o23;\n        var _r18 = i.tickPositions,\n          _n21 = (i.linkedParent || i).series[0],\n          _a17 = s === _r18[0],\n          _l14 = s === _r18[_r18.length - 1],\n          _d7 = _n21 && h(_n21.options.data, function (t) {\n            return t[i.isXAxis ? \"x\" : \"y\"] === s;\n          });\n        _d7 && _n21.is(\"gantt\") && (_o23 = p(_d7), e.seriesTypes.gantt.prototype.pointClass.setGanttPointAliases(_o23)), t.isFirst = _a17, t.isLast = _l14, t.point = _o23;\n      }\n    }\n    function D() {\n      var t = this.options,\n        e = t.grid || {},\n        i = this.categories,\n        s = this.tickPositions,\n        o = s[0],\n        r = s[1],\n        n = s[s.length - 1],\n        a = s[s.length - 2],\n        l = this.linkedParent && this.linkedParent.min,\n        h = this.linkedParent && this.linkedParent.max,\n        d = l || this.min,\n        p = h || this.max,\n        u = this.tickInterval,\n        g = c(d) && d >= o + u && d < r,\n        x = c(d) && o < d && o + u > d,\n        f = c(p) && n > p && n - u < p,\n        m = c(p) && p <= n - u && p > a;\n      !0 === e.enabled && !i && (this.isXAxis || this.isLinked) && ((x || g) && !t.startOnTick && (s[0] = d), (f || m) && !t.endOnTick && (s[s.length - 1] = p));\n    }\n    function G(t) {\n      var e;\n      var _this$options$grid3 = this.options.grid,\n        i = _this$options$grid3 === void 0 ? {} : _this$options$grid3;\n      return !0 === i.enabled && this.categories ? this.tickInterval : t.apply(this, (e = arguments, Array.prototype.slice.call(e, 1)));\n    }\n    (o = s || (s = {}))[o.top = 0] = \"top\", o[o.right = 1] = \"right\", o[o.bottom = 2] = \"bottom\", o[o.left = 3] = \"left\";\n    var R = /*#__PURE__*/function () {\n      function R(t) {\n        _classCallCheck(this, R);\n        this.axis = t;\n      }\n      return _createClass(R, [{\n        key: \"isOuterAxis\",\n        value: function isOuterAxis() {\n          var _t$linkedParent;\n          var t = this.axis,\n            e = t.chart,\n            i = t.grid.columnIndex,\n            s = ((_t$linkedParent = t.linkedParent) === null || _t$linkedParent === void 0 ? void 0 : _t$linkedParent.grid.columns) || t.grid.columns || [],\n            o = i ? t.linkedParent : t,\n            r = -1,\n            n = 0;\n          return 3 === t.side && !e.inverted && s.length ? !t.linkedParent : ((e[t.coll] || []).forEach(function (e, i) {\n            e.side !== t.side || e.options.isInternal || (n = i, e !== o || (r = i));\n          }), n === r && (!c(i) || s.length === i));\n        }\n      }, {\n        key: \"renderBorder\",\n        value: function renderBorder(t) {\n          var e = this.axis,\n            i = e.chart.renderer,\n            s = e.options,\n            o = i.path(t).addClass(\"highcharts-axis-line\").add(e.axisGroup);\n          return i.styledMode || o.attr({\n            stroke: s.lineColor,\n            \"stroke-width\": s.lineWidth,\n            zIndex: 7\n          }), o;\n        }\n      }]);\n    }();\n    return r.E = function (t) {\n      return this.dateFormat(\"%a\", t, !0).charAt(0);\n    }, r.W = function (t) {\n      var e = this,\n        i = new this.Date(t);\n      [\"Hours\", \"Milliseconds\", \"Minutes\", \"Seconds\"].forEach(function (t) {\n        e.set(t, i, 0);\n      });\n      var s = (this.get(\"Day\", i) + 6) % 7,\n        o = new this.Date(i.valueOf());\n      this.set(\"Date\", o, this.get(\"Date\", i) - s + 3);\n      var r = new this.Date(this.get(\"FullYear\", o), 0, 1);\n      return 4 !== this.get(\"Day\", r) && (this.set(\"Month\", i, 0), this.set(\"Date\", i, 1 + (11 - this.get(\"Day\", r)) % 7)), (1 + Math.floor((o.valueOf() - r.valueOf()) / 6048e5)).toString();\n    }, {\n      compose: function compose(t, e, i) {\n        return t.keepProps.includes(\"grid\") || (t.keepProps.push(\"grid\"), t.prototype.getMaxLabelDimensions = m, x(t.prototype, \"unsquish\", G), x(t.prototype, \"getOffset\", b), n(t, \"init\", B), n(t, \"afterGetTitlePosition\", y), n(t, \"afterInit\", v), n(t, \"afterRender\", M), n(t, \"afterSetAxisTranslation\", k), n(t, \"afterSetOptions\", A), n(t, \"afterSetOptions\", S), n(t, \"afterSetScale\", C), n(t, \"afterTickSize\", w), n(t, \"trimTicks\", D), n(t, \"destroy\", O), n(e, \"afterSetChartSize\", P), n(i, \"afterGetLabelPosition\", E), n(i, \"labelFormat\", T)), t;\n      }\n    };\n  }), i(e, \"Gantt/Tree.js\", [e[\"Core/Utilities.js\"]], function (t) {\n    var e = t.extend,\n      i = t.isNumber,\n      s = t.pick;\n    function o(t, r, n, a, l, h) {\n      var d = h && h.after,\n        c = h && h.before,\n        p = {\n          data: a,\n          depth: n - 1,\n          id: t,\n          level: n,\n          parent: r || \"\"\n        },\n        u = 0,\n        g = 0,\n        x,\n        f;\n      \"function\" == typeof c && c(p, h);\n      var m = (l[t] || []).map(function (e) {\n        var s = o(e.id, t, n + 1, e, l, h),\n          r = e.start || NaN,\n          a = !0 === e.milestone ? r : e.end || NaN;\n        return x = !i(x) || r < x ? r : x, f = !i(f) || a > f ? a : f, u = u + 1 + s.descendants, g = Math.max(s.height + 1, g), s;\n      });\n      return a && (a.start = s(a.start, x), a.end = s(a.end, f)), e(p, {\n        children: m,\n        descendants: u,\n        height: g\n      }), \"function\" == typeof d && d(p, h), p;\n    }\n    return {\n      getNode: o,\n      getTree: function getTree(t, e) {\n        return o(\"\", null, 1, null, function (t) {\n          var e = [],\n            i = t.reduce(function (t, i) {\n              var _i$parent = i.parent,\n                s = _i$parent === void 0 ? \"\" : _i$parent,\n                o = i.id;\n              return void 0 === t[s] && (t[s] = []), t[s].push(i), o && e.push(o), t;\n            }, {});\n          return Object.keys(i).forEach(function (t) {\n            if (\"\" !== t && -1 === e.indexOf(t)) {\n              var _i$;\n              var _e31 = i[t].map(function (t) {\n                var e = _extends({}, (_objectDestructuringEmpty(t), t));\n                return e;\n              });\n              (_i$ = i[\"\"]).push.apply(_i$, _toConsumableArray(_e31)), delete i[t];\n            }\n          }), i;\n        }(t), e);\n      }\n    };\n  }), i(e, \"Core/Axis/TreeGrid/TreeGridTick.js\", [e[\"Core/Utilities.js\"]], function (t) {\n    var e = t.addEvent,\n      i = t.removeEvent,\n      s = t.isObject,\n      o = t.isNumber,\n      r = t.pick,\n      n = t.wrap;\n    function a() {\n      this.treeGrid || (this.treeGrid = new d(this));\n    }\n    function l(t, e, i, n, a, l, h, d, c) {\n      var p, u, g;\n      var x = r(this.options && this.options.labels, l),\n        f = this.pos,\n        m = this.axis,\n        b = \"treegrid\" === m.options.type,\n        y = t.apply(this, [e, i, n, a, x, h, d, c]);\n      if (b) {\n        var _ref2 = x && s(x.symbol, !0) ? x.symbol : {},\n          _ref2$width = _ref2.width,\n          _t38 = _ref2$width === void 0 ? 0 : _ref2$width,\n          _ref2$padding = _ref2.padding,\n          _e32 = _ref2$padding === void 0 ? m.linkedParent ? 0 : 5 : _ref2$padding,\n          _i29 = x && o(x.indentation) ? x.indentation : 0;\n        g = (u = (p = m.treeGrid.mapOfPosToGridNode) && p[f]) && u.depth || 1, y.x += _t38 + 2 * _e32 + (g - 1) * _i29;\n      }\n      return y;\n    }\n    function h(t) {\n      var n, a, l;\n      var h = this.pos,\n        d = this.axis,\n        c = this.label,\n        p = this.treeGrid,\n        u = this.options,\n        g = p === null || p === void 0 ? void 0 : p.labelIcon,\n        x = c === null || c === void 0 ? void 0 : c.element,\n        f = d.treeGrid,\n        m = d.options,\n        b = d.chart,\n        y = d.tickPositions,\n        v = f.mapOfPosToGridNode,\n        M = r(u === null || u === void 0 ? void 0 : u.labels, m === null || m === void 0 ? void 0 : m.labels),\n        k = M && s(M.symbol, !0) ? M.symbol : {},\n        A = v && v[h],\n        _ref3 = A || {},\n        S = _ref3.descendants,\n        C = _ref3.depth,\n        w = A && S && S > 0,\n        P = \"treegrid\" === m.type && x,\n        O = y.indexOf(h) > -1,\n        B = \"highcharts-treegrid-node-\",\n        E = B + \"level-\",\n        T = b.styledMode;\n      P && A && c.removeClass(RegExp(E + \".*\")).addClass(E + C), t.apply(this, Array.prototype.slice.call(arguments, 1)), P && w ? (n = f.isCollapsed(A), function (t, e, _l$padding) {\n        var i = t.treeGrid,\n          s = !i.labelIcon,\n          n = e.renderer,\n          a = e.xy,\n          l = e.options,\n          h = l.width || 0,\n          d = l.height || 0,\n          c = ((_l$padding = l.padding) !== null && _l$padding !== void 0 ? _l$padding : t.axis.linkedParent) ? 0 : 5,\n          p = {\n            x: a.x - h / 2 - c,\n            y: a.y - d / 2\n          },\n          u = e.collapsed ? 90 : 180,\n          g = e.show && o(p.y),\n          x = i.labelIcon;\n        x || (i.labelIcon = x = n.path(n.symbols[l.type](l.x || 0, l.y || 0, h, d)).addClass(\"highcharts-label-icon\").add(e.group)), x[g ? \"show\" : \"hide\"](), n.styledMode || x.attr({\n          cursor: \"pointer\",\n          fill: r(e.color, \"#666666\"),\n          \"stroke-width\": 1,\n          stroke: l.lineColor,\n          strokeWidth: l.lineWidth || 0\n        }), x[s ? \"attr\" : \"animate\"]({\n          translateX: p.x,\n          translateY: p.y,\n          rotation: u\n        });\n      }(this, {\n        color: !T && c.styles.color || \"\",\n        collapsed: n,\n        group: c.parentGroup,\n        options: k,\n        renderer: c.renderer,\n        show: O,\n        xy: c.xy\n      }), a = B + (n ? \"collapsed\" : \"expanded\"), l = B + (n ? \"expanded\" : \"collapsed\"), c.addClass(a).removeClass(l), T || c.css({\n        cursor: \"pointer\"\n      }), [c, g].forEach(function (t) {\n        t && !t.attachedTreeGridEvents && (e(t.element, \"mouseover\", function () {\n          c.addClass(\"highcharts-treegrid-node-active\"), c.renderer.styledMode || c.css({\n            textDecoration: \"underline\"\n          });\n        }), e(t.element, \"mouseout\", function () {\n          !function (t, e) {\n            var i = s(e.style) ? e.style : {};\n            t.removeClass(\"highcharts-treegrid-node-active\"), t.renderer.styledMode || t.css({\n              textDecoration: i.textDecoration || \"none\"\n            });\n          }(c, M);\n        }), e(t.element, \"click\", function () {\n          p.toggleCollapse();\n        }), t.attachedTreeGridEvents = !0);\n      })) : g && (i(x), c !== null && c !== void 0 && c.css({\n        cursor: \"default\"\n      }), g.destroy());\n    }\n    var d = /*#__PURE__*/function () {\n      function d(t) {\n        _classCallCheck(this, d);\n        this.tick = t;\n      }\n      return _createClass(d, [{\n        key: \"collapse\",\n        value: function collapse(t) {\n          var e = this.tick,\n            i = e.axis,\n            s = i.brokenAxis;\n          if (s && i.treeGrid.mapOfPosToGridNode) {\n            var _o24 = e.pos,\n              _n22 = i.treeGrid.mapOfPosToGridNode[_o24],\n              _a18 = i.treeGrid.collapse(_n22);\n            s.setBreaks(_a18, r(t, !0));\n          }\n        }\n      }, {\n        key: \"destroy\",\n        value: function destroy() {\n          this.labelIcon && this.labelIcon.destroy();\n        }\n      }, {\n        key: \"expand\",\n        value: function expand(t) {\n          var _this$tick = this.tick,\n            e = _this$tick.pos,\n            i = _this$tick.axis,\n            s = i.treeGrid,\n            o = i.brokenAxis,\n            n = s.mapOfPosToGridNode;\n          if (o && n) {\n            var _i30 = n[e],\n              _a19 = s.expand(_i30);\n            o.setBreaks(_a19, r(t, !0));\n          }\n        }\n      }, {\n        key: \"toggleCollapse\",\n        value: function toggleCollapse(t) {\n          var e = this.tick,\n            i = e.axis,\n            s = i.brokenAxis;\n          if (s && i.treeGrid.mapOfPosToGridNode) {\n            var _o25 = e.pos,\n              _n23 = i.treeGrid.mapOfPosToGridNode[_o25],\n              _a20 = i.treeGrid.toggleCollapse(_n23);\n            s.setBreaks(_a20, r(t, !0));\n          }\n        }\n      }], [{\n        key: \"compose\",\n        value: function compose(t) {\n          var i = t.prototype;\n          i.toggleCollapse || (e(t, \"init\", a), n(i, \"getLabelPosition\", l), n(i, \"renderLabel\", h), i.collapse = function (t) {\n            this.treeGrid.collapse(t);\n          }, i.expand = function (t) {\n            this.treeGrid.expand(t);\n          }, i.toggleCollapse = function (t) {\n            this.treeGrid.toggleCollapse(t);\n          });\n        }\n      }]);\n    }();\n    return d;\n  }), i(e, \"Series/TreeUtilities.js\", [e[\"Core/Color/Color.js\"], e[\"Core/Utilities.js\"]], function (t, e) {\n    var i = e.extend,\n      s = e.isArray,\n      o = e.isNumber,\n      r = e.isObject,\n      n = e.merge,\n      a = e.pick,\n      l = e.relativeLength;\n    return {\n      getColor: function getColor(e, i) {\n        var s, o, r, n, l, h;\n        var d = i.index,\n          c = i.mapOptionsToLevel,\n          p = i.parentColor,\n          u = i.parentColorIndex,\n          g = i.series,\n          x = i.colors,\n          f = i.siblings,\n          m = g.points,\n          b = g.chart.options.chart;\n        return e && (s = m[e.i], o = c[e.level] || {}, s && o.colorByPoint && (n = s.index % (x ? x.length : b.colorCount), r = x && x[n]), g.chart.styledMode || (l = a(s && s.options.color, o && o.color, r, p && function (e) {\n          var i = o && o.colorVariation;\n          return i && \"brightness\" === i.key && d && f ? t.parse(e).brighten(i.to * (d / f)).get() : e;\n        }(p), g.color)), h = a(s && s.options.colorIndex, o && o.colorIndex, n, u, i.colorIndex)), {\n          color: l,\n          colorIndex: h\n        };\n      },\n      getLevelOptions: function getLevelOptions(t) {\n        var e, i, l, h, d, c;\n        var p = {};\n        if (r(t)) for (h = o(t.from) ? t.from : 1, c = t.levels, i = {}, e = r(t.defaults) ? t.defaults : {}, s(c) && (i = c.reduce(function (t, i) {\n          var s, l, d;\n          return r(i) && o(i.level) && (l = a((d = n({}, i)).levelIsConstant, e.levelIsConstant), delete d.levelIsConstant, delete d.level, r(t[s = i.level + (l ? 0 : h - 1)]) ? n(!0, t[s], d) : t[s] = d), t;\n        }, {})), d = o(t.to) ? t.to : 1, l = 0; l <= d; l++) p[l] = n({}, e, r(i[l]) ? i[l] : {});\n        return p;\n      },\n      getNodeWidth: function getNodeWidth(t, e) {\n        var i = t.chart,\n          s = t.options,\n          _s$nodeDistance = s.nodeDistance,\n          o = _s$nodeDistance === void 0 ? 0 : _s$nodeDistance,\n          _s$nodeWidth = s.nodeWidth,\n          r = _s$nodeWidth === void 0 ? 0 : _s$nodeWidth,\n          _i$plotSizeX = i.plotSizeX,\n          n = _i$plotSizeX === void 0 ? 1 : _i$plotSizeX;\n        if (\"auto\" === r) {\n          if (\"string\" == typeof o && /%$/.test(o)) return n / (e + parseFloat(o) / 100 * (e - 1));\n          var _t39 = Number(o);\n          return (n + _t39) / (e || 1) - _t39;\n        }\n        return l(r, n);\n      },\n      setTreeValues: function t(e, s) {\n        var o = s.before,\n          r = s.idRoot,\n          n = s.mapIdToNode[r],\n          l = !1 !== s.levelIsConstant,\n          h = s.points[e.i],\n          d = h && h.options || {},\n          c = [],\n          p = 0;\n        e.levelDynamic = e.level - (l ? 0 : n.level), e.name = a(h && h.name, \"\"), e.visible = r === e.id || !0 === s.visible, \"function\" == typeof o && (e = o(e, s)), e.children.forEach(function (o, r) {\n          var n = i({}, s);\n          i(n, {\n            index: r,\n            siblings: e.children.length,\n            visible: e.visible\n          }), o = t(o, n), c.push(o), o.visible && (p += o.val);\n        });\n        var u = a(d.value, p);\n        return e.visible = u >= 0 && (p > 0 || e.visible), e.children = c, e.childrenTotal = p, e.isLeaf = e.visible && !p, e.val = u, e;\n      },\n      updateRootId: function updateRootId(t) {\n        var e, i;\n        return r(t) && (i = r(t.options) ? t.options : {}, e = a(t.rootNode, i.rootId, \"\"), r(t.userOptions) && (t.userOptions.rootId = e), t.rootNode = e), e;\n      }\n    };\n  }), i(e, \"Core/Axis/TreeGrid/TreeGridAxis.js\", [e[\"Core/Axis/BrokenAxis.js\"], e[\"Core/Axis/GridAxis.js\"], e[\"Gantt/Tree.js\"], e[\"Core/Axis/TreeGrid/TreeGridTick.js\"], e[\"Series/TreeUtilities.js\"], e[\"Core/Utilities.js\"]], function (t, e, i, s, o, r) {\n    var n;\n    var a = o.getLevelOptions,\n      l = r.addEvent,\n      h = r.find,\n      d = r.fireEvent,\n      c = r.isArray,\n      p = r.isObject,\n      u = r.isString,\n      g = r.merge,\n      x = r.pick,\n      f = r.removeEvent,\n      m = r.wrap;\n    function b(t, e) {\n      var i = t.collapseEnd || 0,\n        s = t.collapseStart || 0;\n      return i >= e && (s -= .5), {\n        from: s,\n        to: i,\n        showPoints: !1\n      };\n    }\n    function y(t, e, s) {\n      var o = [],\n        r = [],\n        n = {},\n        a = \"boolean\" == typeof e && e,\n        l = {},\n        d = -1,\n        c = i.getTree(t, {\n          after: function after(t) {\n            var e = l[t.pos],\n              i = 0,\n              s = 0;\n            e.children.forEach(function (t) {\n              s += (t.descendants || 0) + 1, i = Math.max((t.height || 0) + 1, i);\n            }), e.descendants = s, e.height = i, e.collapsed && r.push(e);\n          },\n          before: function before(t) {\n            var e, i;\n            var s = p(t.data, !0) ? t.data : {},\n              r = u(s.name) ? s.name : \"\",\n              c = n[t.parent],\n              g = p(c, !0) ? l[c.pos] : null;\n            a && p(g, !0) && (e = h(g.children, function (t) {\n              return t.name === r;\n            })) ? (i = e.pos, e.nodes.push(t)) : i = d++, !l[i] && (l[i] = e = {\n              depth: g ? g.depth + 1 : 0,\n              name: r,\n              id: s.id,\n              nodes: [t],\n              children: [],\n              pos: i\n            }, -1 !== i && o.push(r), p(g, !0) && g.children.push(e)), u(t.id) && (n[t.id] = t), e && !0 === s.collapsed && (e.collapsed = !0), t.pos = i;\n          }\n        });\n      return {\n        categories: o,\n        mapOfIdToNode: n,\n        mapOfPosToGridNode: l = function (t, e) {\n          var _i31 = function i(t, s, o) {\n            var r = t.nodes,\n              n = s + (-1 === s ? 0 : e - 1),\n              a = (n - s) / 2,\n              l = s + a;\n            return r.forEach(function (t) {\n              var e = t.data;\n              p(e, !0) && (e.y = s + (e.seriesIndex || 0), delete e.seriesIndex), t.pos = l;\n            }), o[l] = t, t.pos = l, t.tickmarkOffset = a + .5, t.collapseStart = n + .5, t.children.forEach(function (t) {\n              _i31(t, n + 1, o), n = (t.collapseEnd || 0) - .5;\n            }), t.collapseEnd = n + .5, o;\n          };\n          return _i31(t[\"-1\"], -1, {});\n        }(l, s),\n        collapsedNodes: r,\n        tree: c\n      };\n    }\n    function v(t) {\n      t.target.axes.filter(function (t) {\n        return \"treegrid\" === t.options.type;\n      }).forEach(function (e) {\n        var i = e.options || {},\n          s = i.labels,\n          o = i.uniqueNames,\n          r = i.max,\n          n = !e.treeGrid.mapOfPosToGridNode || e.series.some(function (t) {\n            return !t.hasRendered || t.isDirtyData || t.isDirty;\n          }),\n          l = 0,\n          h,\n          d;\n        if (n) {\n          if (h = e.series.reduce(function (t, e) {\n            return e.visible && ((e.options.data || []).forEach(function (i) {\n              e.options.keys && e.options.keys.length && (i = e.pointClass.prototype.optionsToObject.call({\n                series: e\n              }, i), e.pointClass.setGanttPointAliases(i)), p(i, !0) && (i.seriesIndex = l, t.push(i));\n            }), !0 === o && l++), t;\n          }, []), r && h.length < r) for (var _t40 = h.length; _t40 <= r; _t40++) h.push({\n            name: _t40 + \"‚Äã\"\n          });\n          d = y(h, o || !1, !0 === o ? l : 1), e.categories = d.categories, e.treeGrid.mapOfPosToGridNode = d.mapOfPosToGridNode, e.hasNames = !0, e.treeGrid.tree = d.tree, e.series.forEach(function (t) {\n            var e = (t.options.data || []).map(function (e) {\n              return c(e) && t.options.keys && t.options.keys.length && h.forEach(function (t) {\n                e.indexOf(t.x) >= 0 && e.indexOf(t.x2) >= 0 && (e = t);\n              }), p(e, !0) ? g(e) : e;\n            });\n            t.visible && t.setData(e, !1);\n          }), e.treeGrid.mapOptionsToLevel = a({\n            defaults: s,\n            from: 1,\n            levels: s && s.levels,\n            to: e.treeGrid.tree && e.treeGrid.tree.height\n          }), \"beforeRender\" === t.type && (e.treeGrid.collapsedNodes = d.collapsedNodes);\n        }\n      });\n    }\n    function M(t, e) {\n      var i = this.treeGrid.mapOptionsToLevel || {},\n        s = \"treegrid\" === this.options.type,\n        o = this.ticks,\n        r = o[e],\n        a,\n        l,\n        h;\n      s && this.treeGrid.mapOfPosToGridNode ? ((a = i[(h = this.treeGrid.mapOfPosToGridNode[e]).depth]) && (l = {\n        labels: a\n      }), !r && n ? o[e] = r = new n(this, e, void 0, void 0, {\n        category: h.name,\n        tickmarkOffset: h.tickmarkOffset,\n        options: l\n      }) : (r.parameters.category = h.name, r.options = l, r.addLabel())) : t.apply(this, Array.prototype.slice.call(arguments, 1));\n    }\n    function k(t, e, i, s) {\n      var o = this,\n        r = \"treegrid\" === i.type;\n      o.treeGrid || (o.treeGrid = new C(o)), r && (l(e, \"beforeRender\", v), l(e, \"beforeRedraw\", v), l(e, \"addSeries\", function (t) {\n        if (t.options.data) {\n          var _e33 = y(t.options.data, i.uniqueNames || !1, 1);\n          o.treeGrid.collapsedNodes = (o.treeGrid.collapsedNodes || []).concat(_e33.collapsedNodes);\n        }\n      }), l(o, \"foundExtremes\", function () {\n        o.treeGrid.collapsedNodes && o.treeGrid.collapsedNodes.forEach(function (t) {\n          var e = o.treeGrid.collapse(t);\n          o.brokenAxis && (o.brokenAxis.setBreaks(e, !1), o.treeGrid.collapsedNodes && (o.treeGrid.collapsedNodes = o.treeGrid.collapsedNodes.filter(function (e) {\n            return t.collapseStart !== e.collapseStart || t.collapseEnd !== e.collapseEnd;\n          })));\n        });\n      }), l(o, \"afterBreaks\", function () {\n        \"yAxis\" === o.coll && !o.staticScale && o.chart.options.chart.height && (o.isDirty = !0);\n      }), i = g({\n        grid: {\n          enabled: !0\n        },\n        labels: {\n          align: \"left\",\n          levels: [{\n            level: void 0\n          }, {\n            level: 1,\n            style: {\n              fontWeight: \"bold\"\n            }\n          }],\n          symbol: {\n            type: \"triangle\",\n            x: -5,\n            y: -5,\n            height: 10,\n            width: 10\n          }\n        },\n        uniqueNames: !1\n      }, i, {\n        reversed: !0\n      })), t.apply(o, [e, i, s]), r && (o.hasNames = !0, o.options.showLastLabel = !0);\n    }\n    function A(t) {\n      var _this$chart$this$coll;\n      var e = this.options,\n        i = \"number\" == typeof e.linkedTo ? (_this$chart$this$coll = this.chart[this.coll]) === null || _this$chart$this$coll === void 0 ? void 0 : _this$chart$this$coll[e.linkedTo] : void 0;\n      if (\"treegrid\" === e.type) {\n        if (this.min = x(this.userMin, e.min, this.dataMin), this.max = x(this.userMax, e.max, this.dataMax), d(this, \"foundExtremes\"), this.setAxisTranslation(), this.tickInterval = 1, this.tickmarkOffset = .5, this.tickPositions = this.treeGrid.mapOfPosToGridNode ? this.treeGrid.getTickPositions() : [], i) {\n          var _t41 = i.getExtremes();\n          this.min = x(_t41.min, _t41.dataMin), this.max = x(_t41.max, _t41.dataMax), this.tickPositions = i.tickPositions;\n        }\n        this.linkedParent = i;\n      } else t.apply(this, Array.prototype.slice.call(arguments, 1));\n    }\n    function S(t) {\n      var e = this;\n      \"treegrid\" === e.options.type && e.visible && e.tickPositions.forEach(function (t) {\n        var i = e.ticks[t];\n        i.label && i.label.attachedTreeGridEvents && (f(i.label.element), i.label.attachedTreeGridEvents = !1);\n      }), t.apply(e, Array.prototype.slice.call(arguments, 1));\n    }\n    var C = /*#__PURE__*/function () {\n      function C(t) {\n        _classCallCheck(this, C);\n        this.axis = t;\n      }\n      return _createClass(C, [{\n        key: \"setCollapsedStatus\",\n        value: function setCollapsedStatus(t) {\n          var e = this.axis,\n            i = e.chart;\n          e.series.forEach(function (e) {\n            var s = e.options.data;\n            if (t.id && s) {\n              var _o26 = i.get(t.id),\n                _r19 = s[e.data.indexOf(_o26)];\n              _o26 && _r19 && (_o26.collapsed = t.collapsed, _r19.collapsed = t.collapsed);\n            }\n          });\n        }\n      }, {\n        key: \"collapse\",\n        value: function collapse(t) {\n          var e = this.axis,\n            i = e.options.breaks || [],\n            s = b(t, e.max);\n          return i.push(s), t.collapsed = !0, e.treeGrid.setCollapsedStatus(t), i;\n        }\n      }, {\n        key: \"expand\",\n        value: function expand(t) {\n          var e = this.axis,\n            i = e.options.breaks || [],\n            s = b(t, e.max);\n          return t.collapsed = !1, e.treeGrid.setCollapsedStatus(t), i.reduce(function (t, e) {\n            return (e.to !== s.to || e.from !== s.from) && t.push(e), t;\n          }, []);\n        }\n      }, {\n        key: \"getTickPositions\",\n        value: function getTickPositions() {\n          var t = this.axis,\n            e = Math.floor(t.min / t.tickInterval) * t.tickInterval,\n            i = Math.ceil(t.max / t.tickInterval) * t.tickInterval;\n          return Object.keys(t.treeGrid.mapOfPosToGridNode || {}).reduce(function (s, o) {\n            var r = +o;\n            return r >= e && r <= i && !(t.brokenAxis && t.brokenAxis.isInAnyBreak(r)) && s.push(r), s;\n          }, []);\n        }\n      }, {\n        key: \"isCollapsed\",\n        value: function isCollapsed(t) {\n          var e = this.axis,\n            i = e.options.breaks || [],\n            s = b(t, e.max);\n          return i.some(function (t) {\n            return t.from === s.from && t.to === s.to;\n          });\n        }\n      }, {\n        key: \"toggleCollapse\",\n        value: function toggleCollapse(t) {\n          return this.isCollapsed(t) ? this.expand(t) : this.collapse(t);\n        }\n      }], [{\n        key: \"compose\",\n        value: function compose(o, r, a, l) {\n          if (!o.keepProps.includes(\"treeGrid\")) {\n            var _t42 = o.prototype;\n            o.keepProps.push(\"treeGrid\"), m(_t42, \"generateTick\", M), m(_t42, \"init\", k), m(_t42, \"setTickInterval\", A), m(_t42, \"redraw\", S), _t42.utils = {\n              getNode: i.getNode\n            }, n || (n = l);\n          }\n          return e.compose(o, r, l), t.compose(o, a), s.compose(l), o;\n        }\n      }]);\n    }();\n    return C;\n  }), i(e, \"Series/Gantt/GanttSeries.js\", [e[\"Series/Gantt/GanttPoint.js\"], e[\"Series/Gantt/GanttSeriesDefaults.js\"], e[\"Gantt/Pathfinder.js\"], e[\"Core/Series/SeriesRegistry.js\"], e[\"Extensions/StaticScale.js\"], e[\"Core/Axis/TreeGrid/TreeGridAxis.js\"], e[\"Core/Utilities.js\"]], function (t, e, i, s, o, r, n) {\n    var a = s.series,\n      l = s.seriesTypes.xrange,\n      h = n.extend,\n      d = n.isNumber,\n      c = n.merge;\n    var p = /*#__PURE__*/function (_l15) {\n      function p() {\n        _classCallCheck(this, p);\n        return _callSuper(this, p, arguments);\n      }\n      _inherits(p, _l15);\n      return _createClass(p, [{\n        key: \"drawPoint\",\n        value: function drawPoint(t, e) {\n          var i = this.options,\n            s = this.chart.renderer,\n            o = t.shapeArgs,\n            r = t.plotY,\n            n = t.selected && \"select\",\n            a = i.stacking && !i.borderRadius,\n            l = t.graphic,\n            h;\n          t.options.milestone ? d(r) && null !== t.y && !1 !== t.visible ? (h = s.symbols.diamond(o.x || 0, o.y || 0, o.width || 0, o.height || 0), l ? l[e]({\n            d: h\n          }) : t.graphic = l = s.path(h).addClass(t.getClassName(), !0).add(t.group || this.group), this.chart.styledMode || t.graphic.attr(this.pointAttribs(t, n)).shadow(i.shadow, null, a)) : l && (t.graphic = l.destroy()) : _superPropGet(p, \"drawPoint\", this, 3)([t, e]);\n        }\n      }, {\n        key: \"translatePoint\",\n        value: function translatePoint(t) {\n          var e, i;\n          _superPropGet(p, \"translatePoint\", this, 3)([t]), t.options.milestone && (i = (e = t.shapeArgs).height || 0, t.shapeArgs = {\n            x: (e.x || 0) - i / 2,\n            y: e.y,\n            width: i,\n            height: i\n          });\n        }\n      }], [{\n        key: \"compose\",\n        value: function compose(t, e, s, n) {\n          l.compose(t), e && (o.compose(t, e), s) && (i.compose(e, s.prototype.pointClass), n && r.compose(t, e, s, n));\n        }\n      }]);\n    }(l);\n    return p.defaultOptions = c(l.defaultOptions, e), h(p.prototype, {\n      pointArrayMap: [\"start\", \"end\", \"y\"],\n      pointClass: t,\n      setData: a.prototype.setData\n    }), s.registerSeriesType(\"gantt\", p), p;\n  }), i(e, \"masters/modules/gantt.src.js\", [e[\"Core/Globals.js\"], e[\"Extensions/ArrowSymbols.js\"], e[\"Gantt/Connection.js\"], e[\"Extensions/CurrentDateIndication.js\"], e[\"Core/Chart/GanttChart.js\"], e[\"Stock/Navigator/Navigator.js\"], e[\"Stock/RangeSelector/RangeSelector.js\"], e[\"Stock/Scrollbar/Scrollbar.js\"], e[\"Series/Gantt/GanttSeries.js\"]], function (t, e, i, s, o, r, n, a, l) {\n    return t.Connection = t.Connection || i, t.GanttChart = t.GanttChart || o, t.Navigator = t.Navigator || r, t.RangeSelector = t.RangeSelector || n, t.Scrollbar = t.Scrollbar || a, t.ganttChart = t.GanttChart.ganttChart, e.compose(t.SVGRenderer), s.compose(t.Axis, t.PlotLineOrBand), l.compose(t.Axis, t.Chart, t.Series, t.Tick), t.Navigator.compose(t.Chart, t.Axis, t.Series), t.RangeSelector.compose(t.Axis, t.Chart), t.Scrollbar.compose(t.Axis), t;\n  });\n});\n\n//# sourceURL=webpack://medaxion-custom-visualizations/./node_modules/highcharts/modules/gantt.js?");

/***/ }),

/***/ "./src/common/utils.ts":
/*!*****************************!*\
  !*** ./src/common/utils.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getMinMaxDatetimes = exports.processQueryResponse = exports.handleErrors = exports.formatType = void 0;\nconst formatType = (valueFormat, value) => {\n    if (value === 0)\n        return 0;\n    if (!value || !valueFormat) {\n        return 0;\n    }\n    ;\n    switch (valueFormat) {\n        case \"date_time\":\n        case \"date_date\":\n        case \"date_month\":\n        case \"date_quarter\":\n        case \"date_week\":\n        case \"date_year\":\n            return new Date(value).valueOf();\n        default:\n            return parseInt(value);\n    }\n};\nexports.formatType = formatType;\nconst handleErrors = (vis, res, options) => {\n    const check = (group, noun, count, min, max) => {\n        if (!vis.addError || !vis.clearErrors)\n            return false;\n        if (count < min) {\n            vis.addError({\n                title: `Not Enough ${noun}s`,\n                message: `This visualization requires ${min === max ? \"exactly\" : \"at least\"} ${min} ${noun.toLowerCase()}${min === 1 ? \"\" : \"s\"}.`,\n                group,\n            });\n            return false;\n        }\n        if (count > max) {\n            vis.addError({\n                title: `Too Many ${noun}s`,\n                message: `This visualization requires ${min === max ? \"exactly\" : \"no more than\"} ${max} ${noun.toLowerCase()}${min === 1 ? \"\" : \"s\"}.`,\n                group,\n            });\n            return false;\n        }\n        vis.clearErrors(group);\n        return true;\n    };\n    const { pivots, dimensions, measure_like: measures } = res.fields;\n    return (check(\"pivot-req\", \"Pivot\", pivots.length, options.min_pivots, options.max_pivots) &&\n        check(\"dim-req\", \"Dimension\", dimensions.length, options.min_dimensions, options.max_dimensions) &&\n        check(\"mes-req\", \"Measure\", measures.length, options.min_measures, options.max_measures));\n};\nexports.handleErrors = handleErrors;\n// const calculateExtremes = (extremes) => {\n//   const { dataMin, dataMax } = extremes;\n//   if (dataMin && dataMax && dataMin === dataMax) {\n//     // Single sensor value or sensors readings all same\n//     // Set reasonable min for range where values may be negative\n//     return { dataMin: 0 - Math.abs(dataMin), dataMax: dataMax };\n//   } else {\n//     return extremes;\n//   }\n// };\n/**\n * Returns tuple in the order [pivotKey[], dimensions[], measures[]]\n * @param queryResponse\n */\nconst processQueryResponse = (queryResponse) => {\n    var _a;\n    let pivots = (_a = queryResponse.pivots) === null || _a === void 0 ? void 0 : _a.map((pivot) => pivot.key);\n    let dimensions = queryResponse.fields.dimensions.map((dimension) => {\n        return {\n            name: dimension === null || dimension === void 0 ? void 0 : dimension.name,\n            type: dimension === null || dimension === void 0 ? void 0 : dimension.type,\n            title: dimension.label_short.trim().replace(/\\r?\\n/g, \"\"),\n        };\n    });\n    let measures = queryResponse.fields.measures.map((measure) => {\n        return {\n            name: measure.name,\n            type: measure.type,\n            title: measure.view_label.trim().replace(/\\r?\\n/g, \"\"),\n        };\n    });\n    return [pivots, dimensions, measures];\n};\nexports.processQueryResponse = processQueryResponse;\nconst getMinMaxDatetimes = (data, timeSeries) => {\n    let minTime = 0;\n    let maxTime = 0;\n    let maxIndex = 0;\n    data.map((datum, i) => {\n        var _a, _b, _c, _d;\n        let timePoint = (0, exports.formatType)((_a = timeSeries[0]) === null || _a === void 0 ? void 0 : _a.type, (_c = datum[(_b = timeSeries[0]) === null || _b === void 0 ? void 0 : _b.name]) === null || _c === void 0 ? void 0 : _c.value);\n        if (!maxTime || timePoint > maxTime) {\n            maxTime = timePoint;\n            maxIndex = i;\n            console.log(datum[(_d = timeSeries[0]) === null || _d === void 0 ? void 0 : _d.name]);\n        }\n        else if (!minTime || timePoint < minTime) {\n            minTime = timePoint;\n        }\n    });\n    return [minTime, maxTime, maxIndex];\n};\nexports.getMinMaxDatetimes = getMinMaxDatetimes;\n\n\n//# sourceURL=webpack://medaxion-custom-visualizations/./src/common/utils.ts?");

/***/ }),

/***/ "./src/visualizations/gantt.ts":
/*!*************************************!*\
  !*** ./src/visualizations/gantt.ts ***!
  \*************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst utils_1 = __webpack_require__(/*! ../common/utils */ \"./src/common/utils.ts\");\nconst highcharts_1 = __importDefault(__webpack_require__(/*! highcharts */ \"./node_modules/highcharts/highcharts.js\"));\n// import More from 'highcharts/highcharts-more';\nconst gantt_1 = __importDefault(__webpack_require__(/*! highcharts/modules/gantt */ \"./node_modules/highcharts/modules/gantt.js\"));\n// More(Highcharts);\n(0, gantt_1.default)(highcharts_1.default);\nconst vis = {\n    id: \"gantt-chart\",\n    label: \"Gantt Chart\",\n    options: {\n        chartTitle: {\n            type: \"string\",\n            label: \"Chart Title\",\n            display: \"text\",\n            section: \"Style\",\n        },\n        yAxisCategories: {\n            type: \"array\",\n            label: \"Y-Axis Categories\",\n            display: \"text\",\n            section: \"Style\",\n        },\n        refBand1Name: {\n            type: \"string\",\n            label: \"Reference Band 1 Name\",\n            display: \"text\",\n            default: \"Reference Band 1\",\n            section: \"Style\",\n        },\n        refBand2Name: {\n            type: \"string\",\n            label: \"Reference Band 2 Name\",\n            display: \"text\",\n            default: \"Reference Band 2\",\n            section: \"Style\",\n        },\n        refBand1Color: {\n            type: \"string\",\n            label: \"Reference Band 1 Color\",\n            display: \"color\",\n            section: \"Style\",\n            default: \"rgba(68, 170, 213, 0.1)\"\n        },\n        refBand2Color: {\n            type: \"string\",\n            label: \"Reference Band 2 Color\",\n            display: \"color\",\n            section: \"Style\",\n            default: \"rgba(68, 170, 213, 0.1)\"\n        },\n        nameDim: {\n            type: \"string\",\n            label: \"Name Dimension\",\n            display: \"select\",\n            values: [],\n            section: \"Data\",\n        },\n        startDim: {\n            type: \"string\",\n            label: \"Start Dimension\",\n            display: \"select\",\n            values: [],\n            section: \"Data\",\n        },\n        endDim: {\n            type: \"string\",\n            label: \"End Dimension\",\n            display: \"select\",\n            values: [],\n            section: \"Data\",\n        },\n        ref1BandStart: {\n            type: \"string\",\n            label: \"Reference Band 1 Start\",\n            display: \"select\",\n            values: [],\n            section: \"Data\",\n        },\n        ref1BandEnd: {\n            type: \"string\",\n            label: \"Reference Band 1 End\",\n            display: \"select\",\n            values: [],\n            section: \"Data\",\n        },\n        ref2BandStart: {\n            type: \"string\",\n            label: \"Reference Band 2 Start\",\n            display: \"select\",\n            values: [],\n            section: \"Data\",\n        },\n        ref2BandEnd: {\n            type: \"string\",\n            label: \"Reference Band 2 End\",\n            display: \"select\",\n            values: [],\n            section: \"Data\",\n        },\n        colorCategory: {\n            type: \"string\",\n            label: \"Color By Category\",\n            display: \"select\",\n            values: [],\n            section: \"Data\",\n        },\n    },\n    create(element, config) {\n        element.className = \"highcharts-gantt-vis\";\n    },\n    update(data, element, config, queryResponse) {\n        var _a;\n        (0, utils_1.handleErrors)(this, queryResponse, {\n            min_pivots: 0,\n            max_pivots: 0,\n            min_dimensions: 1,\n            max_dimensions: 10,\n            min_measures: 0,\n            max_measures: 1,\n        });\n        const { dimension_like: dimensions } = queryResponse.fields;\n        // Populate the select options for dimensions\n        const dimensionOptions = dimensions.map(dim => ({ [dim.label]: dim.name }));\n        const optionsToSet = ['nameDim', 'startDim', 'endDim', 'ref1BandStart', 'ref1BandEnd', 'ref2BandStart', 'ref2BandEnd', 'colorCategory'];\n        optionsToSet.forEach(option => {\n            this.options[option].values = dimensionOptions;\n        });\n        const colorCategory = config.colorCategory || dimensions[7].name;\n        // For each distinct data point value in the colorCategory, make an option for assigning a color.\n        const colorCategoryValues = data.map(row => row[colorCategory].value).filter((value, index, self) => self.indexOf(value) === index);\n        colorCategoryValues.forEach((value, index) => {\n            this.options[`colorFor${value}`] = {\n                type: \"string\",\n                label: `Color for ${value}`,\n                display: \"color\",\n                section: \"Style\",\n            };\n        });\n        // @ts-ignore\n        this.trigger && this.trigger(\"registerOptions\", this.options);\n        const nameDim = config.nameDim || dimensions[0].name;\n        const startDim = config.startDim || dimensions[1].name;\n        const endDim = config.endDim || dimensions[2].name;\n        const refBand1Start = config.ref1BandStart || dimensions[3].name;\n        const refBand1End = config.ref1BandEnd || dimensions[4].name;\n        const refBand2Start = config.ref2BandStart || dimensions[5].name;\n        const refBand2End = config.ref2BandEnd || dimensions[6].name;\n        const getColor = (category) => {\n            return config[`colorFor${category}`] || 'black';\n        };\n        // Group data by nameDim\n        const groupedData = data.reduce((acc, row) => {\n            const name = row[nameDim].value;\n            if (!acc[name]) {\n                // @ts-ignore\n                acc[name] = [];\n            }\n            acc[name].push({\n                name: row[nameDim].value,\n                start: new Date(row[startDim].value).getTime(),\n                end: new Date(row[endDim].value).getTime(),\n                color: row[colorCategory] ? getColor(row[colorCategory].value) : undefined,\n            });\n            return acc;\n        }, {});\n        const categories = Object.keys(groupedData);\n        // Assign yAxis index to each data point\n        Object.keys(groupedData).forEach((name, index) => {\n            // @ts-ignore\n            groupedData[name].forEach(item => {\n                item.y = index;\n            });\n        });\n        const firstRow = data[0];\n        const refBands = {\n            refBand1Start: new Date(firstRow[refBand1Start].value).getTime(),\n            refBand1End: new Date(firstRow[refBand1End].value).getTime(),\n            refBand2Start: new Date(firstRow[refBand2Start].value).getTime(),\n            refBand2End: new Date(firstRow[refBand2End].value).getTime(),\n        };\n        console.log('refbands:', refBands);\n        // @ts-ignore\n        const series = Object.keys(groupedData).map((name) => ({\n            name,\n            data: groupedData[name],\n            type: \"gantt\",\n            showInLegend: false,\n            marker: { enabled: false },\n        }));\n        // Add custom legend items for reference bands and color categories\n        const legendItems = [\n            {\n                name: config.refBand1Name || 'Reference Band 1',\n                color: config.refBand1Color,\n                marker: { symbol: 'square' }\n            },\n            {\n                name: config.refBand2Name || 'Reference Band 2',\n                color: config.refBand2Color,\n                marker: { symbol: 'square' },\n            },\n            ...colorCategoryValues.map(value => ({\n                name: value,\n                color: getColor(value),\n                marker: { symbol: 'circle' }\n            }))\n        ];\n        const options = {\n            chart: {\n                type: 'gantt'\n            },\n            time: {\n                useUTC: false,\n            },\n            title: {\n                text: config.chartTitle || 'Gantt Chart'\n            },\n            yAxis: {\n                uniqueNames: true,\n                categories: categories,\n                title: {\n                    text: config.yAxisCategories || 'Categories'\n                }\n            },\n            xAxis: {\n                type: 'datetime',\n                labels: {\n                    format: '{value:%H:%M}',\n                    align: 'right'\n                },\n                plotBands: [\n                    {\n                        from: refBands.refBand1Start,\n                        to: refBands.refBand1End,\n                        color: config.refBand1Color || 'rgba(68, 170, 213, 0.1)',\n                    },\n                    {\n                        from: refBands.refBand2Start,\n                        to: refBands.refBand2End,\n                        color: config.refBand2Color || 'rgba(68, 170, 213, 0.1)',\n                    }\n                ]\n            },\n            legend: {\n                enabled: true,\n                useHTML: true,\n                itemStyle: {\n                    display: 'flex',\n                    alignItems: 'center'\n                },\n                symbolRadius: 0,\n                symbolHeight: 0,\n                symbolWidth: 0,\n                squareSymbol: false,\n                labelFormatter: function () {\n                    var _a;\n                    const item = legendItems.find(i => i.name === this.name);\n                    return `<span style=\"display: inline-block; width: 12px; height: 12px; background-color: ${item === null || item === void 0 ? void 0 : item.color}; margin-right: 5px; shape-outside: ${((_a = item === null || item === void 0 ? void 0 : item.marker) === null || _a === void 0 ? void 0 : _a.symbol) === 'square' ? 'square' : 'circle'};\"></span>${this.name}`;\n                    // return `<span style=\"color:${item?.color}\">${this.name}</span>`;\n                }\n            },\n            tooltip: {\n                enabled: true,\n                formatter: function () {\n                    const point = this.point;\n                    const categoryIndex = point.y;\n                    const category = categories[Number(categoryIndex) || 0];\n                    console.log('point:', point);\n                    const colorCategory = point.color;\n                    const colorCategoryName = colorCategoryValues.find(value => getColor(value) === colorCategory);\n                    const x2 = point === null || point === void 0 ? void 0 : point.x2;\n                    const start = highcharts_1.default.dateFormat('%Y-%m-%d %H:%M', point === null || point === void 0 ? void 0 : point.x);\n                    const end = highcharts_1.default.dateFormat('%Y-%m-%d %H:%M', x2);\n                    const durationMs = x2 - (point === null || point === void 0 ? void 0 : point.x);\n                    const durationHours = Math.floor(durationMs / 3600000);\n                    const durationMinutes = Math.floor((durationMs % 3600000) / 60000);\n                    const duration = `${durationHours} hours ${durationMinutes} minutes`;\n                    return `\n            <b>${config.yAxisCategories}: ${category}</b><br/>\n            <b>Category:</b> <span style=\"color: ${colorCategory};\">${colorCategoryName}</span><br/>\n            <b>Start:</b> ${start}<br/>\n            <b>End:</b> ${end}<br/>\n            <b>Duration:</b> ${duration}`;\n                }\n            },\n            series: [\n                ...series,\n                ...legendItems.map(item => ({\n                    name: item.name,\n                    color: item.color,\n                    data: [],\n                }))\n            ]\n        };\n        // @ts-ignore\n        console.log('options.x.plotbands:', (_a = options.xAxis) === null || _a === void 0 ? void 0 : _a.plotBands);\n        highcharts_1.default.ganttChart(element, options);\n    },\n};\nlooker.plugins.visualizations.add(vis);\n\n\n//# sourceURL=webpack://medaxion-custom-visualizations/./src/visualizations/gantt.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.nmd = (module) => {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./src/visualizations/gantt.ts");
/******/ 	
/******/ })()
;